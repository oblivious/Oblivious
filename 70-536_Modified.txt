Microsoft 70-536 



70-536 TS: Microsoft .NET Framework - Application 
Development Foundation 
Practice Test 


Version 6.0 

Microsoft 70-536: Practice Exam 











QUESTION NO: 1 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are in the process of storing numerical values up to 2,100,000,000 into a variable and may 
require storing negative values using a .NET Framework 2.0 application. You are required to 
optimize memory usage 

What should you do? 

A. Int32 
B. UInt16 
C. UInt32 
D. Int16 




















Answer: A 

Explanation: 

The Int32 type should be used in the scenario as it can be used to store positive and negative 
numerical values from -2,147,483,648 to +2,147,483,647. 

Incorrect Answers: 

B: The UINT32 and UInt16 type should not be used in the scenario because they are used to store 
only unsigned positive numbers. 
Reference types 
C: The UINT32 and UInt16 type should not be used in the scenario because they are used to store 
only unsigned positive numbers. 
Attributes 
D: The Int16 type should not be used as you will only be allowed to store values from -32768 to 
+32768. 










QUESTION NO: 2 

You work as an application developer at CertKiller.com. You are currently in the process of 
creating a class that stores data about CertKiller.com's customers. 

CertKiller.com customers are assigned unique identifiers and various characteristics that may 
include aliases, shipping instructions, and sales comments. These characteristics can change in 
both size and data type. 

You start by defining the Customer class as shown below: 

public class Customer { 
private int custID; 
private ArrayList attributes; 
public int CustomerID 
{ 
get {return custID;} 
} 
public Customer (int CustomerID) 
{ 
this.custID = CustomerID; 
this.attributes = new ArrayList (); 
} 
public void AddAttribute (object att) 
{ 
attributes.Add (att); 
} 
} 

You have to create the FindAttribute method for locating attributes in Customer objects no matter 
what the data type is. 

You need to ensure that the FindAttribute method returns the attribute if found, and you also need 
to ensure type-safety when returning the attribute. 

What should you do? 

A. Use the following code to declare the FindAttribute method: 
public T FindAttribute (T att) 
{ 
//Find attribute and return the value 
} 


B. Use the following code to declare the FindAttribute method: 
public object FindAttribute (object att) 
{ 
//Find attribute and return the value 
} 


C. Use the following code to declare the FindAttribute method: 
public T FindAttribute <T> (T att) 
{ 
//Find attribute and return the value 
} 


D. Use the following code to declare the FindAttribute method: 
public string FindAttribute (string att) 
{

 //Find attribute and return the value 
} 





















Answer: C 

Explanation: 

This code declares the method FindAttribute and specifies an argument named att using the T 
placeholder as the argument and return data type. To ensure the FindAttribute method accepts 
arguments of different types, you should specify an argument using a generic placeholder. The 
argument att in this generic method will accept any valid data type and ensures type-safety by 
returning that same data type. 

Incorrect Answers: 

A: You should not use this code because it does not declare the placeholder T. when declaring a 
generic method, you have to use the < > brackets to declare the place holder before using it. 
B: You should not use this code because it does not guarantee type-safery. 
D: You should not use this code because it will only accept a string argument and return a string 
argument. 
Generic types 










QUESTION NO: 3 

You work as an application developer at CertKiller.com. You are creating a custom exception 
class named ProductDoesNotExistException so that custom exception messages are displayed in 
a new application when the product specified by users is unavailable. 

This custom exception class will take the ProductID as an argument to its constructor and expose 
this value through the ProductID. You are now in the process of creating a method named 
UpdateProduct. This method will be used to generate and manage the 
ProductDoesNotExistException exception if the ProductID variable contains the value 0. 

You need to ensure that use the appropriate code for the UpdateProduct method. 

What should you do? 

A. Make use of the following code: 
public void UpdateProduct () 
{ 
try 
{ 
if (ProductID == 0) 
throw new ProductDoesNotExistException (ProductID); 
} 
catch (ProductDoesNotExistException ex) 
{ 
MessageBox.Show ("There is no Product" + ex. ProductID); 
} 

} 

B. Make use of the following code: 
public void UpdateProduct () 
{ 
try 
{ 
if (ProductID = = 0) 
throw new Exception ("Invalid ProductID"); 
} 
catch (ProductDoesNotExistException ex) 
{ 
MessageBox.Show (ex.Message); 
} 

} 


C. Make use of the following code: 
public void UpdateProduct () 
{ 
if (ProductID = = 0) 
throw new ProductDoesNotExistException (ProductID); 
} 

D. Make use of the following code: 
public void UpdateProduct () 
{ 
if (ProductID = = 0) 
throw new Exception ("Invalid ProductID"); 
} 





















Answer: A 

Explanation: 

This code verifies the value of the ProductID variable by using the if statement. If the ProductID 
variable contains a value of 0, this code generates an exception of type 
ProductDoesNotExistException . To explicitly generate an exception, you are required to use the 
throw statement. The exception generated by using the throw statement can be handled by the 
try...catch block. This code generates the custom exception by calling the constructor of the 
custom exception class named ProductDoesNotExistException . The constructor argument is the 
ProductID attached to the ProductDoesNotExistException object. This code then handles the 
custom exception named ProductDoesNotExistException by using a catch block, which handles exceptions by using a variable named ex of the type ProductDoesNotExistException . This code 
displays the " There is no Product " error message by using the MessageBox.Show method and 
concatenating the ex. ProductID to it. 

Incorrect Answers: 

B: You should not use the code that generates an exception of the type Exception and handles the 
exception of the type ProductDoesNotExistException in the catch block. This code is incorrect 
because you are required to generate a custom exception named ProductDoesNotExistException. 
C: You should not use the codes that do not use a try...catch block because the application an 
unhandled exception. 
D: You should not use the codes that do not use a try...catch block because the application an 
unhandled exception. 










QUESTION NO: 4 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You have recently finished development of a class named TestReward and package the class in a 
.NET 2.0 assembly named TestObj.dll. After you ship the assembly and it is used by client 
applications, you decide to move the TestReward class from TestObj.dll assembly to the 
TestRewardObj.dll Assembly. You are to ensure when you ship the updated TestObj.dll and 
TestRewardObj.dll assemblies that the client applications continue to work and do not require 
recompiling. 

What should you do? 

A. The TypeForwardedTo attribute should be used 
B. The TypeConvertor.ConvertTo method should be used 
C. The InternalsVisibleTo attribute should be used 
D. The Type Convertor.ConvertFrom method should be used 




















Answer: A 

Explanation: 

The statement used for you to add a type from one assembly into another assembly is the 
TypeForwardTo attribute which enables you not to have the application recompiled. 

Incorrect Answers: 

B: The TypeConverter class provides a unified way of converting different types of values to other 
types and can not be used to move a type. 
C: The method in question here specifies all nonpublic types in an assembly are visible to other 
assemblies but can not be used to move types.
D: The TypeConverter class provides a unified way of converting different types of values to other 
types and can not be used to move a type. 










QUESTION NO: 5 

You work as an application developer at CertKiller.com. You have recently created a custom 
collection class named ShoppingList for a local supermarket. This custom class will include 
ShoppingItem objects that have the public properties listed below. 

* Name 
* AisleNumber 
* OnDiscount 

You are required to enable users of your class to iterate through the ShoppingList collection, and 
to list each product name and aisle number using the foreach statement. 

You need to achieve this by declaring the appropriate code. 

What code should you use? 

A. public class ShoppingList : ICollection 
{ 
// Class implementation 
} 

B. public class ShoppingList : IEnumerator, IEnumerable 
{ 
// Class implementation 
} 

C. public class ShoppingList : Ilist 
{ 
// Class implementation 
} 

D. public class ShoppingList : Enum 
{ 
// Class implementation 
} 





















Answer: B 

Explanation: 

You should implement the IEnumerable and IEnumerator interfaces of the System.Collections 
namespace to ensure that your collection class supports foreach iteration. The IEnumerable interface defines only one method named GetEnumerator that returns an object of type 
IEnumerator of the System.Collections namespace and is used to support iteration over a 
collection. The IEnumerator interface supports methods, such as Current , MoveNext , and Reset 
to iterate through a collection. The Current method returns the current element of the collection. 
The Move method positions the enumerator to the next available element of the collection. The 
Reset method positions the enumerator before the first element of the collection. 

Incorrect Answers: 

A: You should not use the code that implements the ICollection interface because this interface is 
used to define properties in a collection. Implementing this interface will not ensure that your 
collection class supports foreach iteration because it does not inherit the IEnumerator interface. 
C: You should not use the code that implements the Ilist interface because this interface is used to 
define properties of a non-generic list of items accessed by index. Implementing this interface will 
not ensure that your collection class supports foreach iteration because it does not inherit the 
IEnumerator interface. 
D: You should not use the code that inherits the Enum because this structure is used as a base 
class for those classes that provide enumeration values. Inheriting the Enum structure will not 
ensure that your collection class supports foreach iteration. 










QUESTION NO: 6 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application used to store a type-safe list of names and 
e-mail addresses. The list will be populated all at ones from the sorted data which means you well 
not always need to perform insertion or deletion operations on the data. You are required to 
choose a data structure that optimizes memory use and has good performance. 

What should you do? 

A. The System.Collections.Generic.SortedList class should be used 
B. The System.Collections.HashTable class should be used 
C. The System.Collections.Generic.SortedDictionary class should be used 
D. The System.Collections.SortedList class should be used 




















Answer: A 

Explanation: 

The SortedList generic class should be used in the scenario class as it provides type safety 
compared against the System.Collections.SortedList class. 

Incorrect Answers: B: The System.Collections.HashTable class should not be used as this class provides no type 
safety. 
Collection interfaces 
C: Although this is very similar to the SortedList class the SortedList class should be used instead 
in the scenario. 
Iterators 
D: Although this is very similar to the SortedList class the SortedList class should be used instead 
in the scenario. 










QUESTION NO: 7 

You work as an application developer at CertKiller.com. You are currently in the process of 
reviewing an application that was created by a fellow developer. 

The application that you are reviewing includes a declaration for a collection named EmployeeList, 
which stores Employee objects. The declaration is shown below: 

public class EmployeeList : IEnumerator, IEnumerable 

{ 
// Class implementation 
} 

You require the ability to iterate through the EmployeeList with minimum development effort. 

What should you do? 

A. Utilize the switch statement 
B. Utilize the dowhile statement 
C. Utilize the foreach statement 
D. Utilize the if statement 




















Answer: C 

Explanation: 

the IEnumerable and IEnumerator interfaces of the System.Collections namespace are used to 
ensure that your collection class supports foreach iteration. The IEnumerable interface defines 
only one method named GetEnumerator that returns an object of type IEnumerator of the 
System.Collections namespace and is used to support iteration over a collection. The 
IEnumerator interface supports methods, such as Current , MoveNext , and Reset to iterate 
through a collection. The Current method returns the current element of the collection. The Move 
method positions the enumerator to the next available element of the collection. The Reset method positions the enumerator before the first element of the collection. 

Incorrect Answers: 

A: These statements will not allow you to iterate through the EmployeeList collection. 
B: You should not use this statement because it will require manually calling the MoveNext and 
Current methods. The scenario states that you need to "...iterate through the EmployeeList with 
minimum development effort." 
D: These statements will not allow you to iterate through the EmployeeList collection. 
Hashtable class 










QUESTION NO: 8 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted to 
develop an application for the local bank. 

You have been given the responsibility of creating this application and need to store each 
transaction record, which is identified using a complex transaction identifier, in memory. The bank 
informs you that the total amount of transaction records could reach 200 per day. 

To achieve this, you decide to utilize one of the existing collection classes in the .NET 2.0 class 
library. 

You need to ensure that you the collection class you select is the most efficient one for storing 
transaction records. 

What should you do? 

A. Select the ListDictionary collection class. 
B. Select the HashTable collection class. 
C. Select the Queue collection class. 
D. Select the StringCollection collection class. 




















Answer: B 

Explanation: 

You should select the HashTable class to store transaction records because each element is 
identified using a unique identifier and the size of the collection is large. Elements in the 
HashTable collection are stored with a key/value pair where each key is created using a hash 
code. The default capacity of a HashTable class is zero, and you can use the Add method to add 
a new element to the collection. The Count property provides the total number of elements in the 
HashTable collection. An element of the HashTable class can be accessed using the 
DictionaryEntry class. You can use the Key and Value properties of the DictionaryEntry class to 
access the key associated with the element and the value of the element, respectively. Incorrect Answers: 

A: You should not select this collection class because this class is used if the total number of 
elements to be stored in a collection is less than 10 elements in length. 
C: You should not select this collection class because you need to access transaction records 
using a transaction identifier, not in sequential order. 
D: You should not select this collection class because this class is used to manage a collection of 
string values. 










QUESTION NO: 9 

You work as an application developer at CertKiller.com. CertKiller.com has been hired by a small 
local private school to develop a class library that will be used in an application named 
ManageAttendance for the purpose of managing student records. 

You are responsible for developing this class library. CertKiller.com has instructed you to create a 
collection in the application to store learners' results. 

The school has informed you that they currently only have seven learners, but that this value will 
triple in the following year. Due to the limited resources, you need to ensure that the collection you 
create consumes a minimum amount of resources. 

What should you use to create the collection? 

A. The HybridDictionary collection class. 
B. The HashTable collection class. 
C. The ListDictionary collection class. 
D. The StringCollection collection class. 




















Answer: A 

Explanation: 

You should use the HybridDictionary class to create the collection because this class is useful in 
scenarios where the number of elements is unknown or could grow in size. A collection of the 
HybridDictionary type manages the collection depending on the number of elements. The 
HybridDictionary type collection uses the ListDictionary class to manage the collection when there 
are only a few elements. When the number of elements exceeds ten, the HybridDictionary type 
collection automatically converts the elements into HashTable management. 

Incorrect Answers: 

B: You should not use this collection class because this class is used if the total number of 
elements to be stored in a collection is known and is greater than ten elements in length. 
C: You should not use this collection class because this class is used if the total number of 
elements to be stored in a collection is known and is less than ten elements in length. 
D: You should not use this collection class because this class is used to manage a collection of 
string values. 










QUESTION NO: 10 

You work as an application developer at CertKiller.com. CertKiller.com wants you to develop an 
application that stores and retrieves client information by means of a unique account number. 


You create a custom collection class, which implements the IDictionary interface, named 
ClientDictionary. The following code have been included into the new application. 


//Create Client objects 
Client c1 = new Client ("AReid", "Andy Reid", Status.Current); 
Client c2 = new Client ("DAustin", "Dean Austin", Status.New); 


//Create ClientDictionary object 
IDictionary cData = new ClientDictionary (); 
cData.Add ("10001", c1); 
cData.Add ("10002", c2); 


You use the same method to add other Client objects to the collection. You need to ensure that 
you are able to retrieve client information associated with the account number 10111. 


What should you do? 


A. Use the following code: 
Client foundClient; 
foundClient = (Client) cData.Find ("10111"); 


B. Use the following code: 
Client foundClient; 
if (cData.Contains ("10111")) 
foundClient = cData ["10111"]; 


C. Use the following code: 
Client foundClient; 
if (cData.Contains ("10111")) 
foundClient = (Client) cData ["10111"]; 


D. Use the following code: 
Client foundClient; 
foreach (string key in cData.Keys 
{ 
if (key == "10111") 
foundClient = (Client) cData.Values ["10111"]; 
} 





















Answer: C 

Explanation: 

This code invokes the Contains method of the IDictionary interface to determine whether a value is 
associated with the key 10111. If a value exists for that key, then the clientData ["10111"] 
statement retrieves the client data as a generic object. The code casts the generic object into a 
Client object, and it is stored in the foundClient variable 

Incorrect Answers: 

A: You should not use the code that uses the Find method because no such method exists in the 
IDictionary interface. 
B: You should not use the code that assigns the foundClient variable to a generic object because 
the foundClient variable is declared as a Client type. 
D: You should not use the code that iterates through the Keys collection because it is unnecessary 
and process-intensive. 










QUESTION NO: 11 

You work as an application developer at CertKiller.com. CertKiller.com has instructed you to 
create a class named MetricFormula. This class will be used to compare MetricUnit and 
EnglishUnit objects. 

The MetricFormula is currently defined as follows (Line numbers are used for reference purposes 
only): 

1. public class MetricFormula 
2. { 
3. 
4. } 
You need to ensure that the MetricFormula class can be used to compare the required objects. 

What should you do? (Choose two) 

A. Add the following code on line 1: 
: IComparable 
{ 

B. Add the following code on line 1: 
: IComparer 
{

C. Add the following code on line 3: 
public int Compare (object x, object y) 
{ 
// implementation code 
}

D. Add the following code on line 3: 
public int CompareTo (object obj) 
{ 
// implementation code 
} 




















Answer: B,C 

Explanation: 

You should add the code so that it reads as follows: 

1. public class MetricFormula : IComparer
2. { 
3. public int Compare (object x, object y)
4. { 
5. // implementation code 
5. } 
6. } 
You have to implement the IComparer interface to create a comparer class for MetricUnit and 
EnglishUnit objects. The IComparer interface provides only one method named Compare . The 
Compare method takes two objects and returns an integer value representing whether those 
objects are equal, greater than, or less than the other. If the return value is negative, then the first 
object is less than the second. The objects are equal if the return value is zero. The first object is 
greater than the first if the return value is positive. The IComparer interface is typically used if you 
want to implement comparison across objects of different classes without having to provide 
implementation in each comparable class. 

Incorrect Answers: 

A: You should not use these two options because this should be implemented by the MetricUnit 
and EnglishUnit classes. 
D: You should not use these two options because this should be implemented by the MetricUnit 
and EnglishUnit classes. 










QUESTION NO: 12 

You work as an application developer at CertKiller.com. You are developing an application that 
makes use of a Queue class object named MyQueue. This Queue class object will be used to 
store messages sent by the user during application run time. The application that you are 
developing provides an interface for administrators and an interface for users to create message reports. 

You want to ensure that all user messages stored in the MyQueue object are removed when an 
administrator selects the reset option. 

What should you do? 

A. Use the Enqueue method of the MyQueue object. 
B. Use the Clear method of the MyQueue object. 
C. Use the Dequeue method of the MyQueue object. 
D. Use the TrimToSize method of the MyQueue object. 




















Answer: B 

Explanation: 

The clear method sets the Count property of the Queue class object to 0 after removing all the 
elements from the queue. When you call the Clear method for a Queue object, the capacity of the 
Queue object is not changed. 

Incorrect Answers: 

A: You should not use this method because it is used to add a new element at the beginning of a 
Queue object. 
C: You should not use this method because it is used to remove an element at the beginning of a 
Queue object. 
D: You should not use this method because it is used to resize a Queue object. 










QUESTION NO: 13 

You work as an application developer at CertKiller.com. You are developing an application that will 
store user messages collectively and the process the messages in sequence. The order in which 
the messages are processed will depend on the order in which it is received. 

To add messages to the collection, users will specify the message that should be stored in a 
TextBox control named txtMsg and then click a Button control named btnAdd. 

You need to ensure that the appropriate code is used to create the collection. 

What should you use? (Choose two) 

A. Queue msgCollection = new Queue (); 
B. Stack msgCollection = new Stack (); 
C. msgCollection.Enqueue (txtMSG.Text); 
D. msgCollection.Push (txtMSG.Text); 




















Answer: A,C 

Explanation: 

In this scenario, you should use the Queue class to create the collection because you are required 
to process user messages in sequence. The Dim statement creates an object named 
msgCollection of the Queue class. The second line of code then calls the Enqueue method of the 
msgCollection object to add the Text property value of the txtMSG control as an element in the 
collection. To manage elements in the queue, the Queue class provides methods, such as 
Dequeue and Clear . The Dequeue method is used to remove elements that are at the beginning 
of the Queue object. The Clear method is used to remove all elements from a Queue object. The 
Queue class is a data structure for handling elements based on the First In First Out (FIFO) 
concept. 

Incorrect Answers: 

B: Using these lines of code is incorrect because they use the Stack class to create a collection. 
Stack objects are used to store elements on the Last In First Out (LIFO) concept. 
D: Using these lines of code is incorrect because they use the Stack class to create a collection. 
Stack objects are used to store elements on the Last In First Out (LIFO) concept. 










QUESTION NO: 14 

You work as an application developer at CertKiller.com. You are developing an application that 
makes use of a Queue class object named MyQueue. This Queue class object will be used to 
store messages sent by the user during application run time. 

You would like to access the message at the beginning of the queue, prior to processing the user 
messages, without removing it. 

What should you do? 

A. Use the Enqueue method of the MyQueue object. 
B. Use the Contains method of the MyQueue object. 
C. Use the Dequeue method of the MyQueue object. 
D. Use the Peek method of the MyQueue object. 




















Answer: D 

Explanation: 

The Peek method accesses the element at the beginning of the object of the Queue class without 
removing it from the queue. The Queue class is a data structure for handling elements based on 
the First In First Out (FIFO) concept. According to this concept, elements that are stored first are 
processed first. 

Incorrect Answers: A: You should not use this method of the Queue class because it is used to add a new element at 
the end of a Queue object. 
Collection.Generic interfaces 
B: You should not use this method of the Queue class because it is used to verify whether the 
specified element exists for the Queue object instance or not. 
Generic Dictionary 
C: You should not use this method of the Queue class because it is used to remove the next 
element at the beginning of a Queue object. 










QUESTION NO: 15 

You work as an application developer at CertKiller.com. CertKiller.com wants you to develop an 
application that stores and retrieves employee information by means of a unique staff number. 

You create a custom collection class, which implements the type-safe IDictionary interface. This 
collection class is named EmployeeCollection, and is defined using the following code. 

public class EmployeeCollection : IDictionary <int, Employee> 

{ 
// Implementation code 
} 

You need to ensure that an EmployeeCollection object is instantiated and that Employee objects 
are added to it. 

What should you do? 

A. Use the following code: 
Employee e1, e2; 
e1 = new Employee (1001, "Andy Reid", "Manager"); 
e2 = new Employee (1002, "Kara Lang", "Sales Engineer"); 
EmployeeCollection eData = new EmployeeCollection(); 
eData.Add (new KeyValuePair <string, Employee> (e1.ID, e1)); 
eData.Add (new KeyValuePair <string, Employee> (e2.ID, e2)); 
B. Use the following code: 
Employee e1, e2; 
e1 = new Employee (1001, "Andy Reid", "Manager"); 
e2 = new Employee (1002, "Kara Lang", "Sales Engineer"); 
EmployeeCollection eData = new EmployeeCollection(); 
eData.Add ((string) e1.ID, e1); 
eData.Add ((string) e2.ID, e2); 
C. Use the following code: 
Employee e1, e2; 
e1 = new Employee (1001, "Andy Reid", "Manager"); 
e2 = new Employee (1002, "Kara Lang", "Sales Engineer"); 
EmployeeCollection eData = new EmployeeCollection(); 
eData.Add (e1.ID, e1); 
eData.Add (e2.ID, e2); 
D. Use the following code: 
Employee e1, e2; 
e1 = new Employee (1001, "Andy Reid", "Manager"); 
e2 = new Employee (1002, "Kara Lang", "Sales Engineer"); 
EmployeeCollection eData = new EmployeeCollection(); 
eData.Add (new KeyValuePair (e1.ID, e1)); 
eData.Add (new KeyValuePair (e2.ID, e2)); 




















Answer: C 

Explanation: 

This code instantiates two Employee objects and an EmployeeCollection object, and it adds those 
two Employee objects to the EmployeeCollection object. The EmployeeCollection class 
implements the generic IDictionary interface specifying the CKey and TValue placeholders as 
Integer and Employee data types, respectively. Like the non-generic IDictionary interface, the key 
is used to retrieve the value. Unlike the non-generic IDictionary interface, the key does not have 
to be a string and the value does not have to be a generic object. Unlike the non-generic 
IDictionary interface, the Add method of the generic IDictionary interface can accept either a 
KeyValuePair structure with the appropriate data types specified or in this case two arguments, an 
integer and Employee object. 

Incorrect Answers: 

A: If you use this code fragment, the EmployeeCollection class accepts an integer for the CKey 
placeholder and an Employee object for the TValue placeholder. 
B: You should not use the code that casts the ID property from an integer into a string, because 
the key value should match the integer data type defined by CKey placeholder of the generic 
IDictionary interface. 
D: You should not use the code that does not specify the CKey and TValue placeholders when 
using the KeyValuePair structure because the data types must be declared explicitly. 










QUESTION NO: 16 

You work as an application developer at CertKiller.com. CertKiller.com wants you to develop an 
application that stores and retrieves staff information by means of a unique staff number. 

You have already written the following code for the purpose of storing Employee objects.
Employee e1 = new Employee (1001, "Andy Reid", "Manager"); 
Employee e2 = new Employee (1002, "Kara Lang", "Sales Engineer"); 
Dictionary <int, Employee> eData = new Dictionary <int, Employee> (); 
eData.Add (e1.ID, e1); 
eData.Add (e2.ID, e2); 


All other Employee objects have been added in the same way. You are required to display all 
key/value pairs within the Dictionary collection. 


What should you do? 


A. Use the following code: 
foreach (KeyValuePair<int, Employee> keyPair in eData) 
Console.WriteLine ("{0} key : {1} value", keyPair.Key, keyPair.Value); 

B. Use the following code: 
foreach (string key in eData.Keys) 
Console.WriteLine ("{0} key : {1} value", Key, (Employee) eData [key]); 

C. Use the following code: 
foreach (KeyValuePair keyPair in eData) 
Console.WriteLine ("{0} key : {1} value", keyPair.Key, keyPair.Value); 

D. Use the following code: 
foreach (object value in eData.Values) 
Console.WriteLine ("{0} key : {1} value", eData [value], value); 





















Answer: A 

Explanation: 

This code iterates through each KeyValuePair structure in the generic DictionaryData, and it 
displays the Key and Value properties. Like the non-generic IDictionary interface, the key is used 
to retrieve the value. Unlike the non-generic IDictionary interface, the key does not have to be a 
string and the value does not have to be a generic object. You must specify the CKey and TValue 
placeholders when specifying a KeyValuePair structure. Because the eDataDictionary collection 
is instantiated with the integer and Employee data types for the CKey and TValue placeholders, 
respectively, the KeyValuePair structure should also use these data types. During each iteration, 
the KeyValuePair object is assigned to the keyPair variable, and the Console.WriteLine method is 
used to display the Key and Value properties to the console. 

Incorrect Answers: 

B: Like the non-generic IDictionary interface, the key is used to retrieve the value. Unlike the non-
generic IDictionary interface, the key does not have to be a string and the value does not have to 
be a generic object. You must specify the CKey and TValue placeholders when specifying a 
KeyValuePair structure. 
C: You should not use the code that does not specify the CKey and TValue placeholders when 
using the KeyValuePair structure because the data types must be declared explicitly. 
Generic Comparer class and Generic EqualityComparer class 
D: You should not use the code that specifies a value when accessing items in the Dictionary 
collection because you should use a key to access a value and you cannot guarantee that only 
one key exists for a value, as there might be duplicate values in a Dictionary collection 
Generic KeyValuePair structure 










QUESTION NO: 17 

You work as an application developer at CertKiller.com. CertKiller.com wants you to develop an 
application that handles passes for CertKiller.com's parking lot. The application has to store and 
retrieve vehicle information using a vehicle identification number (VIN). 

You need to use the correct code to ensure type-safety. 

What should you do? 

A. Use the following code: 
Vehicle v1, v2; 
v1 = new Vehicle ("1M2567871Y91234574", "Nissan Silvia", 1996); 
v2 = new Vehicle ("1F2569122491234574", "Mitsubishi Lancer", 2005); 
ArrayList vList = new ArrayList (); 
vList.Add (v1); 
vList.Add (v2); 
B. Use the following code: 
Vehicle v1, v2; 
v1 = new Vehicle ("1M2567871Y91234574", "Nissan Silvia", 1996); 
v2 = new Vehicle ("1F2569122491234574", "Mitsubishi Lancer", 2005); 
SortedList <string, Vehicle> vList = new SortedList <string, Vehicle> (); 
vList.Add (v1.VIN, v1); 
vList.Add (v2.VIN, v2); 
C. Use the following code: 
Vehicle v1, v2; 
v1 = new Vehicle ("1M2567871Y91234574", "Nissan Silvia", 1996); 
v2 = new Vehicle ("1F2569122491234574", "Mitsubishi Lancer", 2005); 
List vList = new List (); 
vList.Add (v1); 
vList.Add (v2); 
D. Use the following code: 
Vehicle v1, v2; 
v1 = new Vehicle ("1M2567871Y91234574", "Nissan Silvia", 1996); 
v2 = new Vehicle ("1F2569122491234574", "Mitsubishi Lancer", 2005); 
SortedList vList = new SortedList (); 
vList.Add (v1.VIN, v1); 
vList.Add (v2.VIN, v2); 






















Answer: B 

Explanation: 

This code instantiates two Vehicle objects and a SortedList collection, and it adds those two 
Vehicle objects to the SortedList collection. The SortedList collection class implements the 
generic IDictionary interface specifying the CKey and TValue placeholders. Like the non-generic 
IDictionary interface, the key is used to retrieve the value. Unlike the non-generic IDictionary 
interface, the key does not have to be a string and the value does not have to be a generic object. 
This allows flexibility and type-safety. 

Incorrect Answers: 

A: You should not use the code fragments that specify the ArrayList or generic List collections 
because these collection classes do not implement the IDictionary interface and only allow 
element access by index, not by key. 
C: You should not use the code fragments that specify the List or non-generic SortedList 
collections because you must use generic collection classes to guarantee type-safety. 
D: You should not use the code fragments that specify the List or non-generic SortedList 
collections because you must use generic collection classes to guarantee type-safety. 










QUESTION NO: 18 

You work as an application developer at CertKiller.com. CertKiller.com wants you to develop an 
application that handles passes for CertKiller.com's parking lot. The application has to store and 
retrieve vehicle information in a contiguous list that allows for advanced navigation techniques. 


You have already written and executed the following code: 


Vehicle v1, v2, v3, v4, v5; 
v1 = new Vehicle ("1M2567871Y91234574", "Nissan Silvia", 1996); 
v2 = new Vehicle ("1H2569122493456960", "Honda Civic", 1999); 
v3 = new Vehicle ("1F2569106891234589", "Mitsubishi Lancer", 2001); 
v4 = new Vehicle ("1F7969122491234589", "Mazda MX7", 1998); 
v5 = new Vehicle ("1T2569122493456123", "Toyota Supra", 2000); 


LinkedList <Vehicle> vList = new LinkedList < Vehicle > (); 
LinkedListNode < Vehicle > vNode; 
vNode = vList.AddFirst (v1); 
vNode = vList.AddLast (v2); 
vNode = vList.AddAfter (vNode, v3); 
vNode = vList.AddBefore (vNode, v4); 
vList.AddLast (v5); 

foreach (Vehicle v in vList) 

{ 
Console.WriteLine ("{0} {1} ({2})", v.MakeModel, v.Year, v.Vin); 
} 

What output will be produced in the console? 

A. Nissan Silvia 1996 (1M2567871Y91234574) 
Honda Civic 1999 (1H2569122493456960) 
Mitsubishi Lancer 2001 (1F2569106891234589) 
Mazda MX7 1998 (1F7969122491234589) 
Toyota Supra 2000 (1T2569122493456123) 
B. Nissan Silvia 1996 (1M2567871Y91234574) 
Honda Civic 1999 (1H2569122493456960) 
Mazda MX7 1998 (1F7969122491234589) 
Mitsubishi Lancer 2001 (1F2569106891234589) 
Toyota Supra 2000 (1T2569122493456123) 
C. Nissan Silvia 1996 (1M2567871Y91234574) 
Mazda MX7 1998 (1F7969122491234589) 
Mitsubishi Lancer 2001 (1F2569106891234589) 
Toyota Corolla 2002 (1T2569122493456123) 
Honda Civic 1999 (1H2569122493456960) 
D. Nissan Silvia 1996 (1M2567871Y91234574) 
Mitsubishi Lancer 2001 (1F2569106891234589) 
Mazda MX7 1998 (1F7969122491234589) 
Honda Civic 1999 (1H2569122493456960) 
Toyota Supra 2000 (1T2569122493456123) 




















Answer: B 

Explanation: 

The LinkedList collection class is a doubly-linked list that allows advanced navigation techniques 
when accessing its elements. An element pointer is provided by the LinkedListNode class with the 
Previous and Next properties. The LinkedList collection class has a few methods of insertion, 
including AddFirst , AddLast , AddBefore , and AddAfter methods. The AddFirst and AddLast 
methods accept an element argument and return a LinkedListNode object as a pointer reference. 
The AddBefore and AddAfter methods also return a LinkedListNode object, but they accept 
another LinkedListNode indicating which node before or after to insert the element. In this scenario, there are five Vehicle objects added to the LinkedList collection named vList . 
The v1 object is added to the beginning of vList collection by invoking the AddFirst method. The 
v2 object is added to the end of the vList collection by invoking the AddLast method. The v3 
object is added by invoking the AddAfter method. The v4 object is added before the v3 object by 
invoking the AddBefore method. Finally, the v5 object is added at the end of the vList collection by 
invoking the AddLast method. 

Incorrect Answers: 

A: These options do not represent the output that will be produced by the code you wrote. 
Specialized String classes 
IComparable interface 
C: These options do not represent the output that will be produced by the code you wrote. 
Named collections 
D: These options do not represent the output that will be produced by the code you wrote. 
CollectionsUtil 










QUESTION NO: 19 

You work as an application developer at CertKiller.com. You are developing a collection class 
named ClientCollection, which is to be used for storing the names of CertKiller.com's clients that 
are situated in various geographical areas. 

These client names are represented by the Client class. You are planning to create a method 
named SortClients in the ClientCollection class to arrange Client objects in ascending order. 

You need to ensure that the appropriate interface is implemented by the Client class to allow 
sorting. 

What interface should be used? 

A. IDictionary 
B. IComparable 
C. IComparer 
D. IEqualityComparer 




















Answer: B 

Explanation: 

The IComparable interface provides only one method named CompareTo , which takes on generic 
object, compares it to the current instance, and returns an Integer value representing whether the 
current instance is equal to, greater than, or less than the object. The IComparable interface is 
typically used when you want to create a class whose objects can be sorted in either a list or 
collection. Incorrect Answers: 

A: This interface should not be implemented because it is used to create a collection that is 
managed by key/value pairs. 
Delegate class 
C: This interface should not be implemented because it should be implemented by collection or 
comparer classes, not comparable classes. 
IConvertible interface 
D: This interface should not be implemented because it provides methods to compare two objects 
for equality only. 
ICloneable interface 










QUESTION NO: 20 

You work as an application developer at CertKiller.com. You have been given the responsibility of 
creating a class named CalcSalary that will determine the salaries of CertKiller.com's staff. 

The CalcSalary class includes methods to increment and decrement staff salaries. You would like 
to invoke the IncrementSalary and DecrementSalary methods dynamically at runtime from the 
sales manager application when needed. After viewing the information displayed in the exhibit, 
you decide to use the Salary delegate to invoke these methods. 

using System; 

public delegate bool Salary (Employee Emp, double Amount); 

public class CalcSalary 
{ 
	// for promotions 
	public static bool IncrementSalary (Employee Emp, double Amount) 
	{ 
	// implementation details 
	} 

	// for demotions 
	public static bool DecrementSalary (Employee Emp, double Amount) 
	{ 
	// implementation details 
	} 
}
What code should you use?

A. public void Review (Employee emp, double amount) 
{

 Salary salaryDel;

 if (emp.Status = = QuarterlyReview.OnTarget | | emp.Status = = QuarterlyReview.AboveGoals)

 salaryDel.Invoke (CalcSalary.IncrementSalary (emp, amount));

 else

 salaryDel.Invoke (CalcSalary.DecrementSalary (emp, amount)); 

} 

B. public void Review (Employee emp, double amount) 
{

 Salary salaryDel;

 if (emp.Status == QuarterlyReview.OnTarget | | emp.Status = = QuarterlyReview.AboveGoals)

 salaryDel.Method = CalcSalary.IncrementSalary;

 else

 salaryDel.Method = CalcSalary.DecrementSalary;

 salaryDel.Invoke (emp, amount); 

} 

C. public void Review (Employee emp, double amount) 
{

 Salary salaryDel;

 if (emp.Status == QuarterlyReview.OnTarget | | emp.Status = = QuarterlyReview.AboveGoals)

 salaryDel.IncrementSalary (emp, amount);

 else

 salaryDel.DecrementSalary (emp, amount); 

} 

D. public void Review (Employee emp, double amount) 
{

 Salary salaryDel;

 if (emp.Status = = QuarterlyReview.OnTarget | | emp.Status = = QuarterlyReview.AboveGoals)

 salaryDel = CalcSalary.IncrementSalary;

 else

 salaryDel = CalcSalary.DecrementSalary;

 salaryDel.Invoke (emp, amount); 

} 





















Answer: D 

Explanation: 

This code declares a delegate variable and, based upon the value of the Status property, assigns 
the delegate variable to the correct method. If the Status property is QuarterlyReview.OnTarget or 
QuarterlyReview.AboveGoals , then the Salary delegate variable is assigned to the 
IncrementSalary method of the CalcSalary class. If not, then the Salary delegate variable is 
assigned to the DecrementSalary method of the CalcSalary class. Delegates are method pointers and must be assigned to a method so that a delegate variable can invoke it. The Invoke method 
takes those arguments specified by the delegate declaration. 

Incorrect Answers: 

A: You should not use these code fragments because they are syntactically incorrect and will 
result in a compilation error if used. 
B: You should not use these code fragments because they are syntactically incorrect and will 
result in a compilation error if used. 
C: You should not use these code fragments because they are syntactically incorrect and will 
result in a compilation error if used. 










QUESTION NO: 21 

You work as an application developer at CertKiller.com. You have been given the responsibility of 
creating a class named CalcSalary that will determine the salaries of CertKiller.com's staff. 


The CalcSalary class includes methods to increment and decrement staff salaries. The following 
code is included in the CalcSalary class: 


public class CalcSalary 
{ 
	// for promotions 
	public static bool IncrementSalary (Employee Emp, double Amount) 
	{ 
		if (Emp.Status == QuarterlyReview.AboveGoals) 
		{
			Emp.Salary += Amount; 
			return true; 
		} 
		else 
			return false; 
	} 

	//for demotions 
	public static bool DecrementSalary (Employee Emp, double Amount) 
	{ 
		if (Emp.Status != QuarterlyReview.AboveGoals)
		{
			Emp.Salary -= Amount; 
			return true; 
		} 
		else 
			return false; 
	} 
} 

You would like to invoke the IncrementSalary and DecrementSalary methods dynamically at 
runtime from the sales manager application, and decide to create a delegate named 
SalaryDelegate to invoke them. 

You need to ensure that you use the appropriate code to declare the SalaryDelegate delegate. 

What is the correct line of code? 

A. public delegate bool Salary (Employee Emp, double Amount); 
B. public bool Salary (Employee Emp, double Amount); 
C. public event bool Salary (Employee Emp, double Amount); 
D. public delegate void Salary (Employee Emp, double Amount); 




















Answer: A 

Explanation: 

The signatures of the delegate and the attached method(s) should be identical. When you declare 
a delegate, you use the delegate keyword followed by the return type. If you bind the delegate to 
a method with a return type, you should specify that. If you bind the delegate to a method that 
does not return a data type, you should use the void keyword. After that, you should specify the 
name of the delegate and declare the arguments expected. In this scenario, the IncrementSalary 
and DecrementSalary methods accept an Employee object and a double value, and return a 
Boolean value. You should, therefore, accept an Employee object and a double value, and return 
a Boolean value when you declare the SalaryDelegate delegate. 

Incorrect Answers: 

B: You should not use the code that does not use the delegate keyword. 
EventArgs class 
C: You should not use the code that declares an event named SalaryDelegate. 
EventHandler delegates 
D: You should not use the code that uses the void keyword because both the IncrementSalary and 
DecrementSalary methods return a Boolean value. 










QUESTION NO: 22 You work as an application developer at CertKiller.com. You have recently created a Windows 
service application and need to define a Windows service class. 

What should you do? 

A. Use the following code: 
public class TestService : System.ServiceProcess.WindowsService 
{ 
//Implementation details 
} 

B. Use the following code: 
public class TestService : System.ServiceProcess.IWindowsService 
{ 
//Implementation details 
} 

C. Use the following code: 
public class TestService : System.ServiceProcess.ServiceBase 
{ 
//Implementation details 
} 

D. Use the following code: 
public class TestService : System.ServiceProcess.IService 
{ 
//Implementation details 
} 





















Answer: C 

Explanation: 

The ServiceBase class contains event methods, such as OnStart , OnStop , and Run , for 
controlling Windows service classes. 

The OnStart method code is executed when a Windows service is either manually started or when 
the system is booted if the Startup type is set to Automatic . The OnStop method code is 
executed when a Windows service is either manually stopped or when the system is shut down. 
The Main method is the first point of execution when running any windows application ( .exe ). For 
a Windows service to run in an application process, you must invoke the Run method on the 
ServiceBase class. The Run method is overloaded to accept either a single ServiceBase object or 
an array of ServiceBase objects. 

Incorrect Answers: 

A: You should not use either of the code fragments from the WindowsService class or implement 
the IService and IWindowsService interfaces because no such class or interfaces exist in the 
System.ServiceProcess namespace. 
B: You should not use either of the code fragments from the WindowsService class or implement 
the IService and IWindowsService interfaces because no such class or interfaces exist in the 
System.ServiceProcess namespace. 
D: You should not use either of the code fragments from the WindowsService class or implement 
the IService and IWindowsService interfaces because no such class or interfaces exist in the 
System.ServiceProcess namespace. 










QUESTION NO: 23 

You work as an application developer at CertKiller.com. You have been given the task of 
developing a Windows service application that regularly monitors other Windows services on the 
same computer. 


This Windows service application must also log any abnormal file system activity. You have added 
the following class to the Windows service application: 


public class EnumerateService : ServiceBase 
{ 
	public static EnumerateService () 
	{ 
		this.ServiceName = "Enumerate Service"; 
		this.CanStop = true; 
	} 
	
	protected override void OnStart (string[] args) 
	{ 
		// Enumerate all services and initialize the FileSystemWatcher 
	} 
	
	protected override void OnStop () 
	{ 
		// Stop the FileSystemWatcher and perform cleanup 
	} 
	
	public static void Main () 
	{
		EnumerateService service = new EnumerateService(); 
	} 
} 

You then create the installer for the Windows service application, and install the Windows service 
application. You have configured the Windows service Startup type to Automatic, and rebooted the 
system. You then test the new Windows service application, and find that it is not working. 

You need to ensure that the service is working properly. 

What should you do? 

A. Override the OnBoot method instead of the OnStart method. 
B. Replace the Main method code with the following code: 
EnumerateService service = new EnumerateService (); 
Service.Run (); 
C. Override the OnLoad method instead of the OnStart method. 
D. Replace the Main method code with the following code: 
EnumerateService service = new EnumerateService (); 
Run (service); 




















Answer: D 

Explanation: 

For a Windows service to run in an application process, you have to invoke the Run method on the 
ServiceBase class. The Run method is overloaded to accept either a single ServiceBase object or 
an array of ServiceBase objects. The OnStart method code is executed when a Windows service 
is either manually started or when the system is booted if the Startup type is set to Automatic . 
The OnStop method code is executed when a Windows service is either manually stopped or 
when the system is shut down. The Main method is the first point of execution when running any 
windows application ( .exe ). 

Incorrect Answers: 

A: You should not override the OnBoot or OnLoad method because there are no such methods in 
the ServiceBase class. 
B: For a Windows service to run in an application process, you have to invoke the Run method on 
the ServiceBase class. The Run method is overloaded to accept either a single ServiceBase 
object or an array of ServiceBase objects. This code will not compile because the Run method is a 
class member and does not take zero arguments. 
ServiceController class and ServiceControllerPermission class 
C: You should not override the OnBoot or OnLoad method because there are no such methods in 
the ServiceBase class. 










QUESTION NO: 24 

You work as an application developer at CertKiller.com. CertKiller.com has asked you to develop 
an application allows administrators to control Windows services dynamically without using the 
Services MMC. 

You start by creating a class named LocalServiceController. You need to add the correct code to 
the LocalServiceController class to ensure that administrators are able to start local Windows 
services. 

What code should you use? 

A.
public static bool StartService (string serviceName) 
{
	try
	{
		ServiceBase.Run (serviceName);
		return true;
	}
	catch
	{
		return false;
	} 
} 

B.
public static bool StartService (string serviceName) 
{
	ServiceController controller = new ServiceController (serviceName);

	if (controller.Status != ServiceControllerStatus.Running)
	{
		controller.Start ();
		return true;
	}
	else
		return false; 
}

C.
public static bool StartService (string serviceName) 
{ 
	ServiceManager manager = new ServiceManager (serviceName); 
	if (manager.Status != ServiceManagerStatus.Running) 
	{ 
		manager.Start (); 
		return true;
	}
	else
		return false; 
} 

D.
public static bool StartService (string serviceName) 
{
	ServiceBase service = new ServiceBase ();

	service.ServiceName = serviceName;

	if (service.CanStart)
	{
		ServiceBase.Run (service);
		return true;
	}
	else
		return false; 
} 





















Answer: B 

Explanation: 

This code first instantiates a ServiceController object using the ServiceName variable. Then, the 
Status property is compared to the enumeration value ServiceControllerStatus.Running . If the 
Windows service is not currently running, then the Start method is invoked on the 
ServiceController object, and the method returns true . If the Windows service is running, the 
method returns false . 

Incorrect Answers: 

A: You should not add the code that uses the ServiceManager class because there is no such 
class in the ServiceControllerStatus.Running namespace. 
C: You should not add either of the code fragments that use the ServiceBase class because this is 
the base class for Windows service classes. 
D: You should not add the code that uses the ServiceManager class because there is no such 
class in the ServiceControllerStatus.Running namespace. 










QUESTION NO: 25 

You work as an application developer at CertKiller.com. CertKiller.com has asked you to develop 
an application that monitors and controls the activities of a Windows service. 

You need to use the appropriate class to meet CertKiller.com's requirements. 

What should you do?
A. Use the ServiceBase class. 
B. Use the ServiceInstaller class. 
C. Use the ServiceManager class. 
D. Use the ServiceController class. 




















Answer: D 

Explanation: 

To monitor and control the behavior of a Windows service, you should use the ServiceController 
class. 

Incorrect Answers: 

A: The ServiceBase class is the base class for Windows service classes. 
Thread class 
B: The ServiceInstaller class is used to install a Web service application. 
C: There is no such class in the ServiceControllerStatus.Running namespace. 
ServiceInstaller and ServiceProcessInstaller class 










QUESTION NO: 26 

You work as an application developer at CertKiller.com. CertKiller.com has asked you to create a 
multi-threaded application, which executes a critical database backup operation on an hourly 
basis. You define this operation with the following code: 

public void BackupDB () 
{ 
//Implementation code 
} 

You then create a Thread object for the purpose of invoking this method. 

You need to ensure that the thread is scheduled for execution before any other thread at runtime. 

What should you do? 

A. Use the following code: 
Thread th = new Thread (BackupDB); 
th.Scheduled = ThreadScheduled.Before; 
th.Start (); 
B. Use the following code: 
Thread th = new Thread (BackupDB); 
th.Priority = ThreadPriority.AboveNormal; 
th.Start (); 
C. Use the following code: 
Thread th = new Thread (BackupDB); 
th.Priority = ThreadPriority.Highest; 
th.Start (); 
D. Use the following code: 
Thread th = new Thread (BackupDB); 
th.Scheduled = ThreadScheduled.First; 
th.Start (); 




















Answer: C 

Explanation: 

This code instantiates a Thread object that will execute the BackupDB method, specifies the 
highest priority level for scheduling threads for execution, and starts the thread running. When 
instantiating a Thread object, you must specify the name of the method it will invoke. The Priority 
property indicates the relative position of a thread in the wait queue when being scheduled for 
execution. If two threads arrive in the wait queue at relatively the same time, the higher priority 
thread will receive the time slice before the other. The Priority property is a ThreadPriority 
enumeration value, which can be Lowest , BelowNormal , Normal , AboveNormal , and Highest .by 
default, the Priority property is set to ThreadPriority.Normal . 

Incorrect Answers: 

A: You should not use the code fragments that set the Scheduled property with the 
ThreadSchedule enumeration because no such property or enumeration exists in the 
System.Threading namespace. 
B: You should not use the code that specifies the value ThreadPriority.AboveNormal for the 
Priority property because this will not schedule the thread for execution before any other thread. 
D: You should not use the code fragments that set the Scheduled property with the 
ThreadSchedule enumeration because no such property or enumeration exists in the 
System.Threading namespace. 










QUESTION NO: 27 

You work as an application developer at CertKiller.com. You have recently created a 
multithreaded application to manage CertKiller.com's inventory system. 

The fulfillment task has to be executed on a regular basis, while other tasks are performed in the 
application. The task does not need any input to start. 

You are required to create and start the fulfillment thread using the appropriate code. 

What code should you use? 
A. ThreadStart work = new 
ThreadStart (Fulfill); 
Thread thFulfill = new Thread (work); 

B. ParameterizedThreadStart work = new 
ParameterizedThreadStart (Fulfill); 
Thread thFulfill = new Thread (work); 

C. ThreadStart work = new 
ThreadStart (Fulfill); 
Thread thFulfill = new Thread (work); 
thFulfill.Start (); 

D. ParameterizedThreadStart work = new 
ParameterizedThreadStart (Fulfill); 
Thread thFulfill = new Thread (work); 
thFulfill.Start (); 





















Answer: C 

Explanation: 

This code creates a ThreadStart delegate that references the Fulfill method, creates a Thread 
object named thFulfill , and invokes the Start method to begin the thread execution. 

Incorrect Answers: 

A: You should not use the code that uses the ThreadStart delegate but does not call the Start 
method because you are required to create and start the fulfillment thread. 
B: You should not use the code that uses the ParameterizedThreadStart delegate and does not 
call the Start method. You have to invoke the Start method to begin thread execution. 
ThreadPool class 
D: You should not use the code that uses the ParameterizedThreadStart delegate and calls the 
Start method. The ParameterizedThreadStart delegate is used to reference a method that takes a 
generic object as an argument and, in this scenario, the fulfill method takes no arguments 










QUESTION NO: 28 

You work as an application developer at CertKiller.com. You are currently in the process of 
developing a business logic component that requires long calculations. 

You have identified numerous tasks within this application that can be done asynchronously. You 
notice that these tasks are mutually dependent and require complex synchronization techniques 
so that it can manage efficiently. 

You decide to use Microsoft .NET 2.0 to take advantage of its new thread management features. 
You need to create and start the application threads. What should you do? 

A. Use the following code: 
ThreadPool thPool = new ThreadPool ("Current Application"); 
Thread th1 = new Thread (Task1); 
Thread th1 = new Thread (Task2); 
Thread th1 = new Thread (Task3); 
th1.StartInPool (thPool); 
th2.StartInPool (thPool); 
th3.StartInPool (thPool); 
B. Use the following code: 
ThreadPool thPool = new ThreadPool ("Current Application"); 
thPool.QueueUserWorkItem (Task1); 
thPool.QueueUserWorkItem (Task2); 
thPool.QueueUserWorkItem (Task3); 
C. Use the following code: 
ThreadPool.QueueUserWorkItem (Task1); 
ThreadPool.QueueUserWorkItem (Task2); 
ThreadPool.QueueUserWorkItem (Task3); 
D. Use the following code: 
Thread th1 = new Thread (Task1); 
Thread th1 = new Thread (Task2); 
Thread th1 = new Thread (Task3); 
th1.Start (); 
th2.Start (); 
th3.Start (); 




















Answer: C 

Explanation: 

This code uses the QueueUserWorkItem method of the ThreadPool class to add tasks to the 
current application domain's thread pool. The QueueUserWorkItem method takes a WaitCallback 
delegate as an argument and manages the tasks using background threads. This allows the 
developer to concentrate on business logic and requires minimal synchronization code. 

Incorrect Answers: 

A: You should not use either of the code fragments that instantiate the Thread objects explicitly 
because it will require excessive synchronization code to manage effectively. 
B: You should not use the code that instantiates a ThreadPool object because the ThreadPool 
class is a static class and cannot be instantiated. 
D: You should not use either of the code fragments that instantiate the Thread objects explicitly 
because it will require excessive synchronization code to manage effectively. 

Timeout class, Timer class, TimerCallback delegate, WaitCallback delegate, WaitHandle class, 
and WaitOrTimerCallback delegate 










QUESTION NO: 29 

You work as an application developer at CertKiller.com. You have created a Windows service 
application for the purpose of monitoring the number of active service requests running on 
CertKiller.com's server. 

You want to configure this Windows service application to produce a report every ten minutes. You 
start by placing the reporting logic in the GenerateReport method of this Windows service. 

You want to create a Timer object that invokes this method every ten minutes. 

What should you do? 

A. Use the following code: 
Timer tmrReport = new Timer 
(new TimerCallback (GenerateReport), null, 600000, 0); 

B. Use the following code: 
Timer tmrReport = new Timer 
(new TimerCallback (GenerateReport), null, 10, 0); 

C. Use the following code: 
Timer tmrReport = new Timer 
(new TimerCallback (GenerateReport), null, 0, 600000); 

D. Use the following code: 
Timer tmrReport = new Timer 
(new TimerCallback (GenerateReport), null, 0, 10); 





















Answer: C 

Explanation: 

This code creates a Timer object named tmrReport that will invoke the GnerateReport every ten 
minutes. The first argument of the Timer constructor is a TimerCallback delegate that points to the 
method to be invoked. The second argument is the object that will be sent to the callback method. 
The third and fourth arguments are integers that specify delay and interval in milliseconds, 
respectively. Because the interval is in milliseconds, the following conversion must be made: 

10 minutes = 10 * 60 seconds = 600 * 1000 milliseconds = 600,000 milliseconds 

Therefore, the delay is set to 0, and the interval is set to 600,000 milliseconds. 

Incorrect Answers: 

A: This option is incorrect because the delay and the interval arguments are reversed. If you use 
this option, then the tmrReport will invoke the GnerateReport method only once in ten minutes. 
B: This option is incorrect because the delay and the interval arguments are reversed. Also, the 
interval argument is incorrectly specified. It should be specified in milliseconds. 
D: The interval argument is incorrectly specified. It should be specified in milliseconds, not 
minutes. This code would set the interval to ten milliseconds instead of ten minutes. 










QUESTION NO: 30 

You work as an application developer at CertKiller.com. You have recently created an application 
that includes the code shown below. 

public delegate string GetFileContentsDel (); 

public string GetFileContents () 
{ 
	//Process file and return results 
} 

You now need to invoke the GetFileContents method asynchronously. 

You have to ensure that the code you use to invoke the GetFileContents method will continue to 
process other user instructions, and displays the results as soon as the GetFileContents method 
finishes processing. 

What should you do? 

A. Use the following code: 
GetFileContentsDel delAsync = new GetFileContentsDel (GetFileContents); 
IAsyncResult result = delAsync.BeginInvoke (null, null); 
while (!result.IsCompleted) 
{ 
	//Process other user instructions 
} 
string strFile = delAsync.EndInvoke (result); 


B. Use the following code: 
GetFileContentsDel delAsync = new GetFileContentsDel (GetFileContents); 
string strFile = delAsync.Invoke (); 

C. Use the following code: 
string strFile = GetFileContents.Invoke (); 

D. Use the following code: 
GetFileContentsDel delAsync = new 
GetFileContentsDel (GetFileContents); 
IAsyncResult result = delAsync.BeginInvoke (null, null); 
//Process other user instructions 
string strFile = delAsync.EndInvoke (result); 





















Answer: A 

Explanation: 

This code instantiates a GetFileContentsDel delegate that references the GetFileContents 
method. Then, the BeginInvoke method is invoked to implicitly create and start the worker thread. 
The BeginInvoke method takes the same arguments as the method it references but also includes 
an AsyncCallack delegate and a generic object. The AsyncCallack delegate references the 
method that the worker thread will invoke when its processing is complete. 

In this scenario, there is no AsyncCallack delegate specified. Then, the code polls the 
IAsyncResult object to determine if it's processing is complete using the IsCompleted property. 
Once the processing is complete, the loop is exited and the EndInvoke method returns the result 
from the GetFileContents method. 

Incorrect Answers: 

B: You should not use either of the code fragments that use the Invoke method because this is not 
a technique in asynchronous processing. 
C: You should not use either of the code fragments that use the Invoke method because this is not 
a technique in asynchronous processing. 
D: you should not use the code that does not poll the IAsyncResult object by retrieving the 
IsCompleted property. 










QUESTION NO: 31 

You work as an application developer at CertKiller.com. You have been asked by you superiors at 
CertKiller.com to create a child application domain. 

The new child application domain has to specify a different assembly path than that of the parent 
application domain. 

You need to ensure that your solution meets CertKiller.com's requirements. 

What should you do? 

A. Use the following code: 
AppDomainSetup domainSetup = new AppDomainSetup (); 
domainSetup.ApplicationName = @"C:\Program Files\ChildApp"; 
AppDomain.CreateDomain ("ChildDomain", AppDomain.CurrentDomain.Evidence, domainSetup); 
B. Use the following code: 
AppDomainSetup domainSetup = new AppDomainSetup (); 
domainSetup.ApplicationBase = @"C:\Program Files\ChildApp"; 
AppDomain.CreateDomain ("ChildDomain", AppDomain.CurrentDomain.Evidence, domainSetup); 
C. Use the following code: 
AppDomainSetup domainSetup = new AppDomainSetup (); 
domainSetup.ConfigurationFile = @"C:\Program Files\ChildApp"; 
AppDomain.CreateDomain ("ChildDomain", AppDomain.CurrentDomain.Evidence, domainSetup); 
D. Use the following code: 
AppDomainSetup domainSetup = new AppDomainSetup (); 
domainSetup.CachePath = @"C:\Program Files\ChildApp"; 
AppDomain.CreateDomain ("ChildDomain", AppDomain.CurrentDomain.Evidence, domainSetup); 




















Answer: B 

Explanation: 

The CreateDomain method of the AppDomain class is an overloaded method that you can use to 
create an application domain. This code creates a child application domain named ChildDomain , 
which uses the same evidence as its parent domain and specifies an AppDomainSetup object. In 
this version of CreateDomain , the first argument passed to the CreateDomain method is a String 
that represents the name of the application domain to be created. The second argument of the 
CreateDomain method specifies an Evidence object. The Evidence object represents the identity 
information used for Code Access Security (CAS) in the Microsoft .NET Framework to determine 
the permissions granted to an assembly. The third argument of the CreateDomain method 
specifies an AppDomainSetup object. The AppDomainSetup object represents application domain 
settings such as the application name, base directory, and configuration file path. You have to 
specify a different assembly path than that of the parent application domain, so the 
ApplicationBase property of the AppDomain object has to be set. The ApplicationBase property 
defines the base directory of an application. Any runtime references will be resolved using this 
directory for assembly probing. 

Incorrect Answers: 

A: You should not use the code that sets the ApplicationName property of the AppDomainSetup 
object because this should be the friendly name of the application domain. 
C: You should not use the code that sets the ConfigurationFile property of the AppDomainSetup 
object because this should be the directory where the configuration file is located. 
Configure an application domain. 
D: You should not use the code that sets the CachePath property of the AppDomainSetup object 
because this should be the location where shadow copies of assemblies and other resources are 
stored. 
Retrieve setup information from an application domain. 










QUESTION NO: 32 

You work as an application developer at CertKiller.com. You have recently created an application 
domain for CertKiller.com. 

A few weeks later you are asked to retrieve information from this application domain, which is the 
current application domain. 

What can you do to achieve this objective? (Choose two) 

A. Use the following code: 
AppDomain appInfo = ApplicationDomain.Current; 
B. Use the following code: 
AppDomain appInfo = AppDomain.CurrentDomain (); 
C. Use the following code: 
AppDomain appInfo = Thread.GetDomain (); 
D. Use the following code: 
AppDomain appInfo = MainThread.GetDomain (); 




















Answer: B,C 

Explanation: 

The CurrentDomain property of the AppDomain class is a read-only property that contains the 
application domain for the current thread. You can also use the GetDomain method of the Thread 
class to return the application domain for the thread that is currently running. Using either of these 
lines of code will return an AppDomain object for the currently running application from which you 
can retrieve information. 

Incorrect Answers: 

A: If you use any of these codes it will result in a syntax error because the .NET class libraries do 
not provide an ApplicationDomain or MainThread class. 
D: If you use any of these codes it will result in a syntax error because the .NET class libraries do 
not provide an ApplicationDomain or MainThread class. 










QUESTION NO: 33 

You work as an application developer at CertKiller.com. You have recently created an application 
domain for CertKiller.com. 

A few weeks later, you are required to determine if assembly references in this application domain, 
which is the current application domain, are being cached. 

What property should you use to achieve this objective?

A. AppDomain.CurrentDomain.ShadowCopyFiles 
B. AppDomain.CurrentDomain.CachePath 
C. AppDomain.CurrentDomain.ConfigurationFile 
D. AppDomain.CurrentDomain.Evidence 




















Answer: A 

Explanation: 

The ShadowCopyFiles property of the AppDomain class contains a Boolean value that indicates 
whether assembly references are being cached or not. 

Incorrect Answers: 

B: These options are properties of the AppDomainSetup class. 
C: These options are properties of the AppDomainSetup class. 
D: This property is not used in caching. 










QUESTION NO: 34 

You work as an application developer at CertKiller.com. You are required to dynamically load 
assemblies into a custom child application domain. 

You need to ensure that the assemblies loaded into the child application domain have the same 
permissions as the applications that are accessed across the local intranet. 

What should you do? 

A. Use the following code to create the child application domain: 
Evidence childEvidence = new Evidence (new object [ ] { SecurityZone.Intranet }, null); 
AppDomain.CreateDomain ("ChildDomain", childEvidence); 
B. Use the following code to create the child application domain: 
AppDomain.CreateDomain ("ChildDomain", SecurityZone.Intranet); 
C. Use the following code to create the child application domain: 
AppDomain domain = new AppDomain ("ChildDomain", SecurityZone.Intranet); 
D. Use the following code to create the child application domain: 
Evidence childEvidence = new Evidence (new object [ ] { SecurityZone.Intranet }, null); 
AppDomain domain = new AppDomain ("ChildDomain", childEvidence); 




















Answer: A 

Explanation: 

The CreateDomain method of the AppDomain class is an overload method that can be used to 
create an application domain. This code creates a child application domain named ChildDomain 
with the default permissions of applications that are accessed across the local intranet. Incorrect Answers: 

B: You should not use the code that specifies SecurityZone.Intranet as an argument to the 
CreateDomain method because no such method signature exists. 
C: You should not use the code fragments that instantiate an AppDomain object because the 
AppDomain class does not have any constructors. 
D: You should not use the code fragments that instantiate an AppDomain object because the 
AppDomain class does not have any constructors. 










QUESTION NO: 35 

You work as an application developer at CertKiller.com. You are required to dynamically load 
assemblies into an application domain. 

You are using the Load method of the AppDomain class. 

What types of files can you this use method for? 

A. Library application files (.dll). 
B. All assembly files, no matter what there file extensions are. 
C. Application configuration files (.config). 
D. Standalone application files (.exe). 




















Answer: B 

Explanation: 

An assembly specified in the Load method can use a valid extension, an invalid extension, or no 
extension at all. As long as the Microsoft Intermediate Language (MSIL) code is valid, the 
extension is immaterial. 

Incorrect Answers: 

A: Although .dll and .exe are common extensions for .NET assemblies, they are not required when 
you use the Load method of the AppDomain class. 
C: You cannot use the Load method to load application configuration files (.config) because these 
have no MSIL code to execute and cannot be loaded into an application domain. 
D: Although .dll and .exe are common extensions for .NET assemblies, they are not required when 
you use the Load method of the AppDomain class. 










QUESTION NO: 36 

You work as an application developer at CertKiller.com. CertKiller.com has given you the task of 
creating medical billing application that will deal with various insurance vendors. 

The appropriate assemblies have to be loaded and unloaded dynamically based on the patient's 
insurance provider. All of these insurance assemblies are located in C:\Insurance Assemblies. 

You have to ensure that when the new application first loads, it has to load all assemblies into a 
separate application domain. You need to create the child application domain and load all 
assemblies it using the correct code. 

What should you do? 

A. Use the following code: 
AppDomain domain = AppDomain.CreateDomain ("InsuranceDomain"); 
foreach (string assembly in Directory.GetFiles (@"C:\Insurance Assemblies", "*.dll")) 
domain.LoadAssembly (assembly); 


B. Use the following code: 
AppDomain domain = AppDomain.CreateDomain ("InsuranceDomain"); 
foreach (string assembly in Directory.GetFiles (@"C:\Insurance Assemblies", "*.dll")) 
domain.Load (assembly); 


C. Use the following code: 
AppDomain domain = AppDomain.CreateDomain ("InsuranceDomain"); 
foreach (string assembly in Directory.GetFiles (@"C:\Insurance Assemblies", "*.dll")) 
domain.LoadFrom (assembly); 


D. Use the following code: 
AppDomain.CreateDomain ("InsuranceDomain", 
Directory.GetFiles (@"C:\Insurance Assemblies", "*.dll")) 






















Answer: B 

Explanation: 

First, the CreateDomain method of the AppDomain class is used to create an application named 
InsuranceDomain . Then, the foreach construct is used to iterate through the C:\Insurance 
Assemblies directory to retrieve the insurance assemblies in that location. The GetFiles method 
takes two String arguments, a directory path and a search string. In this code, the GetFiles 
method will retrieve the names of all files in C:\Insurance Assemblies that end in .dll . the Load 
method of the AppDomain class is used to load each assembly into the current application 
domain. 

Incorrect Answers: 

A: The LoadAssembly and LoadFrom methods do not exist in the AppDomain class. 
C: The LoadAssembly and LoadFrom methods do not exist in the AppDomain class. 
D: The CreateDomain method does not allow the loading of assemblies into the new domain. 










QUESTION NO: 37 You work as an application developer at CertKiller.com. You have recently completed 
creating an application that uses an application configuration file. 

This configuration file contains a section named EmployeeSection, which contains Employee 
elements. 

You are required to view the contents of the EmployeeSection element. 

You need to ensure that the EmployeeSection element outputs its contents to the console. 

What should you do? 

A. Use the following code: 
Configuration config = ConfigurationManager.OpenExeConfiguration 
(ConfigurationUserLevel.None); 
ConfigurationSection section = Config.GetSection ("EmployeeSection"); 
Console.WriteLine (section.Contents); 
B. Use the following code: 
ConfigurationSection section = Config.GetSection ("EmployeeSection"); 
Console.WriteLine (section.SectionInformation.GetRawXml ()); 
C. Use the following code: 
string section = ConfigurationSettings.AppSettings ["EmployeeSection"]; 
Console.WriteLine (section); 
D. Use the following code: 
Configuration config = ConfigurationManager.OpenExeConfiguration 
(ConfigurationUserLevel.None); 
ConfigurationSection section = Config.GetSection ("EmployeeSection"); 
Console.WriteLine (section.SectionInformation.GetRawXml ()); 




















Answer: D 

Explanation: 

This code opens the application configuration file, retrieves the EmployeeSection element and 
outputs the contents as raw XML. The OpenExeConfiguration method takes a 
ConfigurationUserLevel enumeration value to indicate the visibility of the configuration settings. 
The value None means that the settings apply to all users. The OpenExeConfiguration method 
returns a Configuration object representing the current configuration settings. The GetSection 
method of the Configuration object can then be used to retrieve a specified section of the 
configuration file. The GetSection method accepts a section name and returns a 
ConfigurationSection object representing the specified section, if it is found. In this scenario, you 
pass the GetSection method the name of the EmployeeSection , and it returns a 
ConfigurationSection representing the EmployeeSection . You can then use this 
ConfigurationSection object to access information about the section of the configuration file. The SectionInformation property of the ConfigurationSection object retrieves section-specific settings, 
including contents. The GetRawWml method returns the XML content of the EmployeeSection . 
The WriteLine method then outputs the contents of the console. 

Incorrect Answers: 

A: You should not use the code that accesses the Contents property of the ConfigurationSection 
class because the ConfigurationSection class contains no such property. 
B: You should not use the code that does not specify the ConfigurationManager because the 
GetSection method is an instance member. 
C: You should not use the code that specifies the ConfigurationSettings class because this class is 
provide only for backwards compatibility. 










QUESTION NO: 38 

You work as an application developer at CertKiller.com. You are in the process of creating an 
application for CertKiller.com's Human Resources department that tracks employee benefits. 


You have to store current employee data without recompiling the application. You elect to store 
this employee data as a custom section in the application configuration file. The relevant portion of 
the application configuration file is shown in the following exhibit: 


<?xml version="1.0" encoding="utf-8" ?> 
<configuration> 


<configSections> 


</configSections> 


<!-- Begin Custom Section --> 
<EmployeeSection type="fulltime"> 
   <Employee name="Rory Allen" /> 
</EmployeeSection> 
<!-- End Custom Section --> 


</configuration> 


You want to use the .NET 2.0 Configuration API to access the custom section. 


You need to ensure that programmatic access of the EmployeeSection element is enabled. 


What should you do? (Choose two) 
A. Create a custom section handler class that inherits the ConfigurationSection class. 
B. Add a section element to the EmployeeSection element of the application configuration file. 
C. Create a custom section handler class that implements the IConfigurationSectionHandler 
interface. 
D. Add an EmployeeSection element to the configSections element of the application configuration 
file. 
E. Create a custom section handler class that implements the IApplicationSettingsProvider 
interface. 
F. Add a section element to the configSections element of the application configuration file. 




















Answer: A,F 

Explanation: 

To enable programmatic access of the EmployeeSection element, you should create a custom 
section handler class that inherits the ConfigurationSection class and add a section element to the 
configSections element of the application configuration file. 

Incorrect Answers: 

B: These options violate the application configuration schema and will cause a run-time error when 
attempted. 
C: This interface is deprecated in .NET 2.0 and requires more development effort. 
D: These options violate the application configuration schema and will cause a run-time error 
when attempted. 
Implement ISettingsProviderService interface 
E: This interface should be implemented if a custom storage solution other than application 
configuration files is required. 
Implement IApplicationSettingsProvider interface 










QUESTION NO: 39 

You work as an application developer at CertKiller.com. You have recently created a business 
application, which requires complex installation logic. 

You add the following code to your project after electing to create a custom installer for the 
business application. 

public class ApplicationInstaller : Installer 
{ 
	public override void Install (IDictionary stateSaver) 
	{ 
		//Install the application 
		Base.Install (stateSaver); 
	}
	public override void Commit (IDictionary savedState) 
	{ 
		//Commit the application 
		Base.Commit (savedState); 
	} 
	public override void Rollback (IDictionary savedState) 
	{ 
		//Rollback the application 
		Base.Rollback (savedState); 
	} 
	public override void Uninstall (IDictionary savedState) 
	{ 
		//UnInstall the application 
		Base.Uninstall (savedState); 
	} 
} 

What should be done NEXT? 

A. The assembly should be compiled and the Install.exe tool should be run. 
B. The RunInstaller attribute should be added to the business application assembly and it should 
be set to true. 
C. The assembly should be compiled and should be run as normal. 
D. The RunInstaller attribute should be added to the ApplicationInstaller class and it should be set 
to true. 




















Answer: D 
Incorrect Answers: 

A: This option should be executed after applying the RunInstaller attribute and setting it to true. 
B: You should not add the RunInstaller attribute to the assembly because the RunInstaller attribute 
is applied to a class, not the entire assembly. 
Configure which runtime version a .NET Framework application should use. 
C: You should not use this option because the installer class will be invoked without applying the 
RunInstaller attribute with a value of true. 










QUESTION NO: 40 

You work as an application developer at CertKiller.com. You have recently created and deployed 
an application using the .NET 1.1 CLR to all CertKiller.com users. 

After a CertKiller.com administrator updates all user computers with the .NET 2.0 CLR, you run 
preliminary tests and find that the application you created using the .NET 1.1 CLR is not compatible 
with the .NET 2.0 CLR. 

You need to ensure that the application can be run with the .NET 1.1 CLR. 

What should you do? 

A. Use the following element in the application configuration file: 
<configuration> 
	<startup> 
		<bindingRedirect oldVersion="1.0.0.0" newVersion="1.1.0.0" /> 
	</startup> 
</configuration> 

B. Use the following element in the application configuration file: 
<configuration> 
	<startup> 
		<requiredRuntime version="v1.1.4322" safemode="true" /> 
	</startup>
</configuration> 

C. Use the following element in the application configuration file: 
<configuration> 
	<startup> 
		<supportedRuntime version="v1.1.4322" /> 
		<supportedRuntime version="v1.0.3705" /> 
	</startup> 
</configuration> 

D. Use the following element in the application configuration file: 
<configuration> 
	<startup> 
		<unsupportedRuntime version="v2.0.50727" /> 
	</startup> 
</configuration> 





















Answer: C 

Explanation: 

This configuration element instructs the host system to launch the application using eith .NET 1.1 
CLR or .NET 1.0 CLR rather than defaulting to the .NET 2.0 CLR. The supportedRuntime element 
identifies the versions of the CLR with which the application can be run. The supportedRuntime 
element is only supported in assemblies built using.NET 1.1 or later. 

Incorrect Answers: 

A: There is no such subelement as bindingRedirect that exists for the startup element. 
B: The requiredRuntime element should only be used by assemblies built by using the .NET 1.0 
Framework. 
D: There is no such element as the unsupportedRuntime element that exists in the application 
configuration schema. 

Configure the location of an assembly and which version of the assembly to use. 










QUESTION NO: 41 

You work as an application developer at CertKiller.com. You have recently created a business 
application that references another strong-named assembly named library.dll, and deployed it to 
all CertKiller.com users. 

Subsequent to testing the applications performance, you elect to upgrade the assembly's version 
to 1.1.0.0. 

You need to ensure that the new version of will not affect any of CertKiller.com's current users by 
adding the appropriate element to the assemblyBinding element in the application configuration 
file. 

What element should you add? 

A.
<dependentAssembly> 
	<assemblyIdentity name="Library" publicKeyToken="32ab4bc45e90a1" culture="neutral" /> 
	<redirect oldVersion="1.0.0.0" newVersion="1.1.0.0" /> 
</dependentAssembly> 

B.
<dependentAssembly> 
	<assemblyIdentity name="Library" publicKeyToken="32ab4bc45e90a1" culture="neutral" /> 
	<bindingRedirect oldVersion="1.0.0.0" newVersion="1.1.0.0" /> 
</dependentAssembly> 

C.
<dependentAssembly> 
	<assemblyIdentity name="Library" publicKeyToken="32ab4bc45e90a1" culture="neutral" 
	oldVersion="1.0.0.0" newVersion="1.1.0.0" /> 
</dependentAssembly> 

D.
<dependentAssembly> 
	<bindingRedirect oldVersion="1.0.0.0" newVersion="1.1.0.0" /> 
</dependentAssembly> 





















Answer: B 

Explanation: 

This dependentAssembly element specifies the assembly identity information using the 
assemblyIdentity element. The name attribute of the assemblyIdentity element indicates the 
common name of the assembly. The publicKeyToken attribute specifies the strong-named key, 
and the culture attribute indicates the localization type. The bindingRedirect element is a 
sub-element of the dependentAssembly element that specifies the oldVersion and newVersion 
attributes. Setting the oldVersion attribute to 1.0.0.0 and the newVersion attribute to 1.1.0.0 
means that any users referencing the 1.0.0.0 version of the Library will now be referencing the 
1.1.0.0 version. 

Incorrect Answers: 

A: You should not use the element that specifies the redirect element because there is no such 
subelement of the assemblyBinding element. 
C: You should not use the element that specifies the assemblyIdentity element because this is 
required information when adding dependentAssembly elements. 
D: You should not use the element that specifies the bindingRedirect element because there are 
no such attributes as oldVersion and newVersion attributes for the assemblyIdentity element. 










QUESTION NO: 42 

You work as an application developer at CertKiller.com. You are currently in the process of 
creating a shared assembly. 

You are required to perform many integration tests to make sure the assembly works properly with 
multiple applications. You want to avoid constantly updating each application's reference when the 
assembly is updated. 

You have set the DEVPATH environmental variable to the default build location for the shared 
assembly. 

You need to ensure that the Common Language Runtime (CLR) uses DEVPATH to locate the 
shared assembly. 

What should you do? 

A. Add the following element to each application's application configuration file: 
<dependentAssembly>
	<assemblyIdentity name="SharedAssembly" />
	<codeBase version="1.0.0.0" DEVPATH ="true" /> 
</dependentAssembly > 

B. Add the following element to the machine.config file in the development computer: 
<dependentAssembly>
	<assemblyIdentity name="SharedAssembly" />
	<codeBase version="1.0.0.0" DEVPATH ="true" /> 
</dependentAssembly > 

C. Add the following element to each application's application configuration file: 
<configuration> 
	<runtime>
		<developmentMode developerInstallation="true" /> 
	</runtime> 
</configuration> 

D. Add the following element to the machine.config file in the development computer: 
<configuration> 
	<runtime> 
		<developmentMode developerInstallation="true" /> 
	</runtime> 
</configuration> 





















Answer: D 

Explanation: 

The developmentMode element instructs the CLR to use the DEVPATH environmental variable to 
locate assemblies. If you do not add this element to the machine.config file, the DEVPATH 
environmental variable will be ignored. 

Incorrect Answers: 

A: Application configuration files are used for application-specific settings only 
B: The codeBase element does not have a DEVPATH attribute. 
C: Application configuration files are used for application-specific settings only 










QUESTION NO: 43 

You work as an application developer at CertKiller.com. You have been asked to profile a 
business application that can be accessible using the Event Log API. 


You have started by adding the following code to create a custom event log: 


if (EventLog.SourceExists ("Application1")) 
	EventLog.DeleteEventSource ("Application1"); 
//Create new event log 
EventLog.CreateEventSource ("Application1", "Profile"); 


You need to write an event to the Application1 event log. 


What code must you use? 


A.
EventLog log = new EventLog (); 
log.Source = "Application1"; 
log.Log = "Profile"; 
log.WriteEvent ("Writing to event log."); 
B.
EventLog log = new EventLog (); 
log.Source = "Profile"; 
log.Log = "Application1"; 
log.WriteEvent ("Writing to event log."); 
C.
EventLog log = new EventLog (); 
log.Source = "Application1"; 
log.Log = "Profile"; 
log.WriteEntry ("Writing to event log."); 
D.
EventLog log = new EventLog (); 
log.Source = "Profile"; 
log.Log = "Application1"; 
log.WriteEntry ("Writing to event log."); 




















Answer: C 

Explanation: 

This code instantiates an EventLog object, sets the Source and Log properties, and invokes the 
WriteEntry method to output the message to the event log. The EventLog object allows you to 
create, delete, read from, or write to Windows event logs. In this scenario, you use the 
CreateEventSource method to create a custom event log. When calling the CreateEventSource 
method, you pass the method two arguments. The first argument represents the source name for 
the event log, and the second represents the name of the event log. Next, you want to write an 
entry to the Application1 event log. To write to an event log, you must first identify the event 
source and the name of the event log to which you want to write. The Source property specifies 
the event source, and the Log property specifies the name of the event log. There are two 
methods to write to the EventLog object: WriteEntry and WriteEvent . The WriteEntry method is 
an overloaded method used to write a text message to an event log. The WriteEvent method is 
used to write localized resources and event instances to an event log. 

Incorrect Answers: 

A: The WriteEvent method is used to write localized resources and event instances to an event 
log. 
B: The WriteEvent method is used to write localized resources and event instances to an event 
log. 
Read from an event log. 
D: You should not use the code fragments that specify a value of "Profile" for the Source property 
and a value "Application1" for the Log property because they would attempt to write the entry to an 
event log named Application1. 










QUESTION NO: 44 


You work as an application developer at CertKiller.com. The CertKiller.com network contains an 
application server named CERTKILLER-SR07. You have been asked to profile a business application that 
can be accessible using the Event Log API. You want to achieve this by creating a custom event log 
on CERTKILLER-SR07. 

What should you do? 

A. Use the following code: 
EventLog.CreateEventSource ("Application1", "Profile", "CERTKILLER-SR07"); 
B. Use the following code: 
EventLog.CreateEventSource ("Application1", "Profile"); 
C. Use the following code: 
EventSourceCreationData sourceData = new EventSourceCreationData ("Application1", "Profile"); 
sourceData.MachineName = "CERTKILLER-SR07"; 
EventLog.CreateEventSource (sourceData); 
D. Use the following code: 
EventSourceCreationData sourceData = new EventSourceCreationData ("Application1", "Profile"); 
EventLog.CreateEventSource (sourceData); 




















Answer: C 

Explanation: 

This code instantiates an EventSourceCreationData object, sets the MachineName property of the 
EventSourceCreationData object, and invokes the CreateEventSource method, passing the 
EventSourceCreationData object as an argument, to create the custom event log. 

The EventSourceCreationData object is used to configure a new event log source. You can then 
pass the EventSourceCreationData object to the CreateEventSource method of an EventLog to 
register the event log source and corresponding event log so that you can write entries to it. The 
EventSourceCreationData object's constructor accepts two String arguments: Source and Log . 
The Source argument specifies the event source, and the Log argument specifies the name of the 
event log. After creating an instance of EventSourceCreationData , you can set the 
EventSourceCreationData object's properties to further configure the event source. The 
MachineName property represents the computer on which you want to create the event source. In 
this scenario, you create a new EventSourceCreationData object named sourceData and then set 
its MachineName property to CERTKILLER-SR07 . Then, you call the CreateEventSource 
method, passing the method sourceData . This creates an event log source on the computer 
named CERTKILLER-SR07.

Incorrect Answers: 

A: The CreateEventSource method that takes three String arguments is obsolete in the .NET 2.0 
Framework.
B: Both of these code fragments would create an event log on the local computer by default, but 
the scenario states that you should explicitly specify the machine name because the computer on 
which the code is running is unknown.
D: Both of these code fragments would create an event log on the local computer by default, but 
the scenario states that you should explicitly specify the machine name because the computer on 
which the code is running is unknown.










QUESTION NO: 45 

You work as an application developer at CertKiller.com. You are required to retrieve and display 
the names of all processes that are currently running in memory. 

What should you do? 

A. Use the following code: 
foreach (Process curProcess in Process.GetSystemProcesses ()) 
Console.WriteLine (curProcess.ProcessName); 

B. Use the following code: 
foreach (Process curProcess in Process.GetAllProcesses ()) 
Console.WriteLine (curProcess.ProcessName); 

C. Use the following code: 
foreach (Process curProcess in Process.GetProcesses ()) 
Console.WriteLine (curProcess.ProcessName); 

D. Use the following code: 
foreach (Process curProcess in Thread.GetProcesses ()) 
Console.WriteLine (curProcess.ProcessName); 





















Answer: C 

Explanation: 

The GetProcesses method creates and returns an array of Process objects representing all 
currently running processes in memory. Because this method invocation does not contain a 
computer name, the local machine is assumed. The curProcess variable is reassigned to a 
Process object with each iteration. The ProcessName property of the Process object retrieves the 
system name of the process. The WriteLine method of the Console class outputs the process 
name to the console. Because the WriteLine method outputs a line return, each process name will 
be on a separate line in the Console window. 

Incorrect Answers: 

A: The GetSystemProcesses and GetAllProcesses methods do not exist in the Process class. 
B: The GetSystemProcesses and GetAllProcesses methods do not exist in the Process class. 
D: There is no such method as the GetProcesses method in the Thread class. 











QUESTION NO: 46 

You work as an application developer at CertKiller.com. CertKiller.com is currently using a 
performance counter named HitCounter. 

You are required to increment each time a user accesses the UI classes within the application. To 
do this, you start by creating performance counters using the following code: 

You have to adjust the HitCounter performance counter when a hit occurs. 


What should you do? 

A. Use the following code: 
PerformanceCounter hitCounter = new PerformanceCounter ("ApplicationPerformance", "HitCounter"); 
hitCounter.ReadOnly = false; 
hitCounter.Increment(); 

B. Use the following code: 
PerformanceCounter hitCounter = new PerformanceCounter ("ApplicationPerformance", "HitCounter"); 
hitCounter.Increment(); 

C. Use the following code: 
PerformanceCounter hitCounter = new PerformanceCounter ("ApplicationPerformance", "HitCounter"); 
hitCounter ++; 

D. Use the following code: 
PerformanceCounter hitCounter = new PerformanceCounter ("ApplicationPerformance", "HitCounter"); 
hitCounter.ReadOnly = false; 
hitCounter ++; 




















Answer: A 

Explanation: 

This code creates a new PerformanceCounter object that references the ApplicationPerformance 
category and the HitCounter performance counter. By default, a performance counter is read-
only, so this code sets the ReadOnly property to False . Then, the Increment method is called to 
increase the counter by one. The PerformanceCounter class also provides an IncrementBy 
method, which increments the performance counter by the value specified in a provided argument. 

Incorrect Answers: 

B: You should not use the code fragments that fail to set the ReadOnly property to False because 
by default, all performance counter objects are read-only. 
C: You should not use the code fragments that use the ++ operator to increment the 
PerformanceCounter object because this will cause a compile-time error. 
D: You should not use the code fragments that use the ++ operator to increment the 
PerformanceCounter object because this will cause a compile-time error. 










QUESTION NO: 47 

You work as an application developer at CertKiller.com. You would like to create a custom 
performance counter for an application that you created recently. 

To do this, you decide to create a custom category named ApplicationPerformance and a 
performance counter named HitNumber. 

You need to ensure that this counter is shared across numerous applications. 

What should you do? 

A. Use the following code: 
PerformanceCounterCategory.Create ("ApplicationPerformance", "ApplicationPerformanceHelp", 
PerformanceCounterCategoryType.MultiInstance, "HitNumber", "HitNumberHelp"); 

B. Use the following code: 
PerformanceCounterCategory.Create ("HitNumber", "HitNumberHelp", 
PerformanceCounterCategoryType.SingleInstance, "ApplicationPerformance" "ApplicationPerformanceHelp");

C. Use the following code: 
PerformanceCounterCategory.Create ("HitNumber", "HitNumberHelp", 
PerformanceCounterCategoryType.MultiInstance, "ApplicationPerformance" "ApplicationPerformanceHelp"); 

D. Use the following code: 
PerformanceCounterCategory.Create ("ApplicationPerformance", "ApplicationPerformanceHelp", 
PerformanceCounterCategoryType.SingleInstance, "HitNumber", "HitNumberHelp"); 





















Answer: D 

Explanation: 

This code invokes the Create method of the PerformanceCounterCategory class. This method 
registers a custom category on the local computer. The first two arguments specify the name of 
the category and category help string, respectively. The third argument specifies a 
PerformanceCounterCategoryType enumeration value indicating how many counters can be in 
use within the specified category. The value PerformanceCounterCategoryType.SigleInstance 
indicates that only a single instance can exist for the entire category. The last two arguments 
specify the name of the performance counter and the counter's help string, respectively. 

Incorrect Answers: 

A: The code fragments that specify the MultiInstance value should not be used because the 
scenario requires you to share the same counter across multiple applications. 
B: This code fragment incorrectly assigns the value HitNumber to the category name and 
ApplicationPerformance to the counter name. 
C: The code fragments that specify the MultiInstance value should not be used because the 
scenario requires you to share the same counter across multiple applications. 










QUESTION NO: 48 

You work as an application developer at CertKiller.com. 

You are required to launch the App.exe process, and specify sample.txt as the input file. App.exe 
will then use the contents of sample.txt to establish the environment's current settings. 

You need to ensure that the code you use meets these requirements. 

What should you do? 

A. Use the following code: 
Process myProcess = new Process(); 
myProcess.StartInfo = new ProcessStartInfo ("App.exe sample.txt"); 
myProcess.Start ();

B. Use the following code: 
Process myProcess = new Process(); 
myProcess.StartInfo = new ProcessStartInfo ("App.exe"); 
myProcess.ProcessStartArgs ("sample.txt"); 
myProcess.Start ();

C. Use the following code: 
Process myProcess = new Process(); 
myProcess.StartInfo = new ProcessStartInfo ("App.exe"); 
myProcess.Start ("sample.txt");

D. Use the following code: 
Process myProcess = new Process(); 
myProcess.StartInfo = new ProcessStartInfo ("App.exe"); 
myProcess.StartInfo.FileName = "sample.txt" 
myProcess.Start (); 




















Answer: D 

Explanation: 

This code creates a new Process object, sets the application to run using the StartInfo property, 
and uses the FileName property to specify the file to use as input. The StartInfo property of a 
Process object stores startup information for the process. This includes the application to run and 
any command-line arguments to be used by the application. The FileName property must be set, 
and can be set by either explicitly setting the FileName property or by passing the name of the file 
to the ProcessStartInfo constructor. The Start method launches the application process with the 
values specified in the StartInfo property. 

In this scenario, the code declares a new Process object named myProcess and then sets the 
StartInfo property of this process. The code passes the constructor of the ProcessStartInfo a 
single argument representing the name of the application, App.exe . Next, the FileName property 
is explicitly set with an assignment statement to the value of "sample.txt" . Then, the code call the 
Start method to launch the application using the values specified in the customized startup 
settings. 

Incorrect Answers: 

A: You should not use the code that passes a single string containing the application and input file 
to the ProcessStartInfo constructor.  
B: You should not use the code that invokes the ProcessStartArgs method because no such 
method exists in the Process class. 
C: You should not use the code that invokes the Start method of the Process object specifying the 
input file because no such method signature exists. 










QUESTION NO: 49 

You work as an application developer at CertKiller.com. CertKiller.com uses an application that 
calculates monthly payments based upon client input. You are currently debugging this application 
using the Microsoft Visual Studio 2005 IDE. 

The application contains the following code: 

public double CalculateMonthlyPayment (Single rate, double principal) 
{ 
	//Implementation code 
} 

You have discovered that unexpected results are being returned by the application. You would like 
to pause execution and display a message box containing an error message in the event of a 
negative or zero rate value is Passed to the CalculateMonthlyPayment method. 

You need to ensure that this only occurs during debugging mode. 

What should you do? 

A. Add the following code to the beginning of the CalculateMonthlyPayment method: 
Debug.Assert (rate > 0, "Rate Error", "Rate must be > zero"); 

B. Add the following code to the beginning of the CalculateMonthlyPayment method: 
if (rate <= 0) 
	MessageBox.Show ("Rate is" + rate, Error); 

C. Add the following code to the beginning of the CalculateMonthlyPayment method: 
if (rate <= 0) 
	Debug.WriteLine ("Error Rate is" + rate); 

D. Add the following code to the beginning of the CalculateMonthlyPayment method: 
Debug.WriteLineIf (rate <= 0, "Error Rate is" & rate); 




















Answer: A 

Explanation: 

This code makes the debugging assertion that the rate argument is greater than zero. If it is not, 
then a message box will be display with the message Rate Error along with the detailed 
description " Rate must be > zero ". The Assert method of the debug class is an overloaded 
method that provides you the ability to test assumptions made in your programming logic. The 
Assert method accepts three arguments, the first of which is required. This first argument 
represents a condition that is assumed to be true for your programming logic and will evaluate to a 
Boolean value. The other two arguments represent optional string messages. When the Assert 
method is invoked with three arguments, the condition is evaluated. If the condition evaluates to 
true, then the program continues to execute. If the condition evaluates to false, the program execution is halted, and by default a modal dialog box is displayed. This dialog box displays the 
first string on a single line, the second string on the second line, and then the location at which the 
assertion failed. From this dialog box, you can invoke the debugger, continue execution, or exit 
the application. Output generated using the Debug class is stripped out when creating a release 
version build of an application. 

Incorrect Answers: 

B: In this scenario, you want the dialog box to display only for debug builds of the application. 
Using this code, the message box would display in a release build of the application. 
C: The output of these options will not display in a message box. 
D: The output of these options will not display in a message box. 

Trace class, CorrelationManager class, TraceListener class, TraceSource class, TraceSwitch 
class, XmlWriterTraceListener class, DelimitedListTraceListener class, and EventlogTraceListener 
class 










QUESTION NO: 50 

You work as an application developer at CertKiller.com. You are preparing to run diagnostics on 
an application by using TraceSwitch objects. 

You start by adding the following elements to the application configuration file: 

<configuration>
  <system.diagnostics>
    <switches>
      <add name="mySwitch" value="1" />
    </switches>
  </system.diagnostics>
</configuration>

You then test the TraceSwitch settings by using the code displayed in the exhibit below: 

private static TraceSwitch appSwitch = new TraceSwitch("mySwitch", "Switch in config file");

public void TestTraceSwitches(int input)
{
    Console.WriteLine("Entering TestTraceSwitches method.";
	Trace.WriteLineIf(input <= 0, "Input cannot be less than or equal to 0.");
    ... bored now.
}

What represents the output that will be displayed by this test? 

A. Entering TestTraceSwitches method. 
Input: 0 
Input cannot be less than or equal to 0. 
Exception thrown in TestTraceSwitches method. 
Exiting TestTraceSwitches method. 

B. Entering TestTraceSwitches method. 
Input cannot be less than or equal to 0. 
Exception thrown in TestTraceSwitches method. 

C. Entering TestTraceSwitches method. 
Input cannot be less than or equal to 0. 
Exception thrown in TestTraceSwitches method. 
Exiting TestTraceSwitches method. 

D. Input cannot be less than or equal to 0. 
Exception thrown in TestTraceSwitches method. 




















Answer: B 

Explanation: 

In this scenario, the DataTraceSwitch is set to 1, or TraceLevel.Error , and the 
MessageTraceSwitch is set to 3, or TraceLevel.Info . The Trace.WriteLineIf method invocations 
check the TraceLevel of each switch. In this way, only error messages will be in the output if the 
DataTraceSwitch.TraceLevel property is evaluated. All messages except verbose will be in the output if the MessageTraceSwitchTraceLevel property is evaluated. The reason that the last trace 
message is not in the output is because an exception is thrown before that statement can be 
executed. 

Incorrect Answers: 

A: These options are all incorrect because they do not indicate the correct output based on the 
TraceLevel settings of the TraceSwitch object. 
C: These options are all incorrect because they do not indicate the correct output based on the 
TraceLevel settings of the TraceSwitch object. 
D: These options are all incorrect because they do not indicate the correct output based on the 
TraceLevel settings of the TraceSwitch object. 










QUESTION NO: 51 

You work as an application developer at CertKiller.com. You have recently created an application, 
and want to capture all debugging text messages generated by it. 

You would like these debugging messages to display on the command line. The application that 
you created contains the following code: 

Debug.WriteLine ("Start the processing"); 
Console.WriteLine ("Generated by Console.WriteLine"); 
Debug.WriteLine ("End the processing"); 

You need to ensure that you are able to capture all debugging messages to the command line. 

What should you do? 

A. Use the following code: 
Debug.Listeners.Add (new TextWriterTraceListener (Console.Out)); 
Debug.AutoFlush = true; 
B. Use the following code: 
Debug.Listeners.Add (new StreamWriter (Console.Out)); 
Debug.AutoFlush = true; 
C. Use the following code: 
Debug.Listeners.Add (new ConsoleTraceListener ()); 
Debug.AutoFlush = true; 
D. Use the following code: 
Debug.Listeners.Add (new DefaultTraceListener ()); 
Debug.AutoFlush = true; 




















Answer: C Explanation: 

Listeners are used to capture trace and debug messages. Both the Trace and Debug objects 
share the same Listeners collection, which includes a DefaultTraceListener that will capture trace 
and debug messages in the Output window. You are able to override this behavior by using the 
Add method to add another listener to the Listeners collection. The ConsoleTraceListener is used 
to route trace and debug messages to the console. The AutoFlush property should be set to true 
for immediate capture. This specifies that after each message is written, the buffer is flushed and 
the output is written to the listener. 

Incorrect Answers: 

A: You should not use the code that instantiates a TextWriterTraceListener object that specifies 
the Console's output stream because this is less efficient than specifying a ConsoleTraceListener 
object. 
B: You should not use the code that instantiates a StreamWriter object that specifies the Console's 
output stream because the Listeners collection allows only Listener object streams. 
D: You should not use the code that instantiates a DefaultTraceListener object because this will 
capture the debugging messages to the Output window in the Visual Studio .NET 2005 IDE. Also, 
each Listeners collection will contain a DefaultTraceListener by default. 










QUESTION NO: 52 

You work as an application developer at CertKiller.com. You have created an application to 
interface with an inventory storage system, and want to enable tracing in the application to track 
stock shortages and surpluses. 

The application should not, however, trace inventory levels if no shortages or surpluses exist. In 
addition, you do not want recompile every time to switch tracing capabilities on or off. 

What should you do? 

A. Specify a command-line argument named InventoryTrace, and configure the application to read 
the argument. 
B. Specify a system-wide environmental variable named InventoryTrace, and configure the 
application to read the environmental variable. 
C. Specify a registry key named InventoryTrace, and configure the application to read the registry 
key setting. 
D. Specify a BooleanSwitch named InventoryTrace, and configure it in the application 
configuration file. 




















Answer: D 

Explanation: The BooleanSwitch class is used to toggle trace messages on and off. The application 
configuration is intended to manage any application-specific settings, including tracing. The value 
of the Enabled property determines whether the BooleanSwitch is turned on or off. This value is 
set in the application configuration file. If the value is 0, then the BooleanSwitch object is turned 
off and the Enabled property returns false. If the value is any other value, the BooleanSwitch 
object is turned on and the Enabled property returns true. 

Incorrect Answers: 

A: This option requires the application to run from the command-line. 
Retrieve a collection of Management objects by using the ManagementObjectSearcher class and 
its derived classes. 
B: This option requires EnvironmentPermission and is intended for more complex application 
settings. 
C: This option requires RegistryPermission and is intended for system-wide settings, not for 
application-specific settings. 
Debugger attributesPart 6: Embed management information and events into a .NET Framework 
application. (Refer System.Management namespace) 










QUESTION NO: 53 

You work as an application developer at CertKiller.com. CertKiller.com has a server named 
CERTKILLER-SR05 that has numerous processors installed. 

You have been given the task of developing an application that displays certain clock speed 
statistics on all processors installed on CERTKILLER-SR05. 

You need to ensure that this requirement is fully satisfied. 

What should you do? 

A. Use the following code: 
ManagementObjectSearcher processorSearcher = new ManagementObjectSearcher (); 
foreach (ManagementObject obj in processorSearcher.Get ("SELECT * FROM 
Win32_Processor")) 
{ 
Console.WriteLine ("{0}", obj ["Name"]); 
Console.WriteLine ("{0} / {1}", obj ["CurrentClockSpeed"], Obj ["MaxClockSpeed"]); 
} 

B. Use the following code: 
ManagementObjectSearcher processorSearcher = new ManagementObjectSearcher ( 
"SELECT * FROM Win32_Processor"); 
foreach (ManagementObject obj in processorSearcher.Get ()) 
{ 
Console.WriteLine ("{0}", obj ["Name"]);

 Console.WriteLine ("{0} / {1}", obj ["CurrentClockSpeed"], Obj ["MaxClockSpeed"]); 
} 

C. Use the following code: 
ManagementObjectQuery processorQuery = new ManagementObjectQuery (); 
foreach (ManagementObject obj in processorQuery.Get ("SELECT * FROM Win32_Processor")) 
{ 
Console.WriteLine ("{0}", obj ["Name"]); 
Console.WriteLine ("{0} / {1}", obj ["CurrentClockSpeed"], Obj ["MaxClockSpeed"]); 
} 

D. Use the following code: 
ManagementObjectQuery processorQuery = new ManagementObjectQuery ( 
"SELECT * FROM Win32_Processor"); 
foreach (ManagementObject obj in processorQuery.Get ()) 
{

 Console.WriteLine ("{0}", obj ["Name"]); 
Console.WriteLine ("{0} / {1}", obj ["CurrentClockSpeed"], Obj ["MaxClockSpeed"]); 
} 





















Answer: B 

Explanation: 

This code retrieve all Win32_Processor objects on the local machine, iterates through each 
Win32_Processor object, and displays the Name , CurrentClockSpeed , and MaxClockSpeed 
properties for each Win32_Processor object. First, the ManagementObjectSearcher object is 
instantiated with the WQL query string on which to search. WQL is a subset of SQL , and it is 
specifically designed for WMI . The WQL string specified in this code returns any 32-bit 
processors available on the local machine. The Get method returns a 
ManagementObjectCollection object. On each iteration, a ManagementObject object is assigned 
to the variable obj . the Console.WriteLine method display the Name , ClockSpeed , and 
MaxClockSpeed properties on the command-line using a string indexer. 

Incorrect Answers: 

A: You should not use the code that specifies the WQL query string as an argument of the Get 
method of the ManagementObjectSearcher object because the Get method does not accept a 
string data type. 
C: You should not use the code that specifies the ManagementObjectQuery class because there 
is no such class in the .NET 2.0 class library. 
D: You should not use the code that specifies the ManagementObjectQuery class because there 
is no such class in the .NET 2.0 class library. 










QUESTION NO: 54 
You work as an application developer at CertKiller.com. You have developed an application that 
simplifies hard drive management for CertKiller.com's administrators. 

The application that you created logs all modifications made to physical hard drives on an hourly 
basis. You now need to create an EventQuery object for this application. 

What should you do? 

A. Use the following code: 
EventQuery query = new EventQuery (); 
query.QueryString = "SELECT InstanceModificationEvent FROM 'Win32_DiskDrive'" + 
"WITHIN 3600"; 


B. Use the following code: 
EventQuery query = new EventQuery (); 
query.QueryString = "SELECT * FROM_ InstanceModificationEvent WITHIN 3600" + 
"WHERE TargetInstance ISA 'Win32_DiskDrive'"; 


C. Use the following code: 
EventQuery query = new EventQuery (); 
query.QueryString = "SELECT * FROM 'Win32_DiskDrive' WITHIN 3600" + 
"WHERE TargetInstance ISA_InstanceModificationEvent"; 


D. Use the following code: 
EventQuery query = new EventQuery (); 
query.QueryString = "SELECT * FROM _InstanceModificationEvent WITHIN 3600" + 
"WHERE Instance = 'Win32_DiskDrive'"; 






















Answer: B 

Explanation: 

This code creates a new EventQuery object that queries all disk drive events every hour. The 
QueryString property contains a string that follows the syntax of WQL . WQL is a subset of SQL , 
and it is specifically designed for WMI . The SELECT clause indicates retrieval, where the asterisk 
(*) represents all properties associated with the event. The FROM clause indicates the event, 
which in this case is _InstanceModificationEvent . The WITHIN clause specifies the polling 
interval in seconds. The WHERE clause specifies the condition that must be met. In this 
scenario, the TargetInstance filed is compared to the value Win32_DiskDrive . This limits the 
_InstanceModificationEvent events to only those that modify hard drives. 

Incorrect Answers: 

A: InstanceModificationEvent is not a valid event property and Win32_DiskDrive is not a valid 
event. 
C: The FROM clause should specify the event InstanceModificationEvent and the ISA operator 
should use the Win32_DiskDrive class. 
Subscribe to management events by using the ManagementEventWatcher class. 
D: Instance is not a valid field name and the equal sign (=) is not valid for class comparisons. 










QUESTION NO: 55 

You work as an application developer at CertKiller.com. 

CertKiller.com has given you the task of serializing an object and writing it to a data file using 
binary serialization. 

You need to ensure that you meet these requirements. 

What should you do? 

A. Use the following code: 
object obj = new object (); 
Stream objStream = File.Open ("DataFile.dat", FileMode.Create); 
BinaryFormatter objFormatter = new BinaryFormatter (); 
objFormatter.Serialize (objStream, obj); 
B. Use the following code: 
object obj = new object (); 
BinaryFormatter objFormatter = new BinaryFormatter (); 
objFormatter.Serialize (obj); 
C. Use the following code: 
Stream objStream = File.Open ("DataFile.dat", FileMode.Create); 
BinaryFormatter objFormatter = new BinaryFormatter (); 
objFormatter.Serialize (objStream); 
D. Use the following code: 
object obj = new object (); 
Stream objStream = File.Open ("DataFile.dat", FileMode.Create); 
BinaryFormatter objFormatter = new BinaryFormatter (); 
objFormatter.Serialize (obj, objStream); 




















Answer: A 

Explanation: 

This code instantiates an object named obj , opens a file stream, instantiates a BinaryFormatter 
object, and serializes the obj object to the DataFile.dat file. The File.Open method takes a file 
path string and FileMode enumeration value as arguments and returns a FileStream object. The 
Serialize method of the BinaryFormatter class takes two arguments: a stream and the object to be 
serialized. The Serialize method uses the stream to write the object to the destination. 

Incorrect Answers: 

B: If you use these options it will cause a compile-time error. 
C: If you use these options it will cause a compile-time error. 
D: If you use these options it will cause a compile-time error. 










QUESTION NO: 56 

You work as an application developer at CertKiller.com. You have recently created a serializable 
class named Vehicle. 


The class is shown below: 


[Serializable] 
public class Vehicle 
{ 
	public string VIN; 
	public string Make; 
	public string Model; 
	public string Year; 
} 


You are planning to create a custom formatter class to control the formatting of Vehicle objects 
when they are serialized. You need to ensure that is achieved with as little development effort as 
possible. 


What should you do? 


A. Use the following code: 
public class VehicleFormatter : Formatter 
{ 
//Implementation omitted 
} 

B. Use the following code: 
public class VehicleFormatter : IGenericFormatter 
{ 
//Implementation omitted 
} 

C. Use the following code: 
public class VehicleFormatter : IFormatConverter 
{ 
//Implementation omitted 
} 

D. Use the following code 
public class VehicleFormatter : IFormatter 
{ 
//Implementation omitted 
} 





















Answer: D 

Explanation: 

When implementing the IFormatter interface, you must provide implementation for two methods 
and three properties. The two methods, Serialize and Deserialize control how objects will be 
stored from memory and loaded into memory, respectively. Both methods accept a Stream object 
as an argument. The Serialize method also takes a generic object as its second argument and 
uses the Stream argument to write the object. The Deserialize method returns the object using 
the Stream argument. The Binder, Context, and Surrogate Selector properties must also be 
implemented. 

Incorrect Answers: 

A: The Formatter class requires more development effort than necessary. 
B: The IGenericFormatter interface does not exist. 
C: The IFormatConverter interface does not control formatting during serialization. 










QUESTION NO: 57 

You work as an application developer at CertKiller.com. You develop a serializable class for 
persisting objects as files. 

Every time an object is serialized, you have to update the database with the name of the object 
and location of that file. You elect to employ the OnSerialized attribute to achieve this objective. 

You now need to apply the Onserialized attribute to a certain method. 

What should you do? 

A. Apply the OnSerialized attribute to the following method: 
public void AfterSerialization (object sender, SerializationEventArgs e) 
{ 
//Update database 
} 

B. Apply the OnSerialized attribute to the following method: 
public void AfterSerialization (object sender 
{ 
//Update database 
} 

C. Apply the OnSerialized attribute to the following method: 
public void AfterSerialization (StreamingContext context) 
{

 //Update database 
} 

D. Apply the OnSerialized attribute to the following method: 
public StreamingContext AfterSerialization () 
{ 
//Update database 
} 






















Answer: C 

Explanation: 

This method contains the correct method signature to have the OnSerialized attribute applied. 
The method must accept a StreamingContext as an argument for accessing the read/write stream 
during serialization/deserialization. 

Incorrect Answers: 

A: You should not apply the OnSerializedattribute to these methods because they do not accept a 
StreamingContext as an argument.
Part 2: Control the serialization of an object into XML format by 
using the System.Xml.Serialization namespace. 
Serialize and deserialize objects into XML format by using the XmlSerializer class. 
B: You should not apply the OnSerializedattribute to these methods because they do not accept a 
StreamingContext as an argument.
Part 2: Control the serialization of an object into XML format by 
using the System.Xml.Serialization namespace. 
D: You should not apply the OnSerializedattribute to these methods because they do not accept a 
StreamingContext as an argument.
Part 2: Control the serialization of an object into XML format by 
using the System.Xml.Serialization namespace. 










QUESTION NO: 58 

You work as an application developer at CertKiller.com. You have recently created a point of sale 
application that serializes sales products into XML, which will then be consumed by 
CertKiller.com's partner company. 

The following exhibit shows the appropriate serializable classes that you have created. 
You then test the serialization process by creating code in the exhibit below: 


What will be in the file if you invoke the Serialize method? 

A. <?xml version="1.0" encoding="utf-8"?> 
<Region xmlns:xsi="http://www,w3,org/2001/XMLSchema-instance" 
xmlns:xsd= ="http://www,w3,org/2001/XMLSchema"> 
<Products> 
<Product> IsTaxable="true">Sofa</Product> 
<Product> Television</Product> </Products> 
</Region> 

B. <?xml version="1.0" encoding="utf-8"?> 
<Region xmlns:xsi="http://www,w3,org/2001/XMLSchema-instance"

 xmlns:xsd= ="http://www,w3,org/2001/XMLSchema">

 <Products>

 <SalesProduct Taxable="true">

 <Name>Sofa</Name>

 </SalesProduct>

 <Product> 
<Name>Television</Name> 
</Product> 
</Products> 
</Region> 

C. <?xml version="1.0" encoding="utf-8"?> 
<Region xmlns:xsi="http://www,w3,org/2001/XMLSchema-instance"

 xmlns:xsd= ="http://www,w3,org/2001/XMLSchema">

 <Products>

 <SalesProduct>

 <IsTaxable>true</IsTaxable >

 <Name>Sofa</Name>

 </SalesProduct>

 <Product>

 <Name>Television</Name>

 </Product>

 </Products> 

</Region> 

D. <?xml version="1.0" encoding="utf-8"?> 
<Region xmlns:xsi="http://www,w3,org/2001/XMLSchema-instance"

 xmlns:xsd= ="http://www,w3,org/2001/XMLSchema" Area="East">

 <Products>

 <SalesProduct Taxable="true">

 <Name>Sofa</Name>

 </SalesProduct>

 <Product>

 <Name>Television</Name>

 </Product>

 </Products> 

</Region> 





















Answer: D Explanation: 

The Area attribute will be written to the Region tag, in answer B the Area attribute is missing. 

B: Control serialization by using serialization attributes. 










QUESTION NO: 59 

You work as an application developer at CertKiller.com. You have recently created a serializable 
class named Vehicle. 


The class is shown below: 


[Serializable] 
public class Vehicle 
{ 
	public string VIN; 
	public string Make; 
	private string Model; 
	private int Year; 
	private string Owner; 
} 


CertKiller.com does not want the Owner field to be persisted when a Vehicle object is serialized, 
for security reasons. 


You need to ensure that this objective is fulfilled. 


What should you do? 


A. Apply the OptionalField attribute to the Owner field. 
B. Apply the NonSerialized attribute to the Owner field. 
C. Have the Vehicle class implement the IFormatter interface for custom serialization. 
D. Do nothing because, when using binary serialization, Private fields are never persisted. 




















Answer: B 

Explanation: 

This will ensure that the Owner field will not be serialized, but it will allow all other fields to be 
serialized normally. 

Incorrect Answers: 

A: This option would be used for deserialization. 
C: This option would require excessive developer effort. 
D: This is incorrect because all fields marked private or otherwise are persisted when using binary 
serialization. 










QUESTION NO: 60 

You work as an application developer at CertKiller.com. You have just completed the creation of 
an application that receives order data from CertKiller.com's partner company in XML format. 
The XML has to be utilized to create an Order object that is consumed by the new application. 
The following exhibit displays an example of CertKiller.com's partner company's XML data: 


You plan to use the XmlSerializer class to deserialize the XML data into an Order object. When 
you learn that CertKiller.com's partner company's XML also contains Shipping object data, you 
decide to deserialize the shipping object after the Shipping element is detected during 
deserialization. 

To achieve this, you need to use a certain event of the XmlSerializer class. What event should you use? 

A. UnknownElement 
B. UnknownNode 
C. UnreferencedObject 
D. UnknownAttribute 




















Answer: B 

Explanation: 

The UnknownNode event is fired when an unexpected element or node is detected that does not 
map to the XmlSerializer object's expected type. The UnknownNode event included the 
XmlNodeEventArgs , which allows access to the entire node of the XML data. This would allow 
easy deserialization for the Shipping object. 

Incorrect Answers: 

A: These options would not allow easy deserialization for the Shipping object. 
SoapFormatter class (Refer System.Runtime.Serialization.Formatters.Soap namespace) 
C: These options would not allow easy deserialization for the Shipping object. 
Implement XML Serialization interfaces to provide custom formatting for XML serialization. 
D: These options would not allow easy deserialization for the Shipping object. 
Delegates and event handlers are provided by the System.Xml.Serialization namespacePart 3: 
Implement custom serialization formatting by using the Serialization Formatter classes. 










QUESTION NO: 61 

You work as an application developer at CertKiller.com. You have recently written the code shown 
below: 

Hashtable emailAddresses = new Hashtable (); 
emailAddresses.Add ("Mia", "mia@CertKiller.com"); 
emailAddresses.Add ("Andy", "andy@CertKiller.com"); 
emailAddresses.Add ("Kara", "kara@CertKiller.com"); 

FileStream stream = new FileStream ("Email.dat", FileMode.Create); 
BinaryFormatter formatter = new BinaryFormatter (); 
formatter.Serialize (stream, emailAddresses); 

You need to ensure that you are able to load the emailAddresses object from the Email.dat file into 
your application. 

What should you do? A. Use the following code: 
FileStream readStream = new FileStream ("Email.dat", FileMode.Open); 
HashTable loadEmails = readStream.Deserialize (); 
B. Use the following code: 
FileStream readStream = new FileStream ("Email.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
HashTable loadEmails = readFormatter.Deserialize (readStream); 
C. Use the following code: 
FileStream readStream = new FileStream ("Email.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
HashTable loadEmails = (HashTable) readFormatter.Deserialize (readStream); 
D. Use the following code: 
FileStream readStream = new FileStream ("Email.dat", FileMode.Open); 
HashTable loadEmails = (HashTable) readFormatter.ReadObject (); 




















Answer: C 

Explanation: 

This instantiates a BinaryFormatter object, and deserializes the emailAddresses object from the 
Email.dat file. the FileStream constructor takes a file path string and FileMode enumeration value 
as arguments. The Deserialize method of the BinaryFormatter class takes the stream of the 
object to be deserialized and returns a generic object. This generic object must be cast or 
converted to the HashTable data type. 

Incorrect Answers: 

A: You should not use the code fragments that do not instantiate the BinaryFormatter object 
because the ReadObject and Deserialize methods do not exist in the FileStream class. 
B: You should not use the code that does not cast or convert the return value of the Deserialize 
method because the Deserialize method returns a generic object. 
BinaryFormatter class (Refer System.Runtime.Serialization.Formatters.Binary namespace) 
D: You should not use the code fragments that do not instantiate the BinaryFormatter object 
because the ReadObject and Deserialize methods do not exist in the FileStream class. 










QUESTION NO: 62 DRAG DROP 

You work as an application developer at CertKiller.com. You define a serializable class named 
Employee, which is shown in the exhibit below. 
To execute serialization on an Employee object, you write the code shown in the exhibit (line 
numbers are used for reference only). 


A trainee developer named Amy Wilson asks you which Employee class methods will be called 
and in what order they will be invoked. 
What should you tell Amy Wilson? 
To answer, select the methods to be used and arrange them in the correct order on invocation. 





















Answer: 












QUESTION NO: 63 

You work as an application developer at CertKiller.com. you have recently written the code shown 
below: 

Hashtable emailAddresses = new Hashtable (); 
emailAddresses.Add ("Mia", "mia@ CertKiller.com") 
emailAddresses.Add ("Andy", "andy@ CertKiller.com") 
emailAddresses.Add ("Kara", "kara@ CertKiller.com") 

You need to ensure that these e-mail addresses are stored in the Email.dat file so that you can 
load them again when the user restarts the application. 

What should you do? 

A. Add the following code: 
FileStream stream = new FileStream ("Email.dat", FileMode.Create); 
BinaryFormatter formatter = new BinaryFormatter (); 
formatter.Deserialize (stream, emailAddresses); 
B. Add the following code: 
FileStream stream = new FileStream ("Email.dat", FileMode.Create); 
BinaryFormatter formatter = new BinaryFormatter (); 
formatter.Serialize (stream, emailAddresses); 
C. Add the following code: 
FileStream stream = new FileStream ("Email.dat", FileMode.Create); 
stream.Serialize (emailAddresses); 
D. Add the following code: 
FileStream stream = new FileStream ("Email.dat", FileMode.Create); 
stream.WriteObject (emailAddresses); 




















Answer: B 

Explanation: 

This code instantiates a file stream, instantiates a BinaryFormatter object, and serializes the 
emailAddresses object to the Email.dat file. The FileStream constructor takes a file path string 
and FileMode enumeration as arguments. The Serialize method of the BinaryFormatter class 
takes two arguments, a stream and the object to be serialized. The Serialize method uses the 
stream to write the object to the destination. 

Incorrect Answers: 

A: You should not add the code that invokes the Deserialize method of the BinaryFormatter class 
because you must serialize the object first. 
C: You should not add the code fragments that do not instantiate the BinaryFormatter object 
because the WriteObject and Serialize methods do not exist in the FileStream class. 
D: You should not add the code fragments that do not instantiate the BinaryFormatter object 
because the WriteObject and Serialize methods do not exist in the FileStream class. 










QUESTION NO: 64 

You work as an application developer at CertKiller.com. You have recently completely creating a 
new application for CertKiller.com. 

This new application has to load an instance of the Inventory class from a large file named 
Inventory.dat. You need to ensure that the application executes the loading process in as little time 
as possible. 

What should you do? 

A. Use the following code: 
FileStream readStream = new FileStream ("Inventory.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
Inventory currentInventory = (Inventory) 
readFormatter.FastDeserialize (readStream); 

B. Use the following code: 
FileStream readStream = new FileStream ("Inventory.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
Inventory currentInventory = (Inventory) 
readFormatter.Deserialize (readStream); 


C. Use the following code: 
FileStream readStream = new FileStream ("Inventory.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
Inventory currentInventory = (Inventory) 
readFormatter.UnsafeDeserialize (readStream); 


D. Use the following code: 
FileStream readStream = new FileStream ("Inventory.dat", FileMode.Open); 
BinaryFormatter readFormatter = new BinaryFormatter (); 
Inventory currentInventory = (Inventory) 
readFormatter.SafeDeserialize (readStream); 






















Answer: C 

Explanation: 

This code instantiates a file stream, instantiates a BinaryFormatter object, and deserializes an 
Inventory object to the Inventory.dat file. The UnsafeDeserialize and Deserialize methods 
perform the same operation, but the UnsafeDeserialize method uses unmanaged code and 
requires more permission. Because the UnsafeDeserialize method uses unmanaged code, your 
code should be granted full trust to execute properly. The UnsafeDeserialize method of the 
BinaryFormatter class takes two arguments, the stream of the object to be deserialized and the 
HeaderHandler object to deal with any binary headers. The UnsafeDeserialize method returns a 
generic object that must be cast or converted to the Inventory data type. 

Incorrect Answers: 

A: You should not use the code that invokes the FastDeserialize and SafeDeserialize methods 
because no such methods exist for the BinaryFormatter class. 
File class and FileInfo class 
B: You should not use the code that invokes the Deserialize method because the 
UnsafeDeserialize method yields better performance.Part 4: Access files and folders by using the 
File System classes. (Refer System.IO namespace) 
Directory class and DirectoryInfo class 
D: You should not use the code that invokes the FastDeserialize and SafeDeserialize methods 
because no such methods exist for the BinaryFormatter class. 










QUESTION NO: 65 
You work as an application developer at CertKiller.com. CertKiller.com has asked you to develop 
an application that displays the properties for all CertKiller.com's network drives. 

The information generated by this application will be utilized by CertKiller.com's network 
administrators to verify client setups. 

You need to ensure that these requirements are fully satisfied. 

What should you do? 

A. Use the following code: 
public void EnumerateNetworkDrives () 
{ 
	foreach (Drive netDrive in Drive.GetDrives ()) 
	{ 
		if (netDrive.DriveType == DriveType.Network) 
			Console.WriteLine ("{0} ({1}) : {2} bytes", netDrive.Name, netDrive.VolumeLabel, netDrive.TotalSize); 
	} 
} 


B. Use the following code: 
public void EnumerateNetworkDrives() 
{ 
	foreach (DriveInfo netDrive in DriveInfo.GetDrives()) 
	{ 
		Console.WriteLine ("{0} ({1}) : {2} bytes", netDrive.Name, netDrive.VolumeLabel, netDrive.TotalSize); 
	} 
} 


C. Use the following code: 
public void EnumerateNetworkDrives() 
{ 
	foreach (DriveInfo netDrive in DriveInfo.GetDrives()) 
	{ 
		if (netDrive.DriveType == DriveType.Network) 
			Console.WriteLine ("{0} ({1}) : {2} bytes", netDrive.Name, netDrive.VolumeLabel, netDrive.TotalSize); 
	} 
} 


D. Use the following code: 
public void EnumerateNetworkDrives() 
{ 
	foreach (DriveInfo netDrive in DriveInfo.GetDrives(DriveType.Network)) 
	{
		Console.WriteLine ("{0} ({1}) : {2} bytes", netDrive.Name, netDrive.VolumeLabel, netDrive.TotalSize);
	} 
} 





















Answer: C 

Explanation: 

The GetDrives method is invoked and returns an array of DriveInfo objects representing the 
available drives. The DriveType property is used to verify that the netDrive variable is a network 
drive. The DriveType property returns a DriveType enumeration value that can be Network , Fixed 
, CDRom , or Removable . If the DriveType property is DriveType.Network , then the 
Console.WriteLine method displays the Name , VolumeLabel , and TotalSize properties of the 
DriveInfo object to the console. 

Incorrect Answers: 

A: You should not use the code that uses the Disk class because there is no such class in the 
System.IO namespace. 
B: You should not use the code fragments that do not retrieve the DriveType property of the 
DriveInfo object because there is no such signature for the GetDrives method and no such method 
as GetNetworkDrives. 
D: You should not use the code fragments that do not retrieve the DriveType property of the 
DriveInfo object because there is no such signature for the GetDrives method and no such method 
as GetNetworkDrives. 
FileSystemInfo class and FileSystemWatcher class 










QUESTION NO: 66 

You work as an application developer at CertKiller.com. 

CertKiller.com has asked you to create an application to display all of the top directories based on 
the drive path. You need to ensure that the application displays the number of files within top-level 
directories. 

What should you do? 

A. Use the following code: 
public void DisplayDriveDirectories (string drivePath) 
{ 
	if (Directory.Exists(drivePath)) 
	{ 
		foreach (String dirPath in Directory.GetDirectories(drivePath)) 
		{ 
			DirectoryInfo dir = new DirectoryInfo(drivePath); 
			int numFiles = dir.TotalFiles; 
			Console.WriteLine( "{0} : {1} files.", dir.Name, numFiles); 
		} 
	} 
} 


B. Use the following code: 
public void DisplayDriveDirectories (string drivePath) 
{ 
	if (Directory.Exists(drivePath)) 
	{ 
		foreach (String dirPath in Directory.GetDirectories(drivePath)) 
		{ 
			DirectoryInfo dir = new DirectoryInfo(drivePath); 
			int numFiles = dir.Length; 
			Console.WriteLine( "{0} : {1} files.", dir.Name, numFiles); 
		} 
	}
} 


C. Use the following code: 
public void DisplayDriveDirectories (string drivePath) 
{ 
	if (Directory.Exists(drivePath)) 
	{ 
		foreach (String dirPath in Directory.GetDirectories(drivePath)) 
		{ 
			DirectoryInfo dir = new DirectoryInfo (drivePath); 
			int numFiles = dir.GetFiles().Length; 
			Console.WriteLine( "{0} : {1} files.", dir.Name, numFiles); 
		} 
	}
} 


D. Use the following code: 
public void DisplayDriveDirectories (string drivePath) 
{ 
	if (Directory.Exists(drivePath)) 
	{ 
		foreach (String dirPath in Directory.GetDirctories (drivePath)) 
		{ 
			DirectoryInfo dir = new DirectoryInfo(drivePath); 
			int numFiles = dir.Size; 
			Console.WriteLine( "{0} : {1} files.", dir.Name, numFiles);
		} 
	} 
} 





















Answer: C 

Explanation: 

This code iterates through each top level of a given drive path and displays the Name property 
and number of files. First, the Exists method verifies that the drive path exists. Then, the 
GetDirectories method is invoked and returns a string array of directory paths. GetDirectories 
takes a directory path as an argument. Then a DirectoryInfo object is instantiated using the 
dirPath variable as it is updated with each iteration. The number of files in the directory is 
evaluated by using the GetFiles method, which returns an array of FileInfo objects and retrieves 
the Length Property of the array. The value is assigned to the numFiles variable. The 
DirectoryInfo object represents metadata about a directory instance. The Console.WriteLine 
method displays the Name property of the DirectoryInfo object and the numFiles variable. 

Incorrect Answers: 

A: The TotalFiles, Length, and Size properties do not exist in the DirectoryInfo class. 
B: The TotalFiles, Length, and Size properties do not exist in the DirectoryInfo class. 
D: The TotalFiles, Length, and Size properties do not exist in the DirectoryInfo class. 










QUESTION NO: 67 

You work as an application developer at CertKiller.com. CertKiller.com has asked you to create a 
file management application to monitor the hosts file. 

CertKiller.com has instructed you to change the hosts file if it has been changed. You, therefore, 
need to display the size and whether the hosts file is set to read-only. 

What should you do? 

A. Use the following code: 
FileInfo hosts = new FileInfo (@"C:\Windows\system32\drivers\etc\hosts"); 
Console.WriteLine ("ReadOnly?" + hosts.IsReadOnly); 
Console.WriteLine ("Size?" + hosts.Length); 
B. Use the following code: 
File hosts = new File (@"C:\Windows\system32\drivers\etc\hosts"); 
Console.WriteLine ("ReadOnly?" + hosts.IsReadOnly); 
Console.WriteLine ("Size?" + hosts.Length); 
C. Use the following code: 
File hosts = new File (@"C:\Windows\system32\drivers\etc\hosts"); 
Console.WriteLine ("ReadOnly?" + hosts.GetReadOnly); 
Console.WriteLine ("Size?" + hosts.GetLength); 
D. Use the following code: 
FileInfo hosts = new FileInfo (@"C:\Windows\system32\drivers\etc\hosts"); 
Console.WriteLine ("ReadOnly?" + hosts.IsReadOnly); 
Console.WriteLine ("Size?" + hosts.Size); 




















Answer: A 

Explanation: 

This code instantiates a FileInfo object using a file path string and outputs the IsReadOnly and 
Length properties to the command line. The FileInfo object represents the information about a 
system file. The FileInfo class contains common properties and methods for reading and setting 
file metadata and contents. The ISReadOnly property returns a Boolean value indicating whether 
the file is set to read-only. The Length property returns the size of the file in bytes. 

Incorrect Answers: 

B: You should not use the code that instantiate a File object because the File class does not 
contain an ISReadOnly or Length property and is a static class. Also, you should not use the code 
fragments that specify the Size property because no such property exists. 
C: You should not use the code that instantiate a File object because the File class does not 
contain an ISReadOnly or Length property and is a static class. Also, you should not use the code 
fragments that specify the Size property because no such property exists. 










QUESTION NO: 68 

You work as an application developer at CertKiller.com. You have recently completed the creation 
of a new application. 

CertKiller.com requires you to ensure that this new application creates a file that contains an array 
of bytes. 

What should you do? 

A. Use the following code: 
public void WriteBytes (byte [] bytes) 
{ 
	FileStream fs = new FileStream ("C:\\file.txt", FileMode.Create);

	for (int i = 0; i < bytes.Length - 1; i++)
		fs.Write(bytes [i]);

	fs.Close (); 
}
B. Use the following code: 
public void WriteBytes (byte [] bytes) 
{ 
	FileStream fs = new FileStream ("C:\\file.txt", FileMode.Create);

	for (int i = 0; i < bytes.Length - 1; i++)
		fs.WriteByte (bytes [i]);

	fs.Close (); 
} 

C. Use the following code: 
public void WriteBytes (byte [] bytes) 
{ 
	FileStream fs = new FileStream ("C:\\file.txt", FileMode.Create);

	fs.WriteBytes(bytes, 0, bytes.Length);

	fs.Close (); 
} 

D. Use the following code: 
public void WriteBytes (byte [] bytes) 
{ 
	FileStream fs = new FileStream ("C:\\file.txt", FileMode.Create);

	fs.Write(bytes, 0, bytes.Length);

	fs.Close (); 
} 





















Answer: D 

Explanation: 

The FileStream constructor accepts a string argument as the file path and a FileMode 
enumeration value. The FileMode enumeration value indicates the file stream will be used, and 
includes the values Append , Create , CreateNew , Open , and Truncate . The FileMode.Create 
value indicates a new file will be created or, if one already exists, that it will be overwritten. The 
FileStream class includes a Write method for writing an array of bytes. The Write method takes a 
byte array, offset value, and total number of bytes as arguments. The other method, WriteByte , 
takes a single argument of the type of byte, and it requires manual iteration to write an array. Like 
all streams, the FileStream object has a Close method, which should be called after work is done 
with the stream. 

Incorrect Answers: 

A: You should not use the code fragments that invokes the Write method or the WriteBytes 
method with only one argument because no such signatures exists in the FileStream class. 
B: This code is unnecessary because the FileStream class also contains a Write method that 
takes a byte array as an argument. 
C: You should not use the code fragments that invokes the Write method or the WriteBytes 
method with only one argument because no such signatures exists in the FileStream class. 










QUESTION NO: 69 

You work as an application developer at CertKiller.com. You are currently in the process of 
creating an application that reads binary information from a file. 

You need to ensure that the only the first kilobyte of data is retrieved. 

What should you do? 

A. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
BufferedStream bs = new BufferedStream (fs); 
byte [] bytes = new byte [1024]; 
bs.Read(bytes, 0, bytes.Length); 
bs.Close (); 
for (int i = 0; i < bytes.Length-1; i++) 
	Console.WriteLine("{0} : {1}", I, bytes [i]); 


B. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
byte [] bytes = new byte [1024]; 
fs.Read(bytes, 0, bytes.Length); 
fs.Close (); 
for (int i = 0; i < bytes.Length-1; i++) 
	Console.WriteLine("{0} : {1}", I, bytes [i]); 


C. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
BufferedStream bs = new BufferedStream (fs); 
byte [] bytes = new byte [1024]; 
bytes = bs.ReadAllBytes(0, 1023); 
bs.Close (); 
for (int i = 0; i < bytes.Length-1; i++) 
	Console.WriteLine("{0} : {1}", I, bytes [i]); 


D. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
BufferedStream bs = new BufferedStream(fs); 
byte [] bytes = new byte[1024]; 
bs.Read (bytes); 
bs.Close(); 
for (int i = 0; i < bytes.Length-1; i++) 
	Console.WriteLine("{0} : {1}", I, bytes [i]); 




















Answer: B 

Explanation: 

The FileStream constructor accepts a string argument as the file path and a FileMode 
enumeration value. The FileMode enumeration value indicates the file stream will be used, and 
includes the values Append , Create , CreateNew , Open , and Truncate . The FileMode.Open 
value indicates a file will be opened if existing, or else a FileNotFoundException object will be 
thrown. An array of 1024 bytes is instantiated. The Read method takes the byte array, offset 
value, and total number of bytes as arguments. The other method ReadByte returns a single byte 
at a time, but it requires manual iteration to write an array. Like all streams, the FileStream object 
has a Close method, which should be called after work is done with the stream. The 
Console.WriteLine method is invoked to display the byte index and byte value. 

Incorrect Answers: 

A: You should not use the code that specifies a buffered stream because the FileStream class is 
already a buffered stream. Also, you should not use the code fragments that invoke the 
ReadAllBytes method and the Read method with the incorrect arguments because no such 
method signatures exist. 
StringReader class and StringWriter class 
C: You should not use the code that specifies a buffered stream because the FileStream class is 
already a buffered stream. Also, you should not use the code fragments that invoke the 
ReadAllBytes method and the Read method with the incorrect arguments because no such 
method signatures exist. 
MemoryStream class 
StreamReader class and StreamWriter class 
D: You should not use the code that specifies a buffered stream because the FileStream class is 
already a buffered stream. Also, you should not use the code fragments that invoke the 
ReadAllBytes method and the Read method with the incorrect arguments because no such 
method signatures exist. 
BufferedStream class
Part 6: Manage the .NET Framework application data by using Reader and 
Writer classes. (Refer System.IO namespace) 










QUESTION NO: 70 

You work as an application developer at CertKiller.com. You are in the process of creating a new 
application. 

This new application has to be able to read all data from a text file. 

What should you do? 

A. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
StreamReader sr = new StreamReader(fs); 
string data = new sr.ReadToEnd(); 
sr.Close();
Console.WriteLine(data); 


B. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
string data = new sr.ReadToEnd (); 
fs.Close (); 
Console.WriteLine (data);

C. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
StringBuilder data = new StringBuilder(); 
string data; 
while(sr.Peek() > -1) 
	data += sr.ReadLine (); 
sr.Close(); 
Console.WriteLine (data); 


D. Use the following code: 
FileStream fs = new FileStream("C:\\file.txt", FileMode.Open); 
StreamReader sr = new StreamReader (fs); 
StringBuilder data = new StringBuilder (); 
while (sr.Peek () > -1) 
	data.Append(sr.ReadLine()); 
sr.Close (); 
Console.WriteLine(data.ToString()); 






















Answer: A 

Explanation: 

The FileStream constructor accepts a string argument as the file path and a FileMode 
enumeration value. The FileMode enumeration value indicates the file stream will be used, and 
includes the values Append , Create , CreateNew , Open , and Truncate . The FileMode.Open 
value indicates a file will be opened if existing, or else a FileNotFoundException object will be 
thrown. A StreamReader object is instantiated using the FileStream object as input. The 
ReadToEnd method returns a string representing all data from that position to the end of the file. 
There are two other read methods, ReadLine and ReadBlock. The ReadLine method returns a 
string representing all data from that position to the end of a line return. The ReadBlock method 
takes a character array, offset value and total number of characters as arguments. Like all 
streams, the StreamReader object has a Close method, which should be called after work is done 
with the stream. The Console.WriteLine method is invoked to display the data to the console. 

Incorrect Answers: 

B: You should not use the code that does not specify the StreamReader class because the 
FileStream class does not contain a ReadToEnd method. 
C: You should not use the code that specifies a string object when invoking the ReadLine method 
rather than a StringBuilder object. The string object is less efficient than StringBuilder objects 
when performing concatenation operations. 
D: This code should not be used because it manually iterates through the file using the ReadLine 
method, whereas the ReadToEnd method is more efficient. 

Part 7: Compress or decompress stream information in 
a .NET Framework application (refer System.IO.Compression namespace), and improve the 
security of application data by using isolated storage. (Refer System.IO.IsolatedStorage 
namespace) 










QUESTION NO: 71 

You work as an application developer at CertKiller.com. You are currently in the process of 
creating a new application for CertKiller.com. 

You are required to read compressed data files that has been sent by CertKiller.com's sales 
offices. These data files are less than 4 GB in size, but was compressed without cyclic 
redundancy. 

You want to write a method that receives the compressed files and return the uncompressed data 
as a byte array. 

What should you do? 

A. Use the following code: 
public byte[] DecompressFile(string file) 
{ 
	FileStream fs = new FileStream(file, FileMode.Open); 
	DeflateStream cs = new DeflateStream(fs, CompressionMode.Decompress, true); 
	byte[] data = new byte[fs.Length - 1]; 
	cs.Read(data, 0, data.Length); 
	cs.Close(); 
	return data; 
} 


B. Use the following code: 
public byte[] DecompressFile(string file)
{ 
	FileStream fs = new FileStream(file, FileMode.Open); 
	GZipStream cs = new GZipStream(fs, CompressionMode.Decompress) 
	byte[] data = new byte[fs.Length - 1]; 
	cs.Read (data, 0, data.Length); 
	return data; 
} 

C. Use the following code: 
public byte[] DecompressFile(string file) 
{ 
	FileStream fs = new FileStream(file, FileMode.Open); 
	DeflateStream cs = new DeflateStream(fs, CompressionMode.Decompress) 
	byte[] data = new byte[fs.Length - 1]; 
	cs.Read(data, 0, data.Length); 
	return data; 
} 


D. Use the following code: 
public byte[] DecompressFil (string file) 
{ 
	FileStream fs = new FileStream(file, FileMode.Open); 
	GZipStream cs = new GZipStream(fs, CompressionMode.Decompress, true); 
	byte [ ] data = new byte[fs.Length - 1]; 
	cs.Read(data, 0, data.Length); 
	cs.Close(); 
	return data; 
} 





















Answer: A 

Explanation: 

The DeflateStream uses the LZ77 and Huffman coding algorithms for lossless compression and 
decompression without cyclic redundancy. The DeflateStream constructor takes a stream (in this 
case an input stream), a CompressionMode enumeration value, and a Boolean value indicating 
whether to keep the stream open. The CompressionMode enumeration value indicates whether to 
compress or decompress the specified stream using the values Compress and Decompress , 
respectively. The Read method takes the byte array, offset value, and total number of bytes as 
arguments. In this code, the compressed data is read from the FileStream object associated with 
the DeflateStream object, and it is stored in the byte array. Like all streams, the DeflateStream 
object has a Close method, which should be called after work is done with the stream. Finally, the 
resulting byte array is returned. 

Incorrect Answers: 

B: You should not use the code fragments that specify the GZipStream class because this data 
format includes a data corruption check during decompression. 
C: You should not use the code fragments that instantiates the Stream objects and invoke the 
Read method with the wrong arguments. 
D: You should not use the code fragments that specify the GZipStream class because this data 
format includes a data corruption check during decompression. 
GZipStream class 











QUESTION NO: 72 

You work as an application developer at CertKiller.com. CertKiller.com has a file server named 
CERTKILLER-SR07 that stores old inventory files. 

CertKiller.com has given you the task of creating an application to archive these old inventory files. 
The inventory files have to be compressed prior to being uploaded to CertKiller.com's Web server. 

You are currently writing a method that will receive a byte array and compress it into a new file. 
You need to ensure that a data corruption check takes place during the decompression process. 

What should you do? 

A. Use the following code: 
public void CompressFileWrite (string file, byte[] data) 
{ 
	FileStream fs = new FileStream (file, FileMode.Create); 
	DeflateStream cs = new DeflateStream( fs, Compressionmode.Compress, true); 
	cs.Write (data, 0, data.Length); 
	cs.Close (); 
} 


B. Use the following code: 
public void CompressFileWrite (string file, byte[] data) 
{ 
	FileStream fs = new FileStream (file, FileMode.Create); 
	GZipStream cs = new GZipStream( fs, Compressionmode.Compress, true); 
	cs.Compress (data, 0, data.Length); 
	cs.Close (); 
} 


C. Use the following code: 
public void CompressFileWrite (string file, byte[] data) 
{ 
	FileStream fs = new FileStream (file, FileMode.Create); 
	DeflateStream cs = new DeflateStream( fs, Compressionmode.Compress, true); 
	cs.Compress (data, 0, data.Length); 
	cs.Close (); 
} 


D. Use the following code: 
public void CompressFileWrite (string file, byte[] data) 
{ 
	FileStream fs = new FileStream (file, FileMode.Create);
	GZipStream cs = new GZipStream( fs, Compressionmode.Compress, true);
	cs.Write (data, 0, data.Length);
	cs.Close (); 
} 





















Answer: D 
Incorrect Answers: 

A: You should not use the code fragments that specify the DeflateStream class because this data 
format does not ensure that a data corruption check occurs during decompression. You should 
also not use the code that invokes the Compress method because no such method exists in the 
GZipStream or the DeflateStream classes. 
B: You should not use the code fragments that specify the DeflateStream class because this data 
format does not ensure that a data corruption check occurs during decompression. You should 
also not use the code that invokes the Compress method because no such method exists in the 
GZipStream or the DeflateStream classes. 
C: You should not use the code fragments that specify the DeflateStream class because this data 
format does not ensure that a data corruption check occurs during decompression. You should 
also not use the code that invokes the Compress method because no such method exists in the 
GZipStream or the DeflateStream classes. 










QUESTION NO: 73 

You work as an application developer at CertKiller.com. You are in the process of creating an 
assembly that will be used to manage file content on CertKiller.com's user computers. 

CertKiller.com wants you to ensure that the users who use the assembly you are creating should 
not be able to access classes in your assembly if they do not have access to the local file system. 

To do this, you need to add certain code fragments to your classes. 

What should you use? (Choose two) 

A. [FileIOPermission (SecurityAction.RequestMinimum) ] 
B. FileIOPermission perm = New FileIOPermission (PermissionState.Unrestricted); 
Perm.Assert 
C. [FileIOPermission (SecurityAction.RequestOptional) ] 
D. FileIOPermission perm = New FileIOPermission (PermissionState.Unrestricted); 
Perm.Request 
E. [FileIOPermission (SecurityAction.Demand) ] 
F. FileIOPermission perm = New FileIOPermission (PermissionState.Unrestricted); 
Perm.Demand 




















Answer: E,F 

Explanation: 

The .NET Framework security system allows permission requests, overrides, and demands using 
declarative security and imperative security. Declarative security makes use of attributes to place 
security data into the metadata of the assembly. The permission attributes take a SecurityAction 
enumeration and other optional arguments. The SecurityAction enumeration includes the values 
Assert, Demand, Deny, RequestMinimum , RequestOptional , and RequestRefuse . The 
SecurityAction.Demand value indicates that all callers must have the permission to access the 
resource. 

Incorrect Answers: 

A: You should not use the code fragments that specify the SecurityAction.RequestMinimum and 
SecurityAction.RequestOptional values because attributes with these values can only be applied 
to the entire assembly. 
B: You should not use the code fragment that invokes the Assert method because all users must 
have permission to access the file system. 
C: You should not use the code fragments that specify the SecurityAction.RequestMinimum and 
SecurityAction.RequestOptional values because attributes with these values can only be applied 
to the entire assembly. 
Modify the Code Access security policy at the computer, user, and enterprise policy level by using 
the Code Access Security Policy tool (Caspol.exe). 
D: You should not use the code fragment that invokes the Request method because no such 
method exists in the CodeAccesPermission or FileIOPermission class. 










QUESTION NO: 74 

You work as an application developer at CertKiller.com. A fellow developer named Amy Walsh 
recently created an assembly that implements a custom permission set. 

CertKiller.comhas asked you to test this assembly. You start by copying the assembly to a test 
server named CERTKILLER-SR15 that has the Microsoft .NET 2.0 Framework installed. You then 
log on to the CERTKILLER-SR15 as a member of the local Administrators Windows group. 

You run the assembly, and receive a security exception. You perform a brief analysis of the 
security issues involved, and find that the assembly has not been assigned the appropriate 
permissions to run. 

You need to ensure that this assembly runs. 

What should you do?
A. Use the permview.exe tool to modify the assembly's granted permissions. 
B. Use the sn.exe tool to modify the assembly's granted permissions. 
C. Use the caspol.exe tool to modify the assembly's granted permissions. 
D. Use the gacutil.exe tool to modify the assembly's granted permissions. 




















Answer: C 

Explanation: 

The caspol.exe command-line tool allows users to modify security permissions, permission sets, 
and code groups for an assembly at the machine, user, and enterprise policy levels. 

Incorrect Answers: 

A: The permview.exe tool only allows users to view declarative security of an assembly. 
B: The sn.exe tool allows developers to create a strong-named asymmetric key pair for strong-
named assemblies. 
D: The gacutil.exe tool allows users to manage the contents of the global assembly and download 
cache. 










QUESTION NO: 75 

You work as an application developer at CertKiller.com. CertKiller.com has a test server named 
CERTKILLER-SR09 that is frequently used by other CertKiller.com developers to test assemblies 
and applied security policies. 

You have just completed creating an assembly and want to test it on CERTKILLER-SR09.you 
need to ensure that all security policies on CERTKILLER-SR09 are reset to their default settings. 

What should you do? 

A. Execute the caspol all -rollback command. 
B. Execute the caspol all -reset command. 
C. Execute the machine all -rollback command. 
D. Execute the machine all -reset command. 




















Answer: B 

Explanation: 

The caspol.exe command-line tool allows users to modify security permissions, permission sets, 
and code groups for an assembly at the machine, user, and enterprise policy levels. The reset 
switch will set the specified security policy or policies back to their default state. The all switch 
refers to machine, user, and enterprise policy levels. 

Incorrect Answers: 

A: The rollback switch does not exist for the caspol.exe tool. 
DirectorySecurity class, FileSecurity class, FileSystemSecurity class, and RegistrySecurity class 
C: The rollback switch does not exist for the caspol.exe tool. 
D: This option will not set all security policies back to their default state. 
PermissionSet class and NamedPermissionSet class 










QUESTION NO: 76 

You work as an application developer at CertKiller.com. CertKiller.com has asked you to create an 
application that copies file content from one file on a client computer named CERTKILLER-WS007 
to a new file on a server named CERTKILLER-SR15. 

The method displayed in the following exhibit is included in the new application: 

You have to ensure that the application copies all permissions on the original file to the new file. 


You should also make sure that the new file does not inherit its permissions from the destination 
directory on CERTKILLER-SR15. 

What should you do? 

A. Add the following code to the Copy method: 
file2.SetAccessControl (file1.GetAccessControl ()); 

B. Add the following code to the Copy method: 
FileSecurity acl = file1.GetAccessControl (); 
acl. SetAccessRuleProtection (true, true); 
file2.SetAccessControl (acl); 

C. Add the following code to the Copy method: 
file2.SetAccessControl (file1.GetAccessControl (), false); 

D. Add the following code to the Copy method: 
FileSecurity acl = file1.GetAccessControl (); 
acl. SetAccessRuleProtection (true, false); 
file2.SetAccessControl (acl); 




















Answer: B 

Explanation: 

This code retrieves the FileSecurity object from the original file, copies and protects the ACL 
settings from directory inheritance, and copies the ACL settings to the destination file. The 
GetAccessControl method returns a FileSecurity object representing the ACL of the original file. 
The SetAccessRuleProtection method sets or removes ACL protection from the parent objects 
through inheritance. The SetAccessRuleProtection method accepts two Boolean arguments, the 
first of which indicates whether settings are protected from inheritance, and the second of which 
indicates whether to preserve the existing inherited access rule. In this scenario, the value true for 
both arguments indicates that the ACL is protected from inheritance, but the current ACL settings 
are copied. The SetAccessControl method takes a FileSecurity object and applies the ACL to the 
destination folder. 

Incorrect Answers: 

A: You should not use the code fragments that do not invoke the SetAccessRuleProtection 
method because this will not protect the destination file's ACL settings from inheritance. 
C: You should not use the code fragments that do not invoke the SetAccessRuleProtection 
method because this will not protect the destination file's ACL settings from inheritance. 
AuthorizationRule class and AuthorizationRuleCollection class 
D: This code will protect the ACL from inheritance, but it does not copy the existing inherited ACL 
settings. 
CommonAce class, CommonAcl class, CompoundAce class, GeneralAce class, and GeneralAcl 
class 










QUESTION NO: 77 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted by a 
local doctor's clinic to develop a client application using Microsoft .NET 2.0 that sends patient visit 
information to a remote server at the clinic's main office. 

This data must be transmitted via a secure network stream because it contains patient protected 
health information (PHI). The data will be sent from a windows application client on the doctor's 
notebook computer to a windows service hosted on a remote server. Both of these applications 
employ a certificate store for network identification. 

You need to create a secure data stream by adding certain classes to the client application. 

What classes should you add? (Choose three) 

A. The MD5CryptoServiceProvider class. 
B. The X509Certificate class. 
C. The NetworkStream class. 
D. The SslStream class. 
E. The TcpListener class. 
F. The TcpClient class. 




















Answer: B,D,F 

Explanation: 

You should use the X509Certificate class to store the server certificate and encrypt data, the 
SslStream class to create a secure channel, and the TcpClient class to establish the connection 
with the server application. 

Incorrect Answers: 

A: Using this option would only hash the data using the MD5 algorithm. 
DES class and DESCryptoServiceProvider class 
C: Using this option would not necessarily create a secure channel. 
E: This class is used by the server application.

Part 4: Encrypt, decrypt, and hash data by using the System.Security.Cryptography classes. (Refer System.Security.Cryptography namespace) 










QUESTION NO: 78 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted by the 
local hospital to create an application that forwards private patient information to various insurance 
providers. 

The hospital informs you that the amount and frequency of the patient data is high. You need to 
ensure that data confidentiality is guaranteed, with as little overhead as possible. 

You now need to encrypt the patient information. 

What should you do? 

A. Use the following code: 
public byte [] EncryptData (byte [] PatientInfo, RSACryptoServiceProvider SecreCKey) 
{ 
	CryptoStream cs = new CryptoStream(SecreCKey);

	cs.Encrypt(PatientInfo, 0, PatientInfo.Length);

	byte[] data = cs.ToArray();

	cs.Close();

	return data; 
} 


B. Use the following code: 
public byte [] EncryptData (byte [] PatientInfo, RSACryptoServiceProvider SecreCKey) 
{
	MemoryStream ms = new MemoryStream ();

	CryptoStream cs = new CryptoStream(ms, SecreCKey.CreateEncryptor(), CryptoStreamMode.Write);

	cs.Write(PatientInfo, 0, PatientInfo.Length);
	
	cs.Close();

	byte[] data = ms.ToArray ();

	ms.Close();

	return data; 
} 

C. Use the following code: 
public byte [] EncryptData (byte [] PatientInfo, DESCryptoServiceProvider SecreCKey) 
{ 
	CryptoStream cs = new CryptoStream(SecreCKey);

	cs.Encrypt(PatientInfo, 0, PatientInfo.Length);

	byte[] data = cs.ToArray ();

	cs.Close ();

	return data; 
} 


D. Use the following code: 
public byte [] EncryptData (byte [] PatientInfo, DESCryptoServiceProvider SecreCKey) 
{ 
	MemoryStream ms = new MemoryStream ();

	CryptoStream cs = new CryptoStream(ms, SecreCKey.CreateEncryptor(), CryptoStreamMode.Write);

	cs.Write(PatientInfo, 0, PatientInfo.Length);

	cs.Close();

	byte[] data = ms.ToArray();

	ms.Close();

	return data; 
} 





















Answer: D 

Explanation: 

This code instantiates a CryptoStream object, specifies the ICryptoTransform object to encrypt 
data, encrypts the PatientInfo byte array, and returns the encrypted byte array. The 
DESCryptoServiceProvider class represents a managed cryptographic provider of the 
DataEncryption Standard (DES) symmetric algorithm. The DES symmetric algorithm is commonly 
used for dat confidentiality, and it supports 64-bit keys. When you instantiate a 
DESCryptoServiceProvider object, a secret key for encryption and an initialization vector (IV) are 
created. Because the same key and IV are needed for encryption and decryption, the 
CreateEncryptor and CreateDecryptor methods generate the appropriate ICryptoTransform object to alter the data. 

Incorrect Answers: 

A: You should not use the code fragments that specify the RSACryptoServiceProvider because 
this implements an asymmetric algorithm. 
B: You should not use the code fragments that specify the RSACryptoServiceProvider because 
this implements an asymmetric algorithm. 
HashAlgorithm class 
C: You should not use the code fragments that invoke the Encrypt method because no such 
method exists in the CryptoSream class. 










QUESTION NO: 79 

You work as an application developer at CertKiller.com. CertKiller.com stores data in a byte array 
named dataArray. 

You have been given the task of ensuring that this data is protected against corruption and 
tampering. You are planning to employ a HashAlgorithm object to achieve this objective. 

What should you do? 

A. Use the following code to generate a hash value for the dataArray object: 
hash.GenerateHash (dataArray); 
B. Use the following code to generate a hash value for the dataArray object: 
hash.ComputeHash(dataArray); 
C. Use the following code to generate a hash value for the dataArray object: 
hash.Hash(dataArray); 
D. Use the following code to generate a hash value for the dataArray object: 
hash.Compute(dataArray); 




















Answer: B 

Explanation: 

This option will return a byte array representing the hash value. The HashAlgorithm abstract class 
is the base class for all hash algorithm provider classes, including the MD5CryptoServiceProvider 
and SHA1CryptoServiceProvider classes. They all inherit the ComputeHash method from the 
HashAlgorithm class. 

Incorrect Answers: 

A: These options are incorrect because these methods do not exist in the HashAlgorithm class. 
C: These options are incorrect because these methods do not exist in the HashAlgorithm class. 
DSA class and DSACryptoServiceProvider class 
D: These options are incorrect because these methods do not exist in the HashAlgorithm class. 










QUESTION NO: 80 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted by the 
local hospital to create an application that forwards private patient information to various insurance 
providers. 

The patient information is sent via a secured VPN to ensure confidentiality. You also need to 
guarantee data integrity, and verify that the patient data originated from the local hospital. To 
achieve this objective, you elect to utilize asymmetric encryption and a digital signature 
technology. 

What code would you use to complete your task? 

A. public byte[] SignAndHash(byte[] PatientInfo, RSAParameters RSAInfo) 
{ 
	RSACryptoServiceProvider RSAProvider = new RSACryptoServiceProvider(); 
	RSAProvider.ImportParameters(RSAInfo); 
	return RSAProvider.Encrypt(PatientInfo, true); 
} 

B. public byte[] SignAndHash(byte[] PatientInfo, DSAParameters DSAInfo) 
{ 
	DSACryptoServiceProvider DSAProvider = new DSACryptoServiceProvider(); 
	DSAProvider.ImportParameters(DSAInfo); 
	return DSAProvider.SignHash(PatientInfo); 
} 

C. public byte[] SignAndHash(byte[] PatientInfo, RSAParameters RSAInfo) 
{ 
	RSACryptoServiceProvider RSAProvider = new RSACryptoServiceProvider(); 
	RSAProvider.ImportParameters(RSAInfo); 
	return RSAProvider.SignEncrypt(PatientInfo, true); 
} 

D. public byte[] SignAndHash(byte[] PatientInfo, DSAParameters DSAInfo) 
{ 
	DSACryptoServiceProvider DSAProvider = new DSACryptoServiceProvider(); 
	DSAProvider.ImportParameters(DSAInfo); 
	return DSAProvider.SignData(PatientInfo); 
} 





















Answer: D Explanation: 

The DSACryptoServiceProvider class represents a managed cryptographic provider of the Digital 
Signature Algorithm (DSA) asymmetric algorithm. The DSA asymmetric algorithm is commonly 
used for digital signatures and data integrity, supporting 1024 bit keys. When instantiating a 
DSACryptoServiceProvider object, a public/private key pair is generated and a default hash is 
assigned. Thus, to use a particular private key to sign data, a public key to verify data, or a 
particular hash, you must invoke the ImportParameters method for the current 
DSACryptoServiceProvider to load custom settings. The SignData method takes a byte array 
representing the original data and returns the hashed and then signed byte array. 

Incorrect Answers: 

A: You should not use the code fragments that specify the RSACryptoServiceProvider object 
because the method invocations are incorrect. 
B: The SignHash method is used to sign a message digest, not the original data. 
C: You should not use the code fragments that specify the RSACryptoServiceProvider object 
because the method invocations are incorrect. 










QUESTION NO: 81 

You work as an application developer at CertKiller.com. A fellow developer named Andy Booth 
has recently created an application. 

The application receives confidential transaction data from CertKiller.com's clients, which it 
secures using the TripleDESCryptoServiceProvider class. You are currently reviewing this 
application, and need to decrypt a byte array of cipher text. 

What code should you use to achieve this objective? 

A.
public byte[] DecryptData(byte[] cipherText, TripleDESCryptoServiceProvider secreCKey) 
{
	MemoryStream ms = new MemoryStream(cipherText);

	CryptoStream cs = new CryptoStream(ms, SecreCKey, CryptoStreamMode.Read);

	byte[] data = new byte[ms.Length - 1];

	cs.Read(data, 0, data.Length);

	cs.Close();

	ms.Close();

	return data; 
} 
B. public byte[] DecryptData(byte[] cipherText, TripleDESCryptoServiceProvider secreCKey) 
{
	MemoryStream ms = new MemoryStream(cipherText);

	CryptoStream cs = new CryptoStream(ms, secreCKey.CreateDecryptor(), CryptoStreamMode.Read);
	
	byte[] data = new byte[ms.Length - 1];

	cs.Read(data, 0, data.Length);

	cs.Close();

	ms.Close();

	return data; 
} 

C.
public byte[] DecryptData(byte[] cipherText, TripleDESCryptoServiceProvider secreCKey) 
{
	MemoryStream ms = new MemoryStream(secret.Key);

	CryptoStream cs = new CryptoStream(ms, secreCKey.CreateDecryptor(), CryptoStreamMode.Read);

	byte[] data = ms.Decrypt(cipherText);

	cs.Read(data, 0, data.Length);

	ms.Close();

	return data; 
} 

D.
public byte[] DecryptData(byte[] cipherText, TripleDESCryptoServiceProvider secreCKey) 
{
	CryptoStream cs = new CryptoStream(secreCKey);

	byte[] data = ms.Decrypt(cipherText);

	cs.Read(data, 0, data.Length);

	ms.Close();

	return data; 
} 





















Answer: B 

Explanation: 

This code instantiates a CryptoStream object, specifies the ICryptoTransform object to encrypt 
data, decrypts the CipherText byte array, and returns the encrypted byte array. The 
TripleDESCryptoServiceProvider class represents a managed cryptographic provider of the Data 
Encryption Standard (DES) symmetric algorithm. The DES symmetric algorithm is commonly 
used for dat confidentiality, and it supports 64-bit keys. When you instantiate a 
TripleDESCryptoServiceProvider object, a secret key for encryption and an initialization vector (IV) 
are created. Because the same key and IV are needed for encryption and decryption, the 
CreateEncryptor and CreateDecryptor methods generate the appropriate ICryptoTransform object 
to alter the data. 

Incorrect Answers: 

A: You should not use the code that does not invoke the CreatDecryptor method because this is 
required when instantiating a CryptoStream object. 
C: You should not use the code fragments that invoke the Decrypt method because no such 
method exists in the CryptoStream class. 
D: You should not use the code fragments that invoke the Decrypt method because no such 
method exists in the CryptoStream class. 










QUESTION NO: 82 

You work as an application developer at CertKiller.com. CertKiller.com has given you the task of 
creating an application that will allow CertKiller.com's customers to order products online. 

To guarantee the availability funds, the application will forward billing information to a third-party 
payment verification system to guarantee the availability funds. 

You need to ensure that the data has not been tampered with between the application and the 
third-party payment verification system. To do this, you have to hash the billing information. 

What code should you use to achieve this? 

A. Use the following code: 
public byte[] Hash(byte[] BillingData) 
{ 
	DESCryptoServiceProvider hashProvider = new DESCryptoServiceProvider(); 
	return hashProvider.Hash(BillingData); 
} 

B. Use the following code: 
public byte[] Hash(byte[] BillingData) 
{ 
	MD5CryptoServiceProvider hashProvider = new MD5CryptoServiceProvider(); 
	return hashProvider.Hash(BillingData); 
} 

C. Use the following code: 
public byte[] Hash(byte[] BillingData) 
{ 
	MD5CryptoServiceProvider hashProvider = new MD5CryptoServiceProvider(); 
	return hashProvider.ComputeHash(BillingData); 
} 

D. Use the following code: 
public byte[] Hash(byte[] BillingData) 
{ 
	DESCryptoServiceProvider hashProvider = new DESCryptoServiceProvider(); 
	return hashProvider.ComputeHash(BillingData); 
} 





















Answer: C Explanation: 

This code instantiates an MD5CryptoServiceProvider object, invokes the ComputeHash method, 
and returns the hashed byte array. The MD5CryptoServiceProvider class represents a managed 
cryptographic provider of the of the MD5 hash algorithm. The MD5 hash algorithm is commonly 
used for data integrity, and it supports a 128-bit hash size. The MD5 hash algorithm is known as a 
message detection code (MDC) hash function. The ComputeHash method accepts a byte array 
and returns a hashed byte array for data integrity. 

Incorrect Answers: 

A: The DESCryptoServiceProvider class is used for data confidentiality, not integrity. 
SecurityPermission class 
B: The Hash method does not exist in the MD5CryptoServiceProvider class. 
PrincipalPermission class 
D: The DESCryptoServiceProvider class is used for data confidentiality, not integrity. 










QUESTION NO: 83 

You work as an application developer at CertKiller.com. CertKiller.com has a file server named 
CERTKILLER-SR07 that hosts company data. 


You are currently in the process of creating an application that will be used by CertKiller.com users 
to manage the data on CERTKILLER-SR07. to ensure that CertKiller.com users have the 
appropriate file permissions on the working directory, you define the DemandDirectorySecurity 
method as shown below. 


public void DemandDirectorySecurity (string path)
{
	FileIOPermission filePerm = new FileIOPermission(PermissionState.None);
	filePerm.AddPathList(FileIOPermissionAccess.AllAccess, path);
	filePerm.Assert();
}

Subsequent to installing the new application, you find that some users do not have full access to 
their working directories. You are informed that these CertKiller.com users only require read only 
access. 

You are required to override the permission assertion in the DemandDirectorySecurity method for these users only. 

What should you do? 


A. Use the following code: 
FileIOPermission.Revert (); 
FileIOPermission fileOVPerm = new FileIOPermission (PermissionState.None); 
fileOVPerm.AddPathList (FileIOPermissionAccess.Read, path); 
fileOVPerm.Assert (); 

B. Use the following code: 
FileIOPermission fileOVPerm = new FileIOPermission (PermissionState.None); 
fileOVPerm.AddPathList (FileIOPermissionAccess.Read, path); 
fileOVPerm.Permit (); 

C. Use the following code: 
FileIOPermission.Revoke (); 
FileIOPermission fileOVPerm = new FileIOPermission (PermissionState.None); 
fileOVPerm.AddPathList (FileIOPermissionAccess.Read, path); 
fileOVPerm.Assert (); 

D. Use the following code: 
FileIOPermission fileOVPerm = new FileIOPermission (PermissionState.None); 
fileOVPerm.AddPathList (FileIOPermissionAccess.Read, path); 
fileOVPerm.OverrideAll (); 




















Answer: A 

Explanation: 

This code invokes the RevertAssert method on the FileIOPermission class, instantiates a 
FileIOPermission object representing read-only access to the working directory, and invokes the 
assert method on the FileIOPermission object. 

Incorrect Answers: 

B: The Permit, OverrideAll, and Revoke methods do not exist in the FileIOPermission class. 
C: The Permit, OverrideAll, and Revoke methods do not exist in the FileIOPermission class. 
D: The Permit, OverrideAll, and Revoke methods do not exist in the FileIOPermission class. 
StrongNameIdentityPermission class 










QUESTION NO: 84 

You work as an application developer at CertKiller.com. You are currently creating a manifest-
activated application on the CertKiller.com's intranet using ClickOnce deployment. 

The network administrator informs you that each application has to identify its name, version, 
culture, and requested permissions. You need to ensure that the application you are creating uses 
the command line to display the required information. 

What should you do? 

A. Use the following code: 
ApplicationSecurityInfo appInfo = new ApplicationSecurityInfo(appDomain.CurrentDomain); 
Console.Writeline(appInfo.ApplicationID.Name); 
Console.Writeline(appInfo.ApplicationID.Version); 
Console.Writeline(appInfo.ApplicationID.Culture); 
Console.Writeline(appInfo.DefaultRequestSet.ToXml()); 

B. Use the following code: 
ApplicationSecurityInfo appInfo = ActivationContext.GetCurrentContext(); 
Console.Writeline(appInfo.ApplicationID.Name); 
Console.Writeline(appInfo.ApplicationID.Version); 
Console.Writeline(appInfo.ApplicationID.Culture); 
Console.Writeline(appInfo.DefaultRequestSet.ToXml()); 

C. Use the following code: 
ApplicationSecurityInfo appInfo = new ApplicationSecurityInfo(AppDomain.CurrentDomain.ActivationContext); 
Console.Writeline(appInfo.ApplicationID.Name); 
Console.Writeline(appInfo.ApplicationID.Version); 
Console.Writeline(appInfo.ApplicationID.Culture); 
Console.Writeline(appInfo.DefaultRequestSet.ToXml()); 

D. Use the following code: 
ApplicationSecurityInfo appInfo = ActivationID.GetCurrentApplication(); 
Console.Writeline(appInfo.ApplicationID.Name); 
Console.Writeline(appInfo.ApplicationID.Version); 
Console.Writeline(appInfo.ApplicationID.Culture); 
Console.Writeline(appInfo.DefaultRequestSet.ToXml()); 




















Answer: C 

Explanation: 

The ApplicationSecurityInfo class represents the security evidence for a manifest-activated 
application. The constructor requires an ActivationContext object that represents the manifest 
activation context of the application. The AppDomain.CurrentDomain.ActivationContext property 
retrieves the activation context of the current manifest-activated application. The 
DefaultRequestSet property represents the permission set the application is requesting of the local 
system. 

Incorrect Answers: 

A: You should not use the code fragments because they attempt the retrieve the 
ApplicationSecurityInfo object through non-existent methods. 
B: You should not use the code fragments because they attempt the retrieve the 
ApplicationSecurityInfo object through non-existent methods. 
ApplicationTrust class and ApplicationTrustCollection class 
D: You should not use the code fragments because they attempt the retrieve the 
ApplicationSecurityInfo object through non-existent methods. 
CodeGroup class, FileCodeGroup class, FirstMatchCodeGroup class, NetCodeGroup class, and 
UnionCodeGroup class 










QUESTION NO: 85 

You work as an application developer at CertKiller.com. You are in the process of creating an 
application that will be used to forward confidential information to CertKiller.com's business 
partners. 

In a bid to improve the security of your production environment, you install digital certificates for 
publishing all assemblies in the application. 

You need to confirm that every assembly belongs to the same publisher, based on that publisher's 
digital certificate. 

You are asked to confirm that the current assembly belongs to a certain publisher. 

What should you do? 

A. Use the following code: 
public bool CheckPolicy (X509Certificate cert) 
{ 
PublisherMembershipCondition policy = new PublisherMembershipCondition (cert); 
return policy.Check (Assembly.GetCallAssembly ().Evidence); 
} 

B. Use the following code: 
public bool CheckPolicy (X509Certificate cert) 
{ 
Publisher pub = new Publisher (cert); 
return pub.Verify (AppDomain.CurrentDomain.Evidence); 
} 

C. Use the following code: 
public bool CheckPolicy (X509Certificate cert) 
{ 
Publisher pub = new Publisher (cert); 
return pub.Check (AppDomain.CurrentDomain.Evidence); 
} 

D. Use the following code: 
public bool CheckPolicy (X509Certificate cert) 
{ 
PublisherMembershipCondition policy = new PublisherMembershipCondition (cert); 
return policy.Verify (Assembly.GetCallAssembly ().Evidence); 
} 



















Answer: A 
Incorrect Answers: 

B: You should not use the code fragments that specify the AppDomain.CurrentDomain.Evidence 
property as an argument because this property retrieves only the evidence available to the current 
application domain. 
C: You should not use the code fragments that specify the AppDomain.CurrentDomain.Evidence 
property as an argument because this property retrieves only the evidence available to the current 
application domain. 
D: You should not use this code fragment that specifies the Verify method because this method 
does not exist in the PublisherMembershipCondition class 










QUESTION NO: 86 

You work as an application developer at CertKiller.com. You are in the process of creating an 
application on CertKiller.com's Web sever named CERTKILLER-SR11. 

This application will be used to manage confidential data from CertKiller.com's business partners. 
The application relies on several assemblies located in CertKiller.com's intranet to fulfill its duties. 

As a result, you have to verify that every assembly originates from the same intranet Web site. 

How would you accomplish this? 

A. Use the following code: 
public bool CheckSite () 
{ 
SiteMembershipCondition site = new SiteMembershipCondition (http//intranet.CertKiller.com); 
return site.Check (AppDomain.CurrentDomain.Evidence); 
} 

B. Use the following code: 
public bool CheckSite () 
{ 
Site site = new Site (http//intranet.CertKiller.com); 
return site.Check (Assembly.GetCallingAssembly ().Evidence); 
} 

C. Use the following code: 
public bool CheckSite () 
{ 
Site site = new Site (http//intranet.CertKiller.com); 
return site.Check (AppDomain.CurrentDomain.Evidence); 
} D. Use the following code: 
public bool CheckSite () 
{ 
SiteMembershipCondition site = new SiteMembershipCondition (http//intranet.CertKiller.com); 
return site.Check (Assembly.GetCallingAssembly ().Evidence); 
} 





















Answer: D 

Explanation: 

This code instantiates a SiteMembershipCondition object using the site's URL as a string, 
retrieves the evidence information from the current assembly, and verifies the evidence indicating 
the assembly originates from the company intranet. The SiteMembershipCondition class' sole 
purpose is to verify whether an assembly belongs to a site's code group based upon the 
originating Web site of the application or assembly. The SiteMembershipCondition class has a 
constructor that takes a URL as a string argument. The Check method determines whether an 
assembly belongs to the site's code group based upon the evidence provided as an argument. 
The GetExecutingAssembly method of the Assembly class returns an Assembly object 
representing the assembly that invoked the CheckPolicy method. The Evidence property of the 
Assembly class returns the identity information used by the .NET Framework code access security 
mechanism to determine code group membership. 

Incorrect Answers: 

A: You should not use the code fragments that specify the AppDomain.CurrentDomain.Evidence 
property because this retrieves the evidence available to the current application domain only. 
GenericIdentity class and GenericPrincipal class 
B: You should not use the code fragments that specify the Site class because this class does not 
provide a method to verify the originating Web site of an assembly or application.Part 7: Access 
and modify identity information by using the System.Security.Principal classes. (Refer 
System.Security.Principal namespace) 
C: You should not use the code fragments that specify the AppDomain.CurrentDomain.Evidence 
property because this retrieves the evidence available to the current application domain only. 










QUESTION NO: 87 

You work as an application developer at CertKiller.com. You are currently creating an application 
that requires role-based security. You are planning to utilize a database to store the user accounts 
and group membership data. 

You need to ensure that users are able to log on and off. You also need to ensure that the 
application you have created tracks the user accounts of these users, and restrict or allow access 
to code based on their group membership. You need to achieve this objective with as little 
developer effort as possible. What should you do to implement role-based security? 

A. Inherit from the GenericIdentity and GenericPrincipal classes. 
B. Make use of GenericIdentity and GenericPrincipal objects. 
C. Implement the IIdentity and IPrincipal interfaces. 
D. Make use of WindowsIdentity and WindowsPrincipal objects. 




















Answer: B 

Explanation: 

in this scenario, the GenericIdentity and GenericPrincipal objects could be implemented as 
follows: 

GenericIdentity curIdentity = new GenericIdentity ("CurrentUser"); 
string [] roles = { "Users", "Administrators" }; 
thread.CurrentPrincipal = GenericPrincipal (curIdentity, roles); 

This code instantiates a GenericIdentity object based upon a user name as a string object, 
instantiates a string array representing the roles to which that user belongs, instantiates a 
GenericPrincipal object specifying the GenericIdentity object and string array of roles as 
arguments, and assigns the new GenericPrincipal object to the CurrentPrincipal property of the 
current thread. By assigning the new principal to the CurrentPrincipal property of the current 
thread, role membership checks can be performed using the IsInRole method 

Incorrect Answers: 

A: These options require more developer effort than necessary. 
C: These options require more developer effort than necessary. 
D: The WindowsIdentity and WindowsPrincipal classes are intended for use with windows domain 
stored accounts and groups only. 










QUESTION NO: 88 

You work as an application developer at CertKiller.com. You are in the process of creating an 
application that will display confidential employee information. 

When your manager informs you that only managers and administrators should be able to view 
the information, you utilize windows authentication and .NET role-based security to guarantee this. 

The network administrator in your department informs you that he has noticed that there are 
certain users that are not managers or administrators are able to view the employee information. 
You immediately analyze your code, and discover an issue with domain group memberships. The network administrator asks you to trace the user account and security identifier (SID) of each 
user in the application so that he can use this information to detect users across the enterprise 
and verify that their group memberships are correct. 

How would you do this? 

A. Use the following code: 
WindowsIdentity curID = WindowsIdentity.GetCurrent (); 
NTAccount account = new NTAccount (curID.Name); 
SecurityIdentifier sid = (SecurityIdentifier); 
account.Translate (typeof (SecurityIdentifier)); 
Trace.Write ("User's SID is" + sid.Value, "User" + account.Value); 


B. Use the following code: 
WindowsIdentity curID = WindowsIdentity.GetCurrent (); 
NTAccount account = new NTAccount (curID.Name); 
Trace.Write ("User's SID is" + sid.Value, "User" + account.Value); 
C. Use the following code: 
WindowsIdentity curID = WindowsIdentity.GetCurrent (); 
Trace.Write ("User's SID is" + curID.Value, "User" + sid.Name); 
D. Use the following code: 
WindowsIdentity curID = WindowsIdentity.GetCurrent (); 
SecurityIdentifier sid = new SecurityIdentifier (curID.Name); 
Trace.Write ("User's SID is" + curID.Value, "User" + sid.Name); 




















Answer: A 

Explanation: 

This code retrieves the current WindowsIdentity object associated with the user, instantiates an 
NTAccount object using the Name property, invokes the Translate method to retrieve the current 
SecurityIdentifier object, and invokes the Write method on the Trace class to record the Value 
property of both the SecurityIdentifier and NTAccount objects. The GetCurrent method of the 
WindowsIdentity object represents the identity of the application user. The NTAccount class 
represents a Windows user group account in the local Security Accounts Manager (SAM) or in the 
Active Directory domain. The constructor of the NTAccount class accepts either a single string 
representing the account name or two strings, one representing the domain name and the other 
representing the account on that domain. To facilitate SID lookups, the Translate method takes a 
Type argument and returns an IdentityReference object. You must convert or cast the 
IdentityReference object to a SecurityIdentifier object to retrieve the Sid for the specified account. 
The Value property of the SecurityIdentifier and NTAccount class returns a SID and fully-qualified 
user name string, respectively. The Write method of the Trace class outputs the specified 
message into the specified category. 

Incorrect Answers: B: You should not use the code that does not specify the SecurityIdentifier class because the 
NTAccount class does not have a SID property. 
C: You should not use the code that does not specify the NTAccount and SecurityIdentifier classes 
because there is no SID property in the WindowsIdentity class. 
NTAccount class and SecurityIdentifier class 
D: You should not use the code that does not specify the NTAccount class because a 
SecurityIdentifier object cannot be instantiated using an account name as an argument, and it 
does not contain a Name property. 
IIdentity interface and IPrincipal interface 










QUESTION NO: 89 

You work as an application developer at CertKiller.com. You are currently creating a sales report 
application that requires Windows authentication on CertKiller.com's domain. 

To achieve this, you are required to implement role-based security within the sales report 
application. 

You establish that the method shown below should only be invoked by members of the Managers 
group: 

public void UpdateEmpSalesBonus (int empID, double amount) 
{ 
//Update employee's salary 
} 

You need to ensure that invocation of the UpdateEmpSalesBonus method is restricted to only 
managers. 

What should you do? (Choose two) 

A. Apply the following attribute to the UpdateEmpSalesBonus method: 
[WindowsPrincipalPermission (SecurityAction.Demand, Role = "Managers")] 
B. Apply the following code to the UpdateEmpSalesBonus method: 
WindowsIdentity user = WindowsIdentity.GetCurrent (); 
if (user.IsInRole ("Managers")) 
{ 
//Update employee's salary 
} 


C. Apply the following attribute to the UpdateEmpSalesBonus method: 
[PrincipalPermission (SecurityAction.Demand, Role = "Managers")] 
D. Apply the following code to the UpdateEmpSalesBonus method: 
if (Thread.CurrentPrincipal.IsInRole ("Managers")) 
{ 
//Update employee's salary 
} 






















Answer: C,D 

Explanation: 

Imperative role-based security can use the PrincipalPermission class or the IPrincipal object 
directly. The PrincipalPermission class takes a user name and role as string arguments 
representing the required membership. The Demand method indicates that all callers must belong 
to the user or group membership specified in the constructor to access the resource. The 
IPrincipal object can be retrieved using the Thread.CurrentPrincipal property. The IsInRole 
method takes a role argument as a string and returns a Boolean value indicating whether the 
current caller belongs to that group or not. 

Incorrect Answers: 

A: You should not use the attribute that applies the WindowsPrincipalPermission attribute because 
no such attribute exists in the .NET Framework 2.0 class library. 
B: You should not use the code that invokes the IsInRole method on the WindowsIdentity class 
because no such method exists. 










QUESTION NO: 90 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You are trying to 
port an old CertKiller.com management application that was written in unmanaged Windows code 
with no COM interfaces. The application you are developing makes calls to the old CertKiller.com 
management unmanaged library namedKingPerformance.dll. 

You are required to make a call to the GetPerformaceScore method of the unmanaged 
Performance.dll library. 

What should you do? 

A. The Type Library Exporter tool (tlbexp.exe) should be used 
B. The Type Library Importer tool (tlbimp.exe) should be used 
C. The Assembly Registration tool (regasm.exe) should be used 
D. The Platform Invoke (DllImportAttribute) should be used 




















Answer: D 

Explanation: 

The feature Platform Invoke is used to allow you to call methods that are in unmanaged libraries 
but you need to declare the unmanaged method in the managed code using the extern and static 
keywords with the DllImport attribute which is used to specify the unmanaged library. 

Incorrect Answers: 

A: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
System.Reflection.Emit namespace. 
B: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
Create a class to hold DLL functions. 
Assembly class 
C: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
Create prototypes in managed code. 










QUESTION NO: 91 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. The application 
will be used to list the available public types and methods in the CertKiller.com assembly. You 
named the assembly strongly and it is installed in the global assembly cache (GAC) and an 
assembly with the same identity is stored at c:\CertKiller\assemb\CertKiller.com.dll. 

You are required to dynamically load the CertKiller.com assembly into your application whilst you 
ensure that the assembly is loaded from c:\CertKiller\assemb\CertKiller.com.dll rather than the 
global assembly cache (GAC). 

What should you do? 

A. Assembly assemb = Assembly.LoadFrom("c:\CertKiller\assemb\CertKiller.com.dll"); 
B. Assembly assemb = Assembly.LoadFile("c:\CertKiller\assemb\CertKiller.com.dll"); 
C. Assembly assemb = Assembly.ReflectionOnlyLoad("CertKiller.com"); 
D. Assembly assemb = Assembly.Load("CertKiller.com"); 
E. Assembly assemb = 
Assembly.ReflectionOnlyLoadFrom("c:\CertKiller\assemb\CertKiller.com.dll"); 




















Answer: E 

Explanation: 

To correctly load the Assembly class from the location c:\CertKiller\assemb\CertKiller.com.dll you 
should make used of the method used in the option of the scenario. 

Incorrect Answers: 

A: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
B: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
C: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
Assembly attributes 
D: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 










QUESTION NO: 92 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. The application's 
assembly is named CertKillerApp and is stored in CertKillerApp.exe. You are busy using .NET 
Framework's Strong Name tool to generate a pair for CertKillerApp.exe shown below: 

Sn.exe -k CertKillerAppKey 

You are required to use the key pair to build the CertKillerApp.exe as a strong named assembly. 

What should you do? 

A. The AssemblyKeyFileAttribute class should be used 
B. The AssemblyDelaySignAttribute class should be used 
C. The AssemblyConfigurationAttribute class should be used 
D. The AssemblyKeyNameAttribute should be used 




















Answer: A 

Explanation: 

The Strong name tool is used to allow you to generate and manage keys for the strong name 
signing and by using the -k switch the tool generates a new key pair and stores it in the specified 
file. So using the AssemblyKeyFileAttribute is the correct way to go in the scenario. 

Incorrect Answers: 

B: This class should not be considered for use as it is designed to specify whether or not delayed 
signing should be used. 
MailAddress class and MailAddressCollection class 
C: The class should not be used in the scenario because the class is used to specify a build 
configuration for an assembly. 
SmtpClient class, SmtpPermission class, and SmtpPermissionAttribute class 
D: This class should not be used in the scenario because it is used to specify the name of a key 
container that should be used. 
Info classes 
Attachment class, AttachmentBase class, and AttachmentCollection class 










QUESTION NO: 93 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS553 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-70-553. The application 
will allow users to send e-mails. The users are required to be able to send e-mail containing 
information like budget documents and images. You decide to use the .NET Framework 2.0 
Attachment class to create the e-mail attachments within your application. 

You are required to specify the content in an attachment by using the attachment class 
constructors. 

What should you do? (Choose two) 

A. The Stream object attachment class should be used in the scenario 
B. The String object attachment class should be used in the scenario 
C. The Image object attachment class should be used in the scenario 
D. The XmlDocument object attachment class should be used in the scenario 
E. The SqlDataReader object attachment class should be used in the scenario 




















Answer: A,B 

Explanation: 

In the scenario the Attachment constructors allow you to create attachments from a filename, a 
String object, or a Stream object. 

Incorrect Answers: 

C: This method is incorrect and should not be used in the scenario because the Image object 
Attachment class cannot directly use an Image object. 
D: This method is incorrect and should not be used in the scenario because the XmlDocument 
Attachment class cannot directly use an XmlDocument object. 
E: This method is incorrect and should not be used in the scenario because the SqlDataReader 
Attachment class cannot directly make use of a SqlDataReader object. 
SmtpException class and SmtpFailedReceipientException class 










QUESTION NO: 94 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS552 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on CERTKILLER-WS552. The 
application will be used to allow the users to send e-mail messages and should allow users to 
send HTML-based e-mails, but the users should not be able to use the HTML <img> tag to embed 
images in the HTML document 

The images are not externally hosted so instead the images must be sent as part of the e-mail 
message. You are required to select which class to use. 

What should you do? 

A. The AlternateView class should be used. 
B. The Attachment class should be used. 
C. The MailAddress class should be used. 
D. The LinkedResource class should be used. 




















Answer: D 

Explanation: 

In the scenario you should make use of the LinkedResource class as it is used to embed external 
resources in an e-mail attachment such as images in an HTML attachment. Incorrect Answers: 

A: The class in question could be used in the scenario but the AlternateView class itself cannot be 
used to embed images in the HTML document. 
B: The Attachment class should not be used in the scenario as the class only allows you to send 
images as an attachment. 
C: The usage of this class is incorrect as it is used to store the address information for e-mail 
messages in the scenario. 










QUESTION NO: 95 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 Windows Forms application on CERTKILLER-WS554. 
The Windows Forms application will be used by regional offices of CertKiller.com in various 
countries. 

You are required to customize the application so that the language, calendar and cultural 
conventions are changed based on the user's operating system settings. You additionally are 
required to identify the .Net Framework class that should be used for this requirement. 

What should you do? 

A. The cultureInfo class should be used 
B. The TextInfo class should be used 
C. The DateTimeFormtaInfo should be used 
D. The CharUnicodeInfo should be used 
E. The RegionInfo should be used 




















Answer: A 

Explanation: 

The CultureInfo class should be used in the scenario because it contains culture-specific 
information and provides the information required for performing culture-specific operations like 
changing casing, formatting dates and numbers and comparing strings. 

Incorrect Answers: 

B: This class should not be used in the scenario because this class only affects the behavior such 
as text casing. 
C: This class should not be used in the scenario because this class only defines how the Date and 
Time values are formatted. 
D: This class should not be used in the scenario because this class is used to only retrieve 
information about a Unicode character. 

E: This class should not be used in the scenario because this class does not represent any 
preferences of the user and does not depend upon the culture. 










QUESTION NO: 96 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 Windows Forms application on CERTKILLER-WS554. 
The application must provide support for multiple languages and regional differences. You are 
required to define a custom culture based on an existing culture and region. An administrative user 
will install the custom culture on the end user's computer prior to the applications deployment and 
you are required to select which class to use. 

What should you do? 

A. The CultureAndRegionInfoBuilder class should be used 
B. The CustomAttributeBuilder class should be used 
C. The RegioInfo class should be used 
D. The CultureInfo class should be used 




















Answer: A 

Explanation: 

The correct option in the scenario would be to make use of the CultureAndRegionInfoBuilder class 
as this class is used to define a custom culture that is new or based upon an existing region and 
culture. 

Incorrect Answers: 

B: This class should not be used in the scenario because this class is used to define custom 
attributes which are used to associate declarative information. 
C: This class should not be used in the scenario because this class is used to access the region 
data for an already installed culture. 
D: This class should not be used in the scenario because this class can only be used to make use 
of cultures that have already been installed. 










QUESTION NO: 97 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You need to 
provide locale-specific services to employees with the application. You must additionally ensure 
that you use a unique country identifier that can be used as a key to access a database record 
that contains specific information about a country whilst you use the minimum storage for storing 
the key. 

What should you do? 

A. CultureInfo.Name should be used as an identifier for a country 
B. CultureInfo.GetHashCode should be used as an identifier for a country 
C. RegionInfo.GetHashCode should be used as an identifier for a country 
D. RegionInfo.Name should be used as an identifier for a country 




















Answer: D 

Explanation: 

In the scenario you should make use of the RegionInfo.Name property as this property gets the 
name or ISO 3166 two-letter country/region code for the current RegionInfo object. 

Incorrect Answers: 

A: This method should not be used in the scenario as you will only receive the culture name 
instead of the country name and does not meet the objective. 
B: The usage of the GetHashCode property in the scenario is incorrect as the hash value 
generated can be used to tell whether the RegionInfo or CultureInfo objects are the same or not. 
Format date and time values based on the culture. 
C: The usage of the GetHashCode property in the scenario is incorrect as the hash value 
generated can be used to tell whether the RegionInfo or CultureInfo objects are the same or not. 










QUESTION NO: 98 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on CERTKILLER-WS554. You 
create the following variable in your code: 

DateTime dateValue; 

You additionally write code to store time in the local time to the dateValue variable. You are 
required to serialize the value of the dateValue variable, if you serialize the DateTime object in one 
time zone and deserialized in a different time zone, the local time represented as a result should be automatically adjusted to the second time zone. You are to decide which expression to use. 

What should you do? 

A. The dateValue.ToString("yyyy-MM-ddTHH:mm:ss.fffffff", CultureInfo.InvariantCulture) 
B. The dateValue.ToBinary() expression should be used 
C. The dateValue.Kind expression should be used 
D. The dateValue.Ticks expression should be used 




















Answer: B 

Explanation: 

To preserve the information that you are required to preserve in the scenario you should make use 
of the newToBinary and FromBinary method as these methods can be used to automatically 
adjust the local times. 

Incorrect Answers: 

A: The expression in question should not be used in the scenario because the expression will not 
preserver any of the required reserved information. 
C: This expression will be used to check whether the value indicates whether time is represented 
by the instance is based on local time. 
Format number values based on the culture. 
D: This expression is used to super fast serialize the required information but should not be 
considered when working with the local time. 










QUESTION NO: 99 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS552 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on CERTKILLER-WS552 used 
as collateral. You write the code below in your application, line numbers are reference: 

01: string num; 
02: integer val; 
03: num = " (37)"; 
04: 
You are required to write additional code at line 04 that will be used to correctly parse the string value and assigns the result to the Integer variable named val. When you execute the code the 
variable is required to hold a value of -37 and you must decide which code to use. 

What should you do? 

A. val=Int32.Parse(num, NumberStyles.AllowLeadingSign And NumberStyles.AllowLeadingWhite) 
B. val=Int32.Parse(num, NumberStyles.AllowParentheses And NumberStyles.AllowLeadingWhite) 
C. val=Int32.Parse(num, NumberStyles.AllowLeadingSign Or NumberStyles.AllowLeadingWhite) 
D. val=Int32.Parse(num, NumberStyles.AllowParentheses Or NumberStyles.AllowLeadingWhite) 




















Answer: D 

Explanation: 

The NumberStyles.AllowParentheses value is used to indicate that the numeric string can have 
one pair of parentheses enclosing the number and the NumberStyles.AllowLeadingWhite value is 
used to indicate that a leading white-space character must be ignored during the parse. 

Incorrect Answers: 

A: This code should not be used in the scenario because the code is used to indicate that the 
numeric string can have a leading sign. 
B: This code should not be used in the scenario because the code is used to indicate that the 
numeric string can have a leading sign. 
C: The code in question should not be used in the scenario because the attributes of 
NumberStyles are set by using the bitwise inclusive Or on the field flags. 










QUESTION NO: 100 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows Forms application that will be used by 
several CertKiller.com employees in several countries on a workstation used as collateral. The 
application is required to fully support customization of the user interface based on the user's 
preferences like the language currency and date and time formats. 

You are required to write code that will compare the name of two employees which are stored in 
variables named employee1 and employee2. You are required to ensure correct comparisons 
whilst taking care of the regional settings selected. 

What should you do? 

A. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.CurrentCulture) segment 
should be used 
B. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.InvariantCulture) 
segment should be used 
C. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.InstalledUICulture) 
segment should be used 
D. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.CurrentUICulture) 
segment should be used 




















Answer: A 

Explanation: 

The default behavior of the segment in question is to perform culture-sensitive comparisons and 
should definitely be considered for use in the scenario. 

Incorrect Answers: 

B: This code segment is incorrect and should not be used in the scenario because it will lead to 
culture-insensitive operations. 
C: This code segment is incorrect and should not be used in the scenario because this will used 
the culture that is installed with the operating system. 
D: This code segment is incorrect and should not be used in the scenario because this settings 
only used for changing the user's interface culture used by a thread. 










QUESTION NO: 101 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a large .NET Framework 2.0 application that is required to provide support for 
culture-specific information. You are required to parse a date and time string generated for a 
custom culture and to help the success of the parse operation you designate parse patterns that 
tare likely to succeed. You must additionally prevent the operation from failing whilst you select the 
method to use for parsing the string. 

What should you do? 

A. The ParseExact method should be used 
B. The Parse method should be used 
C. The TryPassExact method should be used 
D. The TryParse method should be used 




















Answer: C 

Explanation: The TryParseExact method should be used if you require parsing a date and time string generated 
from a custom culture. 

Incorrect Answers: 

A: The usage of these methods in the scenario would be incorrect because the methods do not 
provide error handling and the custom vulture can be complicated and difficult to parse. 
Enhance the user interface of a .NET Framework application by using brushes, pens, colors, and 
fonts. 
B: The usage of these methods in the scenario would be incorrect because the methods do not 
provide error handling and the custom vulture can be complicated and difficult to parse. 
Enhance the user interface of a .NET Framework application by using graphics, images, bitmaps, 
and icons. 
D: If you decide to use the TryParse method which attempt to parse a string using several implicit 
parse patterns that may all fail you will not achieve the scenario objective.Part 2: Enhance the user 
interface of a .NET Framework application by using the System.Drawing namespace. 










QUESTION NO: 102 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application that will be used to manipulate graphics 
files in GIF, JPG and PNG formats. You are required to choose an appropriate data type to store 
graphic files whilst your solution must use the least amount of code. 

What should you do? 

A. The Icon class should be used 
B. The Metafile class should be used 
C. The Image class should be used 
D. The Bitmap class should be used 




















Answer: D 

Explanation: 

Because the Bitmap class is an implementation of the Image abstract class that is capable of 
working with several types of image formats this class should be considered for usage in the 
scenario. 

Incorrect Answers: 

A: This class should not be used in the scenario because the Icon class only allows you to work 
with small bitmap images. 
StringBuilder class 
B: This class should not be used in the scenario because this class can not be used to manipulate 
images in different formats. 
Regex class 
C: This class should not be used in the scenario because this class is an abstract class which 
requires functionality to be implemented which requires programming effort. 
Enhance the user interface of a .NET Framework application by using shapes and sizes.Part 3: 
Enhance the text handling capabilities of a .NET Framework application (refer System.Text 
namespace), and search, modify, and control text in a .NET Framework application by using 
regular expressions. (Refer System.RegularExpressions namespace) 










QUESTION NO: 103 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS551 as your development computer. 

You are developing a .NET Framework 2.0 text-processing application on CERTKILLER-WS551. 
You define the following regular expression of currency values: 

regex tx = new regex("^-?\d+(\.\d{2})?$") 

You are required to write code that will be used to find whether a string in the variable named king 
matches the regular expression or not. You are also required to use this code as the expression in 
a conditional statement and need to know which code segment to use. 

What should you do? 

A. The tx.Matches(king) 
B. The tx.Equals(king) 
C. The tx.Match(king) 
D. The tx.IsMatch(king) 




















Answer: D 

Explanation: 

In order for you to successfully indicate whether the regular expression finds a match in the input 
string you should make use of the IsMatch(king) segment in the scenario. 

Incorrect Answers: 

A: This segment should not be used in the scenario because the Matches method is used to 
search an input string for all occurrences of a regular expression and returns all the successful 
matches. 
B: This segment should not be used in the scenario because this method is used to determine 
whether any two Object instances are equal. 

C: This segment should not be used in the scenario because the Matches method is used to 
search an input string for an occurrence of a regular expression and returns the precise results as 
a single successful match. 
Match class and MatchCollection class 










QUESTION NO: 104 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application. The application will be used globally and 
must be able to represent characters in the following languages: English, Chinese Traditional, 
Hebrew and Tamil. Your application is required to provide error detection for invalid sequences of 
characters whilst your application must also optimize storage. 

What should you do? 

A. Encode the characters in your application using the UTF8Encoding class 
B. Encode the characters in your application using the UTF7Encoding class 
C. Encode the characters in your application using the UTF32Encoding class 
D. Encode the characters in your application using the UTF16Encoding class 




















Answer: A 

Explanation: 

To successfully enable error detection and make the class instance more secure you should make 
use of the UTF8Encoding class in the scenario. 

Incorrect Answers: 

B: The Encoding class used in this option UTF7Encoding does not provide any error detection and 
should not be used in the scenario. 
C: The Encoding classes in these options should not be used in the scenario because the 
UTF16Encoding class represents each character as a sequence of one to two 16-bit integers and 
the UTF32Encoding represents each code point as a 32-bit integer. 
D: The Encoding classes in these options should not be used in the scenario because the 
UTF16Encoding class represents each character as a sequence of one to two 16-bit integers and 
the UTF32Encoding represents each code point as a 32-bit integer. 










QUESTION NO: 105 You work as the application developer at CertKiller.com. You are developing a .NET Framework 

2.0 application that uses the following code (line numbers are for reference only) 
1: Dim testCount As Nullable(Of Integer) = -1 
2: testCount = Nothing 
You are required to insert a statement after line 2 to print the value of the variable testCount but if 
the value of the testCount is a null reference(nothing) the program should print -1. 

What should you do? 

A. If (testCount.HasValue) Then 
Console.WriteLine("testCount = {0}", testCount.Value) 
Else 
Console.WriteLine("testcount = {0}", testCount.GetValueOrDefault()) 
End If 

B. Console.WriteLine("testCount = {0}", testCount.Value) 
C. Console.WriteLine("testcount = {0}", testCount.GetValueOrDefault()) 
D. If (testCount.HasValue) Then 
Console.WriteLine("testCount = {0}", testCount.Value) 
Else 
Console.WriteLine("testCount = {0}", -1) 
End If 





















Answer: D 

Explanation: 

The Has.Value method should be used to determine if a nullable type contains a defined value 
and should be used in the scenario. 

Incorrect Answers: 

A: The other statements are incorrect as it will only run fine when a value is nor set to Nothing in 
the scenario. The GetVaueOrDefault method retrieves the value of the current nullable object if it 
is not Nothing. 
B: The other statements are incorrect as it will only run fine when a value is nor set to Nothing in 
the scenario. The GetVaueOrDefault method retrieves the value of the current nullable object if it 
is not Nothing. 
C: The other statements are incorrect as it will only run fine when a value is nor set to Nothing in 
the scenario. The GetVaueOrDefault method retrieves the value of the current nullable object if it 
is not Nothing. 










QUESTION NO: 106 You work as an application developer at CertKiller.com. CertKiller.com uses the Microsoft Visual 
Studio .NET 2005 as their application development platform. 

You are in the process of storing numerical values up to 2,100,000,000 into a variable and may 
require storing negative values using a .NET Framework 2.0 application. You are required to 
optimize memory usage, 

What should you do? 

A. Use the Int32 data type. 
B. Use the UInt16 data type. 
C. Use the UInt32 data type. 
D. Use the Int16 data type. 




















Answer: A 

Explanation: 

The Int32 type should be used in the scenario as it can be used to store positive and negative 
numerical values from -2,147,483,648 to +2,147,483,647. 

Incorrect Answers: 

B: The UINT32 and UInt16 type should not be used in the scenario because they are used to store 
only unsigned positive numbers. 
Reference types 
C: The UINT32 and UInt16 type should not be used in the scenario because they are used to store 
only unsigned positive numbers. 
Attributes 
D: The Int16 type should not be used as you will only be allowed to store values from -32768 to 
+32768. 
Generic types 










QUESTION NO: 107 

You work as an application developer at CertKiller.com. CertKiller.com uses the Microsoft Visual 
Studio .NET 2005 as their application development platform. 

You have recently finished development of a class named TestReward and package the class in a 
.NET 2.0 assembly named TestObj.dll. After you ship the assembly and it is used by client 
applications, you decide to move the TestReward class from TestObj.dll assembly to the 
TestRewardObj.dll Assembly. You are to ensure when you ship the updated TestObj.dll and 
TestRewardObj.dll assemblies that the client applications continue to work and do not require 
recompiling. What should you use? 

A. The TypeForwardedTo attribute. 
B. The TypeConvertor.ConvertTo method. 
C. The InternalsVisibleTo attribute. 
D. The TypeConvertor.ConvertFrom method. 




















Answer: A 

Explanation: 

The statement used for you to add a type from one assembly into another assembly is the 
TypeForwardTo attribute which enables you not to have the application recompiled. 

Incorrect Answers: 

B: The TypeConverter class provides a unified way of converting different types of values to other 
types and can not be used to move a type. 
C: The method in question here specifies all nonpublic types in an assembly are visible to other 
assemblies but can not be used to move types.Part 2: Manage a group of associated data in a 
.NET Framework application by using collections. (Refer System.Collections namespace) 
D: The TypeConverter class provides a unified way of converting different types of values to other 
types and can not be used to move a type. 










QUESTION NO: 108 

You work as an application developer at CertKiller.com. You are developing a .NET Framework 

2.0 application used to store a type-safe list of names and e-mail addresses. The list will be 
populated all at ones from the sorted data which means you well not always need to perform 
insertion or deletion operations on the data. You are required to choose a data structure that 
optimizes memory use and has good performance. 
What should you do? 

A. The System.Collections.Generic.SortedList class should be used 
B. The System.Collections.HashTable class should be used 
C. The System.Collections.Generic.SortedDictionary class should be used 
D. The System.Collections.SortedList class should be used 




















Answer: A 

Explanation: 

The SortedList generic class should be used in the scenario class as it provides type safety 
compared against the System.Collections.SortedList class. 

Incorrect Answers: B: The System.Collections.HashTable class should not be used as this class provides no type 
safety. 
Collection interfaces 
C: Although this is very similar to the SortedList class the SortedList class should be used instead 
in the scenario. 
D: Although this is very similar to the SortedList class the SortedList class should be used instead 
in the scenario. 










QUESTION NO: 109 

You work as the application developer at CertKiller.com. You are developing a .NET Framework 

2.0 application that uses the Stack class. You need to write the code which will enumerate through 
the stack which may contain objects of the Stack class or objects of a class derived from the Stack 
class. The code you write must guarantee thread safety during the enumeration 
What should you do? 

A. Dim TeStack As Stack = New Stack() 
SyncLock (TeStack.SyncRoot) 
For Each item As Object In TeStack 
' additional code goes here. 
Next 
End SyncLock 


B. Dim TeStack As Stack = New Stack() 
Dim syncStack As Stack = Stack.Synchronized(TeStack) 
For Each item As Object In syncStack 
'additional code goes here. 
Next 


C. Dim TeStack As Stack = New Stack() 
Dim syncStack As Stack = TeStack.SyncRoot 
For Each item As Object In syncStack 
' additional code goes here. 
Next 


D. Dim TeStack As Stack = New Stack() 
SyncLock (Stack.Synchronized(TeStack)) 
For Each item As Object In TeStack 
' additional code goes here. 
Next 
End SyncLock 





















Answer: A Explanation: 

It is important to remember that when enumerating through a collection that a thread procedure is 
not safe as another thread can modify the collection, to ensure the safety the collection should be 
locked during enumeration. 

Incorrect Answers: 

B: Any Stack classes derived from the Stack class may make use of the SyncRoot property to 
implement their own synchronized version of the Stack class. 
C: Any Stack classes derived from the Stack class may make use of the SyncRoot property to 
implement their own synchronized version of the Stack class. 
Iterators 
D: The technique used here can also be used to maintain proper synchronization with other 
threads that might be modifying the Stack object simultaneously. 
Hashtable class 










QUESTION NO: 110 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted to 
develop an application for the local bank. 

You have been given the responsibility of creating this application and need to store each 
transaction record, which is identified using a complex transaction identifier, in memory. The bank 
informs you that the total amount of transaction records could reach 200 per day. 

To achieve this, you decide to utilize one of the existing collection classes in the .NET 2.0 class 
library. 

You need to ensure that you the collection class you select is the most efficient one for storing 
transaction records. 

What should you do? 

A. Select the ListDictionary collection class. 
B. Select the HashTable collection class. 
C. Select the Queue collection class. 
D. Select the StringCollection collection class. 




















Answer: B 

Explanation: 

You should select the HashTable class to store transaction records because each element is 
identified using a unique identifier and the size of the collection is large. Elements in the 
HashTable collection are stored with a key/value pair where each key is created using a hash code. The default capacity of a HashTable class is zero, and you can use the Add method to add 
a new element to the collection. The Count property provides the total number of elements in the 
HashTable collection. An element of the HashTable class can be accessed using the 
DictionaryEntry class. You can use the Key and Value properties of the DictionaryEntry class to 
access the key associated with the element and the value of the element, respectively. 

Incorrect Answers: 

A: You should not select this collection class because this class is used if the total number of 
elements to be stored in a collection is less than 10 elements in length. 
C: You should not select this collection class because you need to access transaction records 
using a transaction identifier, not in sequential order. 
D: You should not select this collection class because this class is used to manage a collection of 
string values. 










QUESTION NO: 111 

You work as an application developer at CertKiller.com. CertKiller.com has been hired by a small 
local private school to develop a class library that will be used in an application named 
ManageAttendance for the purpose of managing student records. 

You are responsible for developing this class library. CertKiller.com has instructed you to create a 
collection in the application to store learners' results. 

The school has informed you that they currently only have seven learners, but that this value will 
triple in the following year. Due to the limited resources, you need to ensure that the collection you 
create consumes a minimum amount of resources. 

What should you use to create the collection? 

A. The HybridDictionary collection class. 
B. The HashTable collection class. 
C. The ListDictionary collection class. 
D. The StringCollection collection class. 




















Answer: A 

Explanation: 

You should use the HybridDictionary class to create the collection because this class is useful in 
scenarios where the number of elements is unknown or could grow in size. A collection of the 
HybridDictionary type manages the collection depending on the number of elements. The 
HybridDictionary type collection uses the ListDictionary class to manage the collection when there 
are only a few elements. When the number of elements exceeds ten, the HybridDictionary type 
collection automatically converts the elements into HashTable management. Incorrect Answers: 

B: You should not use this collection class because this class is used if the total number of 
elements to be stored in a collection is known and is greater than ten elements in length. 
C: You should not use this collection class because this class is used if the total number of 
elements to be stored in a collection is known and is less than ten elements in length. 
D: You should not use this collection class because this class is used to manage a collection of 
string values. 










QUESTION NO: 112 

You work as an application developer at CertKiller.com. You are developing an application that 
makes use of a Queue class object named MyQueue. This Queue class object will be used to 
store messages sent by the user during application run time. The application that you are 
developing provides an interface for CertKiller.com administrators and an interface for 
CertKiller.com users to create message reports. 

You want to ensure that all user messages stored in the MyQueue object are removed when an 
CertKiller.com administrator selects the reset option. 

What should you do? 

A. Use the Enqueue method of the MyQueue object. 
B. Use the Clear method of the MyQueue object. 
C. Use the Dequeue method of the MyQueue object. 
D. Use the TrimToSize method of the MyQueue object. 




















Answer: B 

Explanation: 

The clear method sets the Count property of the Queue class object to 0 after removing all the 
elements from the queue. When you call the Clear method for a Queue object, the capacity of the 
Queue object is not changed. 

Incorrect Answers: 

A: You should not use this method because it is used to add a new element at the beginning of a 
Queue object. 
C: You should not use this method because it is used to remove an element at the beginning of a 
Queue object. 
D: You should not use this method because it is used to resize a Queue object. 










QUESTION NO: 113 You work as an application developer at CertKiller.com. You are developing an application that 
makes use of a Queue class object named MyQueue. This Queue class object will be used to 
store messages sent by the user during application run time. 

You would like to access the message at the beginning of the queue, prior to processing the user 
messages, without removing it. 

What should you do? 

A. Use the Enqueue method of the MyQueue object. 
B. Use the Contains method of the MyQueue object. 
C. Use the Dequeue method of the MyQueue object. 
D. Use the Peek method of the MyQueue object. 




















Answer: D 

Explanation: 

The Peek method accesses the element at the beginning of the object of the Queue class without 
removing it from the queue. The Queue class is a data structure for handling elements based on 
the First In First Out (FIFO) concept. According to this concept, elements that are stored first are 
processed first. 

Incorrect Answers: 

A: You should not use this method of the Queue class because it is used to add a new element at 
the end of a Queue object. 
B: You should not use this method of the Queue class because it is used to verify whether the 
specified element exists for the Queue object instance or not. 
C: You should not use this method of the Queue class because it is used to remove the next 
element at the beginning of a Queue object. 










QUESTION NO: 114 

You work as an application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an application that will store user messages collectively and then process the 
messages in sequence. The order in which the messages are processed will depend on the order 
in which it is received. 

To add messages to the collection, CertKiller.com users will specify the message that should be 
stored in a TextBox control named txtMsg and then click a Button control named btnAdd. 

You need to ensure that the appropriate code is used to create the collection. What should you use? (Choose two) 

A. Dim msgCollection As Queue = New Queue() 
B. Dim msgCollection As Stack = New Stack() 
C. msgCollection.Enqueue(txtMsg.Text) 
D. msgCollection.Push(txtMsg.Text) 




















Answer: A,C 

Explanation: 

In this scenario, you should use the Queue class to create the collection because you are required 
to process user messages in sequence. The Dim statement creates an object named 
msgCollection of the Queue class. The second line of code then calls the Enqueue method of the 
msgCollection object to add the Text property value of the txtMSG control as an element in the 
collection. To manage elements in the queue, the Queue class provides methods, such as 
Dequeue and Clear . The Dequeue method is used to remove elements that are at the beginning 
of the Queue object. The Clear method is used to remove all elements from a Queue object. The 
Queue class is a data structure for handling elements based on the First In First Out (FIFO) 
concept. 

Incorrect Answers: 

B: Using these lines of code is incorrect because they use the Stack class to create a collection. 
Stack objects are used to store elements on the Last In First Out (LIFO) concept. 
D: Using these lines of code is incorrect because they use the Stack class to create a collection. 
Stack objects are used to store elements on the Last In First Out (LIFO) concept. 










QUESTION NO: 115 

You work as the application developer at CertKiller.com. You are developing a .NET Framework 

2.0 application that uses a Dictionary generic class. You write the following code to create the 
dictionary. 
Dim value As String = "" 
Dim openWith As Dictionary(Of String, String) = New Dictionary(Of String, String)() 


openWith.Add("txt", "notepad.exe") 
openWith.Add("gif", "paint.exe") 
openWith.Add("png", "paint.exe") 
openWith.Add("rtf", "wordpad.exe") 
openWith.Add("log", "notepad.exe") 


You are required to write the code that displays the value corresponding to a key if the key exists 
in the dictionary, but the code frequently tries keys that are not in the dictionary. The solution you 
propose must minimize the number of times you access the dictionary and offer the fastest 
performance. 

What should you do? 

A. If openWith.ContainsKey("tif") Then 
Console.WriteLine("For key = " "tif" ", value = {0}. ", openWith("tif")) 
Else 
Console.WriteLine("Key = " "tif" "is not found.") 
End If 

B. Try 
Console.WriteLine("For key = " "tif" ", value = {0}. ", openWith("tif")) 
Catch notfoundex As KeyNotFoundException 
Console.WriteLine("Key =" "tif" "is not found.") 
End Try 

C. Try 
Console.WriteLine("For key = " "tif" ", value = {0}. ", openWith("tif")) 
Catch argex As ArgumentException 
Console.WriteLine("Key =" "tif" "is not found.") 
End Try 

D. If (openWith.TryGetValue("tif", value)) Then 
Console.WriteLine("For key = " "tif" ", value = {0}. ", value) 
Else 
Console.WriteLine("Key = " "tif" "is not found.") 
End If 





















Answer: D 

Explanation: 

By making use of the TryGetValue method you efficiently retrieve values in a program that 
frequently tries keys that are not in the dictionary. By using this method the return will simply be a 
null reference (nothing). 

Incorrect Answers: 

A: The contains key is an effective way to check if a key exists but in this scenario it would require 
an additional operation to retrieve the value corresponding to the key. 
B: Better performance can be attained by using the TryGetValue method in the scenario. 
C: The method in question about catching the ArgumentException is not correct as nothing will be 
caught that is thrown when a key is not found. 










QUESTION NO: 116 You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application class library. You create a class named 
Test using the following code. 

Class Test 

'Additional code goes here 

End Class 

In the code created a SortedList collection with the Test objects as keys, the SortedList collection 
must be able to sort the items in a collection so that they are arranged in order from biggest to 
smallest. You must ensure that the class you wrote complies with the .NET Framework standard 
contracts. 

What should you do? 

A. The Test class should be modified to implement the Icomparer interface. 
B. The Test class should be modified to implement the IEquatable interface. 
C. The Test class should be modified to implement the IConvertible interface. 
D. The Test class should be modified to implement the IComparable interface. 




















Answer: D 

Explanation: 

The Test class must be modified to implement the Icomparable interface as it determines the sort 
order of the two objects of the class. 

Incorrect Answers: 

A: This method is not recommended because the key type (Test) implements Icomparable , the 
default comparer of the SortedList will use Icomparable defined in the Test class to compare two 
objects. 
B: This method should not be implemented as it only checks the two type instances for equality. 
Generic Dictionary 
C: This interface is used to define methods that allow you to convert the value of the Test object to 
an equivalent value of any other type. 
Generic Comparer class and Generic EqualityComparer class 










QUESTION NO: 117 You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an application that uses the queue data structure. You are required to create a 
solution that allows you to enumerate a queue's contents whilst providing type safety. 

What should you do? 

A. Dim CKQueue As Queue = New Queue() 
CKQueue.Enqueue("one") 
CKQueue.Enqueue("two") 
For Each CKStr As String In CKQueue 
Console.WriteLine(CKStr) 
Next 


B. Dim CKQueue As Queue(Of String) = New Queue(Of String)() 
CKQueue.Enqueue("one") 
CKQueue.Enqueue("two") 
For Each CKStr As String In CKQueue 
Console.WriteLine(CKStr) 
Next 

C. Dim CKQueue As Queue = New Queue() 
CKQueue.Enqueue("one") 
CKQueue.Enqueue("two") 
Dim safeT As Queue = Queue.Synchronized(CKQueue) 
For Each CKStr As String In CKQueue 
Console.Writeline(CKStr) 
Next 

D. Dim CKQueue As Queue = New Queue() 
CKQueue.Enqueue("one") 
CKQueue.Enqueue("two") 
For Each CKStr As String in CKQueue 
Console.WriteLine(CKStr) 
Next 





















Answer: B 

Explanation: 

If you are to ensure type safety the generic version of the Queue class should be used, if you used 
the non-generic Queue class you would be able to add or insert objects of any type. 

Incorrect Answers: 

A: The usage of the SyncRoot property and the Synchronized method is useful for using the 
queue in a multithreaded scenario but does not provide any type safety. 
Specialized String classes 

C: The usage of the SyncRoot property and the Synchronized method is useful for using the 
queue in a multithreaded scenario but does not provide any type safety. 
D: The usage of the SyncRoot property and the Synchronized method is useful for using the 
queue in a multithreaded scenario but does not provide any type safety. 










QUESTION NO: 118 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an application that will be used to store a list of names and e-mail addresses. 
The number f elements in the list are currently unknown and may vary at runtime. You are 
required to choose a data structure that provides the highest performance as you work with your 
data. 

What should you do? 

A. A HybridDictionary should be used 
B. A HashTable should be used 
C. The ListDictionary should be used 
D. OrderedDictionary should be used 




















Answer: A 

Explanation: 

Since the number of Elements in the dictionary is unknown the HybridDictionary class is 
recommended as it takes advantage of the improved performance of a ListDictionary with small 
collections. 

Incorrect Answers: 

B: The class used in the answer to the scenario takes advantage of all that is offered by these 
classes and these classes should not be used. 
C: The class used in the answer to the scenario takes advantage of all that is offered by these 
classes and these classes should not be used. 
Named collections 
D: In the scenario at hand the use of a OrderedDictionary class does not provide any performance 
advantage. 
CollectionsUtil 










QUESTION NO: 119 You work as an application developer at CertKiller.com. You are developing a collection class 
named ClientCollection, which is to be used for storing the names of CertKiller.com's clients that 
are situated in various geographical areas. 

These client names are represented by the Client class. You are planning to create a method 
named SortClients in the ClientCollection class to arrange Client objects in ascending order. 

You need to ensure that the appropriate interface is implemented by the Client class to allow 
sorting. 

What interface should be used? 

A. IDictionary 
B. IComparable 
C. IComparer 
D. IEqualityComparer 




















Answer: B 

Explanation: 

The IComparable interface provides only one method named CompareTo , which takes on generic 
object, compares it to the current instance, and returns an Integer value representing whether the 
current instance is equal to, greater than, or less than the object. The IComparable interface is 
typically used when you want to create a class whose objects can be sorted in either a list or 
collection. 

Incorrect Answers: 

A: This interface should not be implemented because it is used to create a collection that is 
managed by key/value pairs. 
Delegate class 
C: This interface should not be implemented because it should be implemented by collection or 
comparer classes, not comparable classes. 
IConvertible interface 
D: This interface should not be implemented because it provides methods to compare two objects 
for equality only. 
ICloneable interface 










QUESTION NO: 120 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an pplication that handles the inventory for CertKiller.com. You develop and Inventory class. The class definition for the Inventory class is shown in the following exhibit. 


Public Class Inventory 
Public Event Reorder As EventHandler 
Private quantity As Integer 


Protected Overridable Sub OnReorder(ByVal e As EventArgs) 
RaiseEvent Reorder(Me, e) 
End Sub 
End Class 


You need to have code added for a new method named TestOne. The new method will be used to 
decrease the quantity variable by one unit and raises the Reorder event when the quantity 
becomes 0. You must additionally avoid rewriting any functionality that is already available. 


What should you do? 


A. Public Sub TestOne() 
quantity = quantity -1 
If quantity = 0 Then 
RaiseEvent Reorder(Me, EventArgs.Empty) 
End If 
End Sub 

B. Public Sub TestOne() 
quantity = quantity -1 
If quantity = 0 Then 
AddHandler Reorder, AddressOfInventory_Reorder 
End If 
End Sub 
Public Sub Inventory_Reorder(ByVal sender As Object Object, ByVal e As EventArgs) 
OnReorder(e) 
End Sub 

C. Public Sub TestOne() 
quantity = quantity -1 
If quantity = 0 Then 
RaiseEvent Reorder(Me,New EventArgs()) 
End If 
End Sub 

D. Public Sub TestOne() 
quantity = quantity -1 
If quantity =0 Then 
OnReorder(New EventArgs()) 
End If 
End Sub 





















Answer: D 

Explanation: 

The method in the answer is the correct choice because when the quantity reaches 0 it calls the 
OnReorder method which raises the Reorder event. 

Incorrect Answers: 

A: The method in this answer should not be used as an AddHandler statement is used to add an 
event handler to the Reorder event which in turn calls the OnReorder method raising the Reorder 
event in an infinite loop. 
B: The following methods should not be used because you should call the already available 
OnReorder method to correctly raise the Reorder event without rewriting the functionality which 
already exists. 
C: The following methods should not be used because you should call the already available 
OnReorder method to correctly raise the Reorder event without rewriting the functionality which 
already exists. 










QUESTION NO: 121 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 class library and write the following code: 


Public Delegate Sub NumberDelegate(ByVal number As Integer) 
Public Class NumberClass 


Public Sub Method1(ByVal number As Integer) 
Dim output As String = "Zero" 
If (number > 0) Then output = "Positive" 
If (number < 0) Then output = "Negative" 
Console.WriteLine(output) 
End Sub 


Public Sub Method2(ByVal number As Integer) 
Dim output As String = String.Empty 
If (number > 0) Then output = "+" 
If (number < 0) Then output = "-" 
Console.WriteLine(output) 
End Sub 
End Class 
You want to test the class. You write the following piece of code to test the class: 


Dim num As NumberClass = New NumberClass() 
Dim del1 As NumberDelegate = New NumberDelegate(AddressOf num.Method1) 
Dim del2 As NumberDelegate = New NumberDelegate(AddressOf num.Method2) 
[Delegate].combine(del2, del1) 
del1(5) 


You are required to select the output that you would receive. 


What should you select? 


A. Positive 
B. Positive 
+ 
C. + 
positive 
D. + 




















Answer: A 

Explanation: 

It is possible to combine two delegates objects but it does not alter the existing delegates, 
therefore the received output would be Positive. 

Incorrect Answers: 

B: There will be only one line of output generated because only one delegate (del1) is invoked in 
the scenario. 
EventArgs class 
C: There will be only one line of output generated because only one delegate (del1) is invoked in 
the scenario. 
D: There will be only one line of output generated because only one delegate (del1) is invoked in 
the scenario. 










QUESTION NO: 122 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an inventory application by using the .NET Framework 2.0 for CertKiller.com. 
You develop and Inventory class. The class definition for the Inventory class is shown in the 
following exhibit. Public Class Inventory 
Public Event Reorder As EventHandler 
Private quantity As Integer 

Public Sub SellOne() 
quantity = quantity - 1 
If quantity = 0 Then 
OnReorder(Me, New EventArgs()) 
End If 
End Sub 
End Class 

You are required to define the OnReorder method to raise the Reorder event. 

What should you do? 

A. Protected Overridable Sub OnReorder (ByVal sender As Object, ByVal e As EventArgs) 
RaiseEvent Reorder(Me, e) 
End Sub 

B. Protected Overridable Sub OnReorder (ByVal sender As Object, ByVal e As EventArgs) 
AddHandler Reorder, AddressOf OnReorder 
RaiseEvent Reorder(Nothing, e) 
End Sub 

C. Protected Overridable Sub OnReorder (ByVal sender As Object, ByVAL e As EventArgs) 
If e Is Nothing Then 
RaiseEvent Reorder(Me, e) 
End If 
End Sub 

D. Protected Overridable Sub OnReorder (ByVal sender As Object, ByVal e As EventArgs) 
AddHandler Reorder, AddressOf OnReorder 
End Sub 





















Answer: A 

Explanation: 

By using the code specified in the answer, the RaiseEvent statement raises the specified event by 
calling all the event handlers attached to the event. 

Incorrect Answers: 

B: This statement about AddHandler is incorrect as you have to raise the event not add event 
handlers. 
C: This is also incorrect as there is no need for checking whether the event argument is nothing 
before invoking the event. 
EventHandler delegates 

D: This statement about AddHandler is incorrect as you have to raise the event not add event 
handlers. 










QUESTION NO: 123 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a Windows Forms application. You are required to create a new class that 
raises a large number of events and keep memory usage of the class as low as possible. This task 
must be accomplished using the minimum amount of code possible. 

What should you do? 

A. One instance of the EventHandlerList class should be used to store the delegate defined for 
each event in the class 
B. One instance of the EventInstance class should be used for each event in the class 
C. The EventBuilder class should be used to define the events for the class 
D. One member variable per event delegate should be created per event delegate instance in the 
class 




















Answer: A 

Explanation: 

The best option in this scenario would be to make use of the EventHandlerList class since the 
number of events is large and this method provides a memory efficient mechanism for storing a list 
of delegates. 

Incorrect Answers: 

B: This method is used for representing information for an event log entry. 
C: This method is used for defining events for a dynamically generated class and in the scenario 
the class is not dynamically generated. 
D: This method should not be used as it is not a memory efficient solution which is what is 
required of you. 










QUESTION NO: 124 

You work as the application developer at CertKiller.com. You are developing a .NET Framework 

2.0 Windows Service application named TestScannerSync that will be used to constantly monitor 
for a scanner to be connected to the computer. The TestScannerSync class inherits its 
functionality from the ServiceBase class. When you connect a scanner the service synchronizes 
its data with the data in a SQL Server database. 
You decide to override the OnStop method in the TestScannerSync class and write code to close 
database connections. You are required to identify a place in the code where you can open the 
connection to the database. 

What should you do? 

A. The database connection is opened in the constructor of TestScannerSync class 
B. The database connection is opened in the OnContinue method of TestScannerSync class 
C. The database connection is opened in the OnStart method of the TestScannerSync class 
D. The database connection is opened in the OnPowerEvent method of the TestScannerSync 
class 




















Answer: C 

Explanation: 

The constructor for a service class derived from ServcieBase is called the first time you call Start 
on the service, the OnStart command-handling method is called immediately after the constructor 
executes. 

Incorrect Answers: 

A: The constructor is the incorrect choice as this is only called upon once and not again. 
B: This method should not be used as this code will be executed when a Continue command is 
sent to a service in a paused state. 
ServiceController class and ServiceControllerPermission class 
D: This method should not be considered as this method will execute when the computer's power 
state has changed. 










QUESTION NO: 125 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing an application that will be used to connect and control the behavior of existing 
services installed on a network server named CERTKILLER-SR01. 

What should you do? 

A. Use the MachineName and ServiceName properties of the ServiceController class. 
B. Use the Site property of the ServiceController class. 
C. Use the Site property of the ServiceInstaller class. 
D. Use the ServiceName and DisplayName properties of the ServiceInstaller class. 




















Answer: A 

Explanation: 

The proper way to connect and control the behavior of existing services is by using the 
ServiceController class after which you are required to set two properties on it to identify the 
service to interact with. The MachineName property is used to define the computer CERTKILLERSR01. 


Incorrect Answers: 

B: The Site property of the ServiceController and ServiceInstaller class should not be used 
because they bind a component to a container and enables communication between them. 
C: The Site property of the ServiceController and ServiceInstaller class should not be used 
because they bind a component to a container and enables communication between them. 
ServiceInstaller and ServiceProcessInstaller class 
D: This property should not be used as it is meant to specify the name of the service at the time of 
installation. The DisplayName property is used to specify the friendly name of the service at the 
time of installation. 










QUESTION NO: 126 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a Windows Service application that consists of two Services. The first service 
monitors a directory for new orders while the other service replicates a database table with up-todate 
information. You are required to develop a project installer class to install these services. 

What should you do? (Choose two) 

A. One ServiceProcessInstaller instance must be Instantiate and add it to the project installer class 
B. Two ServiceInstaller instances must be Instantiate and add them to the project installer class 
C. Two ServiceProcessInstaller instances must be Instantiate and add them to the project installer 
class 
D. One ComponentInstaller instance must be Instantiate and add them to the project installer class 
E. Two ComponentInstaller instances must be Instantiate and add them to the project installer 
class 
F. One ServiceInstaller instance must be Instantiate and add them to the project installer class 




















Answer: A,B 

Explanation: 

The proper way to do what the scenario requires of you would be to create one 
ServiceProcessInstaller instance per service application and one ServiceInstaller instance for each 
service in the application which have to be Instantiate. Incorrect Answers: 

C: You must create one ServiceProcessInstaller instance per service application and one 
ServiceInstaller instance for each service in the application which have to be Instantiate. 
D: The ComponentInstaller class should not be considered for use as this class is an abstract 
class that can not be Instantiate. 
E: The ComponentInstaller class should not be considered for use as this class is an abstract 
class that can not be Instantiate. 
F: You must create one ServiceProcessInstaller instance per service application and one 
ServiceInstaller instance for each service in the application which have to be Instantiate. 










QUESTION NO: 127 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a Windows Service application. You need to change the security context in 
which the service runs. The service will be run in context of a non-privileged user on the local 
computer and present anonymous credentials to any remote server. 

You are required to set the Account property of the ServiceProcessInstaller class to specify the 
service account. 

What should you do? 

A. Use ServiceAccount.User. 
B. Use ServiceAccount.LocalService. 
C. Use ServiceAccount.LocalSystem. 
D. Use ServceAccount.NetworkService. 




















Answer: B 

Explanation: 

The proper way to complete the operation is to use the ServiceAccount.LocalService as the value 
of the Account property of the ServiceProcessInstaller class, setting this value will run the service 
in context of the non-privileged user on the local computer. 

Incorrect Answers: 

A: This method should not be used as you will be specifying the service to run in the security 
context of a specified user account. 
C: This method should not be considered as you will run the service in the security context of a 
highly privileged user account. 
D: The scenario requires the service to run in the security context of a non-privileged user on the 
local system not the network. 










QUESTION NO: 128 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a Windows Service application which contains three different Windows 
services. You are required to only set one Windows service to start automatically when the system 
is restarted. 

What should you do? 

A. Use the ServiceController class. 
B. Use the ServiceBase class. 
C. Use the ServiceProcessInstaller class. 
D. Use the ServiceInstaller class. 




















Answer: D 

Explanation: 

The proper and best way to achieve the scenario would be to use the ServiceInstaller class, the 
StartType property of the ServiceInstaller class allows you to specify how and when a service is 
started. 

Incorrect Answers: 

A: This method used here is incorrect as it can not be used to specify the start type of a Windows 
service. 
B: This method is the base type for all Windows services but does not allow you to specify the 
start type for a Windows service. 
C: This class should not be used because it has a method that affects all services in an 
executable. 










QUESTION NO: 129 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows Service application and are busy writing the 
following installation code for the Windows service: 

<RunInstallerAttribute(True)> Public Class TestServiceInstaller 
Implemets Installer 
'Additional code to go here End Class 

You are required to install the Windows service and write the values associated with the service in 
the Windows Registry. 

What should you do? 

A. The Assembly Registration Tool (Regasm.exe) should be used. 
B. The Global Assembly Cache Tool (Gacutil.exe) should be used. 
C. The .NET Services Installation Tool (Regsvcs.exe) should be used. 
D. The Installer Tool (InstallUtil.exe) should be used. 




















Answer: D 

Explanation: 

The InstallUtil.exe utility is the correct toll that should be used because it will install the classes in 
the specified assembly that derive from the installer class and have the RunInstallArttribute 
attribute set to True. 

Incorrect Answers: 

A: This tool should not be used in the scenario as this tool registers .Net assemblies so that COM 
clients can access .NET classes. 
Thread class 
B: This tool should not be used as it is used to install and uninstall assemblies from the global 
assembly cache. 
ThreadPool class 
C: This tool should not be considered for usage as the tool is used for installing classes for 
Enterprise Services. 










QUESTION NO: 130 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows service application that is used to perform 
several short tasks that require background processing. You are not required to actively manage 
threads in your application but you are required to ensure that security checks are performed 
during the execution of the task. 

What should you do? 

A. Use ThreadPool.queueUserWorkItem. 
B. Use ThreadPool.UnsafeQueueUserWorkItem. 
C. Use Thread.Resume. 
D. Use Thread.Start. 




















Answer: A 

Explanation: 

The scenario requires several short tasks to be run which requires background processing. Using 
the ThreadPool class is ideal in this situation as the system manages the thread pool meaning you 
have less overhead involved. 

Incorrect Answers: 

B: This method should not be considered for use as the security check the scenario requires will 
not be performed. 
C: This method should not be considered because the Thread class is useful for creating threads 
that run in the foreground that are actively managed. 
ThreadStart delegate and ParameterizedThreadStart delegate 
D: This method should not be considered because the Thread class is useful for creating threads 
that run in the foreground that are actively managed. 










QUESTION NO: 131 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application and need to create a foreground 
thread to draw lines in your application. When the thread is started you must provide a data value 
that specifies the number of lines drawn. 

What should you do? (Choose two) 

A. A WaitCallBack delegate should be created 
B. A ThreadStart delegate should be created 
C. A ParameterizedThreadStart delegate should be created 
D. The ThreadStart method should be called 
E. The ThreadPool.QueueUserWorkItem method should be called 




















Answer: C,D 

Explanation: 

The first order of operations would be to create a ParameterizedThreadStart delegate then use the 
ThreadStart method to start the thread. The ThreadStart method can be used to create actively 
managed foreground threads. The Parameterized ThreadStart delegate allows the passing of 
data when starting a thread. Incorrect Answers: 

A: This method should not be used as this method is for executing in a background thread that is 
part od a thread pool. 
B: The ThreadStart delegate should not be used because you first need to pass parameters when 
starting a thread. 
E: The method in this option should not be used because this method is used to create system 
managed background threads. 










QUESTION NO: 132 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows Service application. You write the following 
code: 

Dim CKTimer As Timer = New Timer(statusDelegate, Nothing, 1000, 250) 

You already correctly defined the delegate statusDelegate and are required to modify the code to 
start so that the callback method is not invoked periodically 

What should you do? 

A. Dim CKTimer As Timer = New Timer(statusDelegate, Nothing, Timeout.Infinite, 0) 
B. Dim teTimer As Timer = New Timer(statusDelegate, Nothing, 0, 32767) 
C. Dim teTimer As Timer = New Timer(statusDelegate, Nothing, Timeout.Infinite, 250) 
D. Dim teTimer As Timer = New Timer(statusDelegate, Nothing, 1000, Timeout.Infinite) 




















Answer: D 

Explanation: 

This is the correct method if you do not want the callback method to be called periodically, the 
second last parameter is used to specify when the timer must fire for the first time whilst the last 
parameter indicates the interval for the callback method. 

Incorrect Answers: 

A: The methods in question in the options here should not be used as one option will try the 
callback method after 32767 milliseconds and the other option has a value of infinite meaning the 
callback is never invoked and the timer is disabled. 
B: The methods in question in the options here should not be used as one option will try the 
callback method after 32767 milliseconds and the other option has a value of infinite meaning the 
callback is never invoked and the timer is disabled. 
C: The methods in question in the options here should not be used as one option will try the 
callback method after 32767 milliseconds and the other option has a value of infinite meaning the 
callback is never invoked and the timer is disabled. 











QUESTION NO: 133 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a graphics application. You create a Point class with two Integer fields as 
shown in the exhibit. 

Class Point 
Dim x, y As Integer 

Public Sub New(ByVal x As Integer, ByVal y As Integer) 
Me.x = x 
Me.y = y 
End Sub 
End Class 

You are required to write a method named GetPointPosition that will be used to provide read 
access to the two Integer fields in the class. You must also permit read access to multiple threads 
at the same time whilst your solution results in fast response time and high throughput. 

What should you do? 

A. Private rwlock As ReaderWriterLock 
Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer)

 rwlock.AcquireReaderLock(Timeout.Infinite)

 Try

 x = Me.x

 y = Me.y

 Finally

 rwlock.ReleaseReaderLock()

 End Try 

End Sub 

B. Public Sub GetPointPosition(ByRef X As Integer, ByRef y As Integer) 
SyncLock (Me) 
x = Me.x 
y = Me.y 
End SyncLock 
End Sub C. Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer) 
Dim lockAcquired As Boolean 
lockAcquired = Monitor.TryEnter(Me, 2000) 
If (lockAcquired) Then 
Try 
x = Me.x 
y = Me.y 
Finally 
Monitor.Exit(Me) 
End Try 
End If 
End Sub 

D. Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer) 
Monitor.Enter(Me) 
Try 
x = Me.x 
y = Me.y 
Finally 
Monitor.Exit(Me) 
End Try 
End Sub 





















Answer: A 

Explanation: 

The method chosen in the scenario allows you to design a synchronization scheme that employs 
shared locks together with exclusive locks making it possible to access multiple reader threads at 
the same time. 

Incorrect Answers: 

B: The other methods in questions should not be used as they all have an exclusive locking 
mechanism which does not take into consideration that not all threads are readers or writers. 
C: The other methods in questions should not be used as they all have an exclusive locking 
mechanism which does not take into consideration that not all threads are readers or writers. 
D: The other methods in questions should not be used as they all have an exclusive locking 
mechanism which does not take into consideration that not all threads are readers or writers. 










QUESTION NO: 134 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application class library. You make used of a custom class named TestResource in the application, you create two instances of the TestResource class 
as shown in the exhibit. 

Dim CK1, CK2 As TestResouce 
'Additional code goes here 

You want object CK2 to be assigned to object CK1 if the values of the CK1 object is Nothing. The 
code may be shared by multiple threads. You are required to write code that is thread-safe and 
provides the best performance. 

What should you do? 

A. System.Threading.Monitor.TryEnter(Me) 
If (CK1 Is Nothing) Then CK1 = CK2 
System.Threading.Monitor.Exit(Me) 
B. System.Threading.Interlocked.Exchange(CK1, CK2) 
C. If (CK1 Is Nothing) Then 
SyncLock (Me) 
If (CK1 Is Nothing) Then CK1 = CK2 
End SyncLock 
End If 

D. System.Threading.Interlocked.CompareExchange(CK1, CK2, Nothing) 




















Answer: D 

Explanation: 

The statement used in the answer should be used because the statement performs two operations 
comparison and exchange. The value of the first operand with the third operand if there is a 
match the first operand replaces the second operand. 

Incorrect Answers: 

A: This method should not be used in the scenario because it makes use of two atomic operations 
comparison and exchange where as the CompareExchange method uses just one. 
B: This statement should not be considered for usage as the first operand will always replace the 
second operand. 
C: This method should not be used in the scenario because it makes use of two atomic operations 
comparison and exchange where as the CompareExchange method uses just one. 










QUESTION NO: 135 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You are developing a .NET Framework 2.0 Windows Service application that will be used on a 
multiprocessor system. You are writing code for a class that contains globally accessible Integer 
variable named Testcounter. The value of the Testcounter will be incremented of decremented 
from other classes running in separate threads. 

You are required to provide atomic and non-blocking updates for the Testcounter whilst your 
solution provides the best performance. 

What should you do? 

A. The Interlocked class should be used 
B. The Overlapped class should be used 
C. The SynchronizationContext class should be used 
D. The SyncLock statement should be used 




















Answer: A 

Explanation: 

For this particular scenario the Interlocked class is ideal because you are required to provide 
atomic and non-blocking updates for a data item. 

Incorrect Answers: 

B: This option should not be used in the scenario because it is used to transfer information to 
Win32 API functions. 
C: This operation should not be used as you will not be providing atomic and non-blocking 
updates. 
D: This option should not be used as it does not offer atomic operations and offers inferior 
performance compared to the Interlocked class. 










QUESTION NO: 136 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows Service application. You are required to 
synchronize execution of some resources across multiple processes. 

What should you do? 

A. Use the Mutex class. 
B. Use the Interlocked class. 
C. Use the Monitor class. 
D. Use the ReaderWriterLock class. 




















Answer: A 

Explanation: 

The Mutex class can be used for the synchronization of thread execution across multiple 
processes. 

Incorrect Answers: 

B: The classes in question in these options can not be used in the scenario because they can only 
be used within a single process. 
C: The classes in question in these options can not be used in the scenario because they can only 
be used within a single process. 
D: The classes in question in these options can not be used in the scenario because they can only 
be used within a single process. 










QUESTION NO: 137 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 graphics application and are busy writing a Point class 
with two Integer fields shown below: 

Class Point 

Dim x, y As Integer 

Public Sub New(ByVal x As Integer, ByVal y As Integer) 
Me.x = x 
Me.y = y 
End Sub 

'Additional code goes here 
End Class 

You are required to write a method named GetPointPosition that will be used to provide read 
access to the two Integer fields in the class and prevent inconsistent reads where another reader 
thread would be able to see a Point object at an invalid position. The Point class makes use of 
additional code that other applications may use over which you have no control. You must ensure 
you protect your code against deadlocks. 

What should you do? A. Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer) 
Dim lockAcquired As Boolean 
lockAcquired = Monitor.TryEnter(Me, 2000) 
If (lockAcquired) Then 
Try 
x = Me.x 
y = Me.y 
Finally 
Monitor.Exit(Me) 
End Try 
End If 
End Sub 

B. Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer) 
Monitor.Enter(Me) 
Try 
x = Me.x 
y = Me.y 
Catch 
Monitor.Exit(Me) 
End Try 
End Sub 

C. Public Sub GetPointPosition(ByRef x As Integer, ByRef y As Integer) 
Synclock (Me) 
x = Me.x 
y = Me.y 
End SyncLock 
End Sub 

D. Public Sub GetPointPosition(ByRef x As Integer, ByVal y As Integer) 
Monitor.Enter(Me) 
Try 
x = Me.x 
y = Me.y 
Finally 
Monitor.Exit(Me) 
End Try 
End Sub 





















Answer: A 

Explanation: 

To have your code protected from being deadlocked you should avoid using the SyncLock 
statement and replace calls to Monitor.Enter with calls to Monitor.TryEnter. Incorrect Answers: 

B: If a class instance is access publicly the code is beyond your control and may lock an instance 
in your class which could create deadlocks.Part 3: Create a unit of isolation for common language 
runtime in a .NET Framework application by using application domains. (Refer System 
namespace) 
C: If a class instance is access publicly the code is beyond your control and may lock an instance 
in your class which could create deadlocks.Part 3: Create a unit of isolation for common language 
runtime in a .NET Framework application by using application domains. (Refer System 
namespace) 
D: If a class instance is access publicly the code is beyond your control and may lock an instance 
in your class which could create deadlocks.Part 3: Create a unit of isolation for common language 
runtime in a .NET Framework application by using application domains. (Refer System 
namespace) 










QUESTION NO: 138 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that uses the CreateDomain method of the 
AppDomain class to create an application domain. You are required to set the following properties 
for the new application domain: 

* Root directory 
* Location of the configuration file 
* Search path that the Common Language Runtime uses to load the assemblies into the domain 
You must ensure that these properties values are passed to the CreateDomain method. 

What should you do? 

A. Pass an AppDomainFactory object as a parameter to the CreateDomain method. 
B. Pass an AppDomainIsolatedTask object as a parameter to the CreateDomain method. 
C. Pass an AppDomainHelper object as a parameter to the CreateDomain method. 
D. Pass an AppDomainSetup object as a parameter to the CreateDomain method. 




















Answer: D 

Explanation: 

The correct method for achieving your scenario objective is to pass an AppDomainSetup object as 
parameter to the CreateDomain method. The AppDomainSetup object is used to allow you to 
specify the root directory and required. Incorrect Answers: 

A: This method is used to create a new AppDomain instance for the Web applications and can not 
be used to specify setup information for an application domain. 
B: The method in question here can be used to create build tasks that can be instantiated in their 
own application domain but can not be used to specify setup information. 
C: This method should not be used in the scenario as it switches into the given application domain 
and does a callback on the given function and can not be used to specify setup information. 










QUESTION NO: 139 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that will be used for geographical mapping. 
Whenever you load a plug-in you create a separate application domain. You want to specify a list 
of directories that are searched for private assemblies. You are required to add the application's 
base directory as part of your search and need to configure an application domain to meet the 
requirements. 

What should you do? 

A. The AppDomainSetup.PrivateBinPathProbe property should be used. 
B. The AppDomain.BaseDirectory property should be used. 
C. The AppDomain.DynamicDirectory property should be used. 
D. The AppDomainSetup.PrivateBinPath property should be used. 




















Answer: D 

Explanation: 

The method used in the answer is used to specify a list of directories under the application's base 
directory that are probed for private assemblies. This property must be set to specify the locations 
that should be searched. 

Incorrect Answers: 

A: This property is set to a non-empty value and excludes the ApplicationBase from the searches 
and should not be used. 
B: This method only specifies the base directory for the application domain and does not specify 
all the different locations to be searched for private assemblies. 
Unload an application domain. 
C: This property is used to get the directory that the assembly resolver uses to probe for 
dynamically created assemblies and is a read-only assembly. 
Configure an application domain. 










QUESTION NO: 140 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application class library and decide to use the 
AppDomainSetup class to create an application domain. You are required to create an instance of 
a type named KingSpace.KingType. You are additionally required to configure the new application 
domain so that it probes for the assembly containing the type in a specified directory. 

What should you do? 

A. The ApplicationBase property of the AppDomainSetup class should be used. 
B. The ActivationArguments property of the AppDomainSetup class should be used. 
C. The CachePath property of the AppDomainSetup class should be used. 
D. The AppDomainInitializerArguments property of the AppDomainSetup class should be used. 




















Answer: A 

Explanation: 

It is possible to provide the common language runtime with configuration information for a new 
application domain using the AppDomainSetup class. The most important property is the 
ApplicationBase when creating your own application domains which is used to define the root 
directory of the application. 

Incorrect Answers: 

B: This method is incorrect and should not be used because it sets or gets data about activation of 
an application domain. 
C: This method is incorrect and should not be used because it sets or gets the name of an area 
specific to the application where files are shadow copied. 
D: This method is incorrect and should not be used because it sets or gets AppDomainInitializer 
delegate which represents a callback method. 
Retrieve setup information from an application domain. 










QUESTION NO: 141 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 system utility application and are required to write 
some code that allows you to examine assemblies compiled for other platforms of the .NET 
Framework. You create a new application domain and load assemblies into it. You are required to ensure that code loaded into this context can be examined but not executed. You know the path 
name of the file containing the assembly but you do not know the name of the assembly. 

What should you do? 

A. The Assembly.ReflectionOnlyLoadFrom method should be used. 
B. The Assembly.LoadFrom method should be used. 
C. The Assembly.ReflectionOnlyLoad method should be used. 
D. The Assembly.Load method should have been used. 




















Answer: A 

Explanation: 

The correct method for what is required would be to use the reflection-only load context because 
this allows you to only examine the assembly and not execute it. 

Incorrect Answers: 

B: These methods should not be considered for usage because the methods allow you to execute 
code and create objects. 
C: The method in question should not be considered for usage when you only know the path name 
to where the assembly resides. 
D: These methods should not be considered for usage because the methods allow you to execute 
code and create objects. 










QUESTION NO: 142 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Web application. You need to access the configuration 
data for the application. You do not need read-only access to the configuration data whilst your 
solution provides the maximum performance. 

What should you do? 

A. The GetSection method of the Configuration class should be used 
B. The GetSection method of the ConfigurationManager class should be used 
C. The GetSectionGroup method of the Configuration class should be used 
D. The GetSection method of the WebConfigurationManager class should be used 




















Answer: D 

Explanation: The configuration class in question is designed to programmatically access configuration 
information for Web applications. The GetSection static method retrieves the cached configuration 
information. 

Incorrect Answers: 

A: The method in question does allow programmatic access to all configuration files but it does not 
cache configuration values for the current application. 
B: This should be avoided at all costs as it is best suited for retrieving information for Windows 
client applications. 
C: This method is used to only retrieve specific section groups from the configuration object similar 
to the GetSection method. 










QUESTION NO: 143 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Web application and are busy creating a Configuration 
object in your application that inherits settings from the applications' web.config file and 
machine.config file. You modify several of the Configuration objects settings and want to save the 
Configuration object to a file named testconf.config. You require only the values that differ from the 
inherited values to be written to the configuration file. 

What should you do? (Choose two) 

A. The Save method on the Configuration object should be called 
B. The ConfigurationSaveMode.Full value must be passed as a parameter 
C. The ConfigurationSaveMode.Modified value must be passed as a parameter 
D. The SaveAs method on the Configuration object should be called 
E. The ConfigurationSaveMode.Minimal value should be passed as a parameter 




















Answer: C,E 

Explanation: 

When you are required to write configuration settings to a different file the SaveAs method should 
be called. If you wish to write only values which differ from inherited values the 
ConfigurationSaveMode.Minimal value should be passed as a parameter. 

Incorrect Answers: 

A: This method is used to have the SaveAs method to save all the values to the configuration file 
that you specified in the scenario. 
B: This method is used to have the SaveAs method to only the modified values to the 
configuration file that you specified in the scenario. 
ConfigurationElement class, ConfigurationElementCollection class, and 
ConfigurationElementProperty class 











QUESTION NO: 144 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Web application. You are required to extend the 
standard configuration setting by adding a custom configuration section using the following class: 

Public Class ConfigHandler 

Public Sub New() 

End Sub 

End Class 

You are required to ensure that the class ConfigHandler allows reading and writing to the custom 
configuration section whilst providing strongly typed access to the custom configuration elements. 

What should you do? 

A. The ConfigHandler class must be inherited from the ConfigurationSection class. 
B. The ISettingsProviderService interface must be implemented in the ConfigHandler class. 
C. The IConfigurationSectionHandler interface must be implemented in the ConfigHandler class. 
D. The IApplicationSettingsProvider interface must be implemented in the ConfigHandler class. 




















Answer: A 

Explanation: 

The ConfigurationSection is a new class in .NET Framework 2.0 which should be used as it allows 
you to read and write custom configuration sections. The method in the answer also provides 
strongly typed access to the custom configuration sections. 

Incorrect Answers: 

B: This method is used to provide support for specific application settings that are required by the 
design-time tools and will not help in the scenario. 
Configure which runtime version a .NET Framework application should use. 
C: This is an old method of working with custom configuration sections and does not provide the 
required strongly typed access. 
D: This method is only use full when it comes to Windows client applications and you are busy 
with a Web application. 
Implement ISettingsProviderService interface 











QUESTION NO: 145 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are in the process of maintaining a .NET Framework 1.0 Windows application and need to 
configure the application to run using the .NET Framework 1.1. The network computers of 
CertKiller.com all have three versions of .NET Framework (version 1.0, 1.1, and 2.0 installed side-
by-side. You are required to modify the application configuration file to target the .NET Framework 

1.1 runtime. 
What should you do? 

A. <configuration> 
<startup> 
<supportedRuntime version="v2.0.50727"/> 
<supportedRuntime version="v1.1.4322"/> 
<supportedRuntime version="v1.0.3705"/> 
</startup> 
</configuration> 

B. <configuration> 
<startup> 
<supportedRuntime version="v1.1.4322"/> 
<supportedRuntime version="v1.0.3705"/> 
</startup> 
</configuration> 

C. <configuration> 
<startup> 
<requiredRuntime version="v1.1.4322"/> 
</startup> 
</configuration> 

D. <configuration> 
<startup> 
<supportedRuntime version="v1.1.4322"/> 
</startup> 
</configuration> 





















Answer: D Explanation: 

To have your applications run under the required runtime in the scenario you should use the 
configuration section provided in the answer, this is the only correct method. 

Incorrect Answers: 

A: The method you are trying to use hear is incorrect as you would be executing against .NET 
Framework v2.0. 
B: The method you are trying to use hear is incorrect as you would be executing against .NET 
Framework v1.1. 
C: This method is used to indicate that the application only supports .Net Framework v1.0 and 
should not be used in the scenario. 
Configure where the runtime should search for an assembly. 










QUESTION NO: 146 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application that will make use of an assembly 
named KingAssembly. The assembly file KingAssembly.dll is deployed in a folder named Test20 
under the application root directory. The KingAssembly assembly was not strongly named 

You are required to configure the Windows application to specify the location of the KingAssembly 
assembly whilst any settings that you change not affect other applications installed on the system. 

What should you do? 

A. The application configuration file must be modified to add the following setting to the 
<assemblyBinding> section: 
<probing privatePath="Test20\KingAssembly.dll"/> 
B. The machine configuration file should be modified to add the following setting to the 
<assemblyBinding> section: 
<codeBase href="Test20"/> 
C. The machine configuration file must be modified to add the following setting to the 
<assemblyBinding> section for the KingAssembly assembly: 
<codeBase href="Test20/KingAssembly.dll"/> 
D. The application configuration file should be modified to add the following section to the 
<assemblyBinding> section: 
<probing privatePath="Test20"/> 




















Answer: D Explanation: 

Since the KingAssembly assembly is not strongly named the configuration will have to be made at 
the local level by making use of the application configuration files as is the case in the scenario. 

Incorrect Answers: 

A: The modification of the machine configuration file is incorrect as the assembly in question does 
not have a unique identity and should not be used. 
B: The modification of the machine configuration file is incorrect as the assembly in question does 
not have a unique identity and should not be used. 
C: The path here is incorrect since you only need point to the Test20 path in the scenario. 










QUESTION NO: 147 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application and are busy developing the shared 
assembly called KingSharedObjects which resides in a file named KingSharedObjects.dll, upon 
compiling you store the assembly in the C:\KingSharedObjects\Debug directory. You do not want 
the assembly to be repeatedly installed in the global assembly cache while you develop and 
debug. 

You want the application to load the assembly from its current location by .Net Framework when 
testing whilst any changes made to the system not affect any other applications that are deployed 
or will be deployed. 

What should you do? (Choose two) 

A. C:\SharedObjects\Debug must be put in the PATHEXT environment variable 
B. C:\SharedObjects\Debug must be put in the PATH environment variable 
C. C:\SharedObjects\Debug must be put in the DEVPATH environment variable 
D. The following code should be added to the application configuration file: 
<configuration>

 <runtime>

 <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">

 <probing privatePath="c:\SharedObjects\Debug"/>

 </assemblyBinding>

 </runtime> 

</conmfiguration> 

E. The following code should be added to the machine configuration file: 
<configuration> 
<runtime> 
<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"> <dependantAssembly> 
<assemblyIdentity name="KingSharedObjects" 
publicKeyToken="12ac3ab67e0a34b5" 
culture="en-us"/> 
<codeBase version="2.0.0.0" 
href="KingSharedObjects\Debug"/> 
</dependantAssembly> 
</assemblyBinding> 
</runtime> 


</configuration> 


F. The following code should be added to the machine configuration file: 
<configuration> 
<runtime> 
<developmentMode developerInstallation="true"/> 
</runtime> 

</configuration> 





















Answer: C,F 

Explanation: 

In order for you to achieve the scenario objective you must use the <developmentMode> element 
and set the developerInstallation attribute to "true" this will let .NET Framework search for 
assemblies in the DEVPATH environment variable. 

Incorrect Answers: 

A: This method is incorrect as these environment variables are used by Windows and are not used 
by .NET Framework. 
B: This method is incorrect as these environment variables are used by Windows and are not used 
by .NET Framework. 
D: The usage of the <codeBase> and <probing> elements are incorrect as the one is useful for 
specifying the search path for private assemblies and the other will affect settings of applications 
that are already deployed. 
E: The usage of the <codeBase> and <probing> elements are incorrect as the one is useful for 
specifying the search path for private assemblies and the other will affect settings of applications 
that are already deployed. 










QUESTION NO: 148 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows service application that has three distinct 
Windows services. You create a custom installation class named KingAppInstaller which derives from the Installer class. Within the class you decide to customize installation for each Windows 
service by using the ServiceInstaller objects and add them to the installer collection below: 

Installers.Add(serviceInstaller1) 
Installers.Add(serviceInstaller2) 
Installers.Add(serviceInstaller3) 

You later compile the class and store in a file named KingAppInstaller.dll. You are required to 
programmatically access and install the Windows services in the KingAppInstaller.dll file. 

What should you do? 

A. Use the ManagedInstallerClass class. 
B. Use the ComponentInstaller class. 
C. Use the InstallContext class. 
D. Use the AssemblyInstaller class. 




















Answer: D 

Explanation: 

The AssemblyInstaller class should be used in the scenario because the AssemblyInstaller class 
is capable of loading available installers in an assembly and install them. 

Incorrect Answers: 

A: This class should not be used in the scenario as this is not for the .NET Framework internal 
use. 
B: This method is used to install components such as event logs and performance counters and 
should not be used in the scenario. 
C: This class should not be used because by itself the class can not help install the installers in an 
assembly. 










QUESTION NO: 149 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Remoting application with the name of your class 
KingType and the name of the assembly TestAssembly which will be accessed using the 
Transmission Control Protocol (TCP) at port 1234. You are required to expose KingType as a 
server-activated object for remote access whilst you must use a configuration file to register the 
remote object. 

What should you do? A. <configuration> 
<system.runtime.remoting> 
<application> 
<service> 
<activated type = "KingType, TestAssembly"/> 
</service> 
</application> 
</system.runtime.remoting> 
</configuration> 

B. <configuration> 
<system.runtime.remoting> 
<application> 
<client url="tcp://localhost:1234/KingType.rem"> 
<activated type ="KingType, TestAssembly"/> 
</client> 
</application> 
</system.runtime.remoting> 
</configuration> 

C. <configuration> 
<system.runtime.remoting> 
<application> 
<service> 
<wellknown mode = "Singleton" 
type ="KingType, TestAssembly" 
objectUri="KingType.rem" 
/> 
</service> 
</application> 
</system.runtime.remoting> 
</configuration> 

D. <configuration> 
<system.runtime.remoting> 
<application> 
<client> 
<wellknown type="KingType, TestAssembly" 
url="tcp://localhost:1234/KingType.rem" 
/> 
</client> 
</application> 
</system.runtime.remoting> 
</configuration> 



















Answer: C 

Explanation: 

In order to successfully set up an object for remote access the configuration used in the answer is 
the proper method if you want the object to be activated as a server object. 

Incorrect Answers: 

A: The usage of the <client> element is incorrect as this will be used to configure a program that 
will consume the remote object and in the scenario you must expose an object for remote 
access.Part 3: Manage an event log by using the System.Diagnostics namespace. 
Write to an event log. 
B: The usage of the <client> element is incorrect as this will be used to configure a program that 
will consume the remote object and in the scenario you must expose an object for remote 
access.Part 3: Manage an event log by using the System.Diagnostics namespace. 
D: The usage of the <client> element is incorrect as this will be used to configure a program that 
will consume the remote object and in the scenario you must expose an object for remote 
access.Part 3: Manage an event log by using the System.Diagnostics namespace. 










QUESTION NO: 150 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application for CertKiller.com. You complete the 
application but as soon as CertKiller.com users attempt to log on to the application the application 
fails. You need to have an entry written to the Windows event log. When you look at the event log 
viewer you want the source of the events to be listed as TestApp. You are required to create an 
event source that can be used to write entries to the event log. 

What should you do? 

A. If Not EventLog.SourceExists("TestApp") Then 
EventLog.CreateEventSource("TestApp", "Application") 
End If 

B. EventLog.LogNameFromSourceName("TestApp", "Application") 
C. EventLog.LogNameFromSourceName("TestApp", "Security") 
D. If Not EventLog.SourceExists("TestApp") Then 
EventLog.CreateEventSource("TestApp", "Security") 
End If 





















Answer: A 

Explanation: The code that is used in the answer is the proper code that should be used to create entries into 
the Application event log. 

Incorrect Answers: 

B: The other methods that are used are not correct because the security log is read-only and 
furthermore the LogNameSourceName method returns the name of an event log for the given 
event and does not help in creating an event source. 
C: The other methods that are used are not correct because the security log is read-only and 
furthermore the LogNameSourceName method returns the name of an event log for the given 
event and does not help in creating an event source. 
D: The other methods that are used are not correct because the security log is read-only and 
furthermore the LogNameSourceName method returns the name of an event log for the given 
event and does not help in creating an event source. 










QUESTION NO: 151 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that will be used to capture application 
errors like failure to send e-mail messages are logged in the Windows event log. You are required 
to write only non-localized string messages to the event log. You already previously wrote the 
event source and need to write code to create an entry in the error log. 

What should you do? 

A. Dim failedEvent As EventInstance = New EventInstance(1001, 0, EventLogEntryType.Error) 
Dim messageStrings As Strings() = {"Process1", "Value1"} 
myEventLog.WriteEvent(failedEvent, messageStrings) 
B. Dim messageStrings As String() = {"Process1", "Value1"} 
myEventLog.WriteEntry(String.Join(", ", messageStrings), EventLogEntryType.FailureAudit) 
C. Dim failedEvent As EventInstance = New EventInstance(1001, 0, 
EventLogEntryType.FailureAudit) 
Dim messageStrings As String() = {"Process1", "Value1"} 
myEventLog.WriteEvent(failedEvent, messageStrings) 
D. Dim messageStrings As String() = {"Process1", "Value1"} 
meEventLog.WriteEntry(String.Join(", ", messageStrings), EventLogEntryType.Error) 




















Answer: D 

Explanation: 

The WriteEntry method of the EventLog class should be used in the scenario as this method is 
used to write the localized messages to the event log. The usage of the EventLogEntryType.Error value as a parameter is the proper way to use the WriteEntry method. 

Incorrect Answers: 

A: The other methods in question are not correct as you would be auditing and you are required to 
write to the error log of the Windows event log and should not be considered to use. 
B: The other methods in question are not correct as you would be auditing and you are required to 
write to the error log of the Windows event log and should not be considered to use. 
Read from an event log. 
C: The other methods in question are not correct as you would be auditing and you are required to 
write to the error log of the Windows event log and should not be considered to use. 










QUESTION NO: 152 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 Windows application named TestAnalyzer.exe that will 
be used to monitor the Application event log of the local computer to find if any new events are 
generated by another application named KingNotify.exe which runs on the local computer named 
CERTKILLER-WS11. Whenever a new event log entry is recorded the application must invoke the 
applicationLog_EntryWritten method in response. 


You write the code below for the notification of new event log entries: 


Dim applicationLog As EventLog = New EventLog("Application", ".") 
AddHandler applicationLog.EntryWritten, AddressOf applicationLog_EntryWritten 


When you test the application you discover that there are no notifications generated. You are 
required to ensure that you are notified of a new event log entries. 


What should you do? 


A. The applicationLog.EnableRaisingEvents property must be set to True 
B. The applicationLog.Log property must be set to KingNotify.exe 
C. The applicatioLogMachineName property must be set to CERTKILLER-WS11 
D. The applicationLog EnableRaisingEvents property must be set to False 




















Answer: A 

Explanation: 

The EnableRaisingEvents property of the applicationLog object must be set to true if you want to 
be notified whenever new entries have been written to the specified event log. Incorrect Answers: 

B: This method is incorrect as the Log property should be used to specify the name of the event 
log. 
Retrieve information about the current process. 
C: This is incorrect as this is a redundant operation and the EventLog object is already pointing to 
CERTKILLER-WS11. 
Create a new event log.Part 4: Manage system processes and monitor the performance of a .NET 
Framework application by using the diagnostics functionality of the .NET Framework 2.0. (Refer 
System.Diagnostics namespace) 
Get a list of all modules that are loaded by a process. 
D: This step is almost what you require but the property of the EnableRaisingEvents should be set 
to True. 
PerformanceCounter class, PerformanceCounterCategory, and CounterCreationData class 










QUESTION NO: 153 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that will be used for publishing its own 
custom performance counter. You additionally require the value of a performance counter to 
increase by 5 and must minimize the amount of code needed to write. 

What should you do? 

A. Use the NextValue method. 
B. Use the Decrement method. 
C. Use the Increment method. 
D. Use the IncrementBy method. 




















Answer: D 

Explanation: 

To have the value of a counter decreased by the desired amount the best choice of method 
requiring the least amount of code would be the IncrementBy method. 

Incorrect Answers: 

A: This is the code used to return the value of the counter and should not be used in the scenario. 
B: The method is used if you want to have the value decreased and in the scenario an increase is 
needed. 
C: This method is used to only increase the value of the counter by one and should not be used. 










QUESTION NO: 154 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 time management application that requires opening a 
file namedKingTimeManagement.als programmatically. All the client computers are equipped with 
Microsoft Office and file associations have not been modified after installation of the software. You 
are required to create a ProcessStatInfo object to provide file details to open the file. 

What should you do? 

A. Dim psi As ProcessStartInfo = New ProcessStartInfo("KingTimeManagement.xls", "Excel") 
B. Dim psi As ProcessStartInfo = New ProcessStartInfo("Excel KingTimeManagement.xls") 
C. Dim psi As ProcessStartInfo = New ProcessStartInfo("Excel", "KingTimeManagement.xls") 
D. Dim psi As ProcessStartInfo = New ProcessStartInfo("KingTimeManagement.xls") 




















Answer: D 

Explanation: 

To successfully complete your objective you should use the ProcessStartInfo class that is used to 
specify an application file name with which the process should start. 

Incorrect Answers: 

A: This option should not be used because KingTimeManagement the file to be opened would be 
used as a command line argument. 
B: This method should not be used as the file name Excel KingTime Management.xls will be 
treated as the file name in the scenario. 
C: This option should not be considered for use as Excel would be the file name and 
KingTimeManagement would be a command line argument 










QUESTION NO: 155 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application that provides a user interface 
similar to Microsoft Excel and allows users to manage their expenses. You recently wrote a 
wrapper around the expense management application which performs security checks. If the users 
have the sufficient rights the wrapper application launches the expense management application, 
if no sufficient rights the application should be forced to close. You must decide which method of 
the Process class to use. What should you do? 

A. Use the Kill method. 
B. Use the Close method. 
C. Use the Dispose method. 
D. Use the CloseMainWindows method. 




















Answer: A 

Explanation: 

To successfully have an application forcefully close or shutdown the Kill method should be used 
as it forces an immediate termination of the process. 

Incorrect Answers: 

B: This method should not be used as the Close method is used to free resources associated with 
the application process. 
C: This method should not be used in the scenario as it is generally used to implement cleaning of 
unmanaged resources. 
D: This method should not be used as this method requests that the application be closed and we 
require closing the application forcefully. 










QUESTION NO: 156 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 Windows application that has the following 
configuration settings. 


<system.diagnostics> 
<switches> 
<add name="BolleanSwitch" value="1"/> 
<add name="TraceLevelSwitch" value="1"/> 
</switches> 
</system.diagnostics> 


You started coding your Windows application further by creating switch objects using the following 
statements: 


Dim bs As Boolean Switch = New BooleanSwitch("BooleanSwitch", "Boolean Switch") 
Dim ts As TraceSwitch = New TraceSwitch("TraceLevelSwitch", "Trace Switch") 


You are required to select what the outcome would be of executing the command s in the 
scenario. 

What should you do? (Choose two) 

A. The TraceLevelSwitch switch objects trace level is set to TraceLevel.Info. 
B. The BooleanSwitch switch object is disabled. 
C. The TraceLevelSwitch switch objects trace level is set to TraceLevel.Warning. 
D. The BooleanSwitch switch object is enabled. 
E. The TraceLevelSwitch switch objects trace level is set to TraceLevel.Error. 




















Answer: D,E 

Explanation: 

The Boolean objects can be considered to be either On or Off. The value 0 corresponds to being 
off whereas a non-zero value indicates the objects are On. 

Incorrect Answers: 

A: The usage of the TraceSwitch class is used to provide different levels of tracing switches which 
are defined by the enumeration as Off 0, Error 1, Warning 2, Info 3 and Verbose 4. 
Debug class and Debugger class 
B: The value 1 will have the BooleanSwitch object enabled and a value of 1 will set the 
TraceLevelSwitch objects to have a trace level to TraceLevel.Error. 
Trace class, CorrelationManager class, TraceListener class, TraceSource class, TraceSwitch 
class, XmlWriterTraceListener class, DelimitedListTraceListener class, and EventlogTraceListener 
class 
C: The usage of the TraceSwitch class is used to provide different levels of tracing switches which 
are defined by the enumeration as Off 0, Error 1, Warning 2, Info 3 and Verbose 4. 










QUESTION NO: 157 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 application and write the following code in your King 
program: 


Dim logFile As Stream = File.Create("C:\KingLogFile.txt") 
Dim txtl As TextWriterTraceListner = New TextWriterTraceListner(logFile) 
Trace.Listners.Add(txtl) 
Trace.WriteLine("King Message 1") 
Debug.WriteLine("King Message 2") 
Trace.Flush() 
You need to know what output will be generated in the C:\KingLogFIle.txt file when you run the 
King program in debug mode. 

What should you do? 

A. King Message 1 
B. King Message 2 
C. The C:\KingLogFile.txt file is empty 
D. King Message 1 
King Message 2 




















Answer: D 

Explanation: 

The program if run in debug mode both the Trace and Debug statements will be ewxecuted as 
their object is sent to the listener object. 

Incorrect Answers: 

A: The other mentioned methods are all incorrect because if you run the application in debug 
mode both the Tracer and Debug statements will be executed. 
Retrieve a collection of Management objects by using the ManagementObjectSearcher class and 
its derived classes. 
B: The other mentioned methods are all incorrect because if you run the application in debug 
mode both the Tracer and Debug statements will be executed. 
C: The other mentioned methods are all incorrect because if you run the application in debug 
mode both the Tracer and Debug statements will be executed. 
Debugger attributesPart 6: Embed management information and events into a .NET Framework 
application. (Refer System.Management namespace) 










QUESTION NO: 158 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 console application that will be used to enumerate all 
disk drives on the local computer and list their drive letter and available free space. You are 
required to make use of the functionality in the System.Management namespace to accomplish 
the task. 

What should you do? 

A. Dim tQuery As SelectQuery = New SelectQuery ("Win32_LogicalDisk") 
Dim moSearch As ManagementObjectSearcher = New ManagementObjectSearcher(tQuery) 
For Each mo As ManagementObject In moSearch.Get() 
Console.WriteLine("Drive {0}, Free Space {1}", mo("DeviceID"), mo("NumberOfBlocks")) 
Next 

B. Dim tQuery As SelectQuery = New SelectQuery ("Select *from Win32_LogicalDisk") 
Dim moSearch As ManagementObjectSearcher = New ManagementObject Searcher(tQuery) 
For Each mo As ManagementObject In moSearch.Get() 
Console.WriteLine("Drive {0}, Free Space {1}", mo("DeviceID"), mo("NumberOfBlocks")) 
Next 


C. Dim tQuery As SelectQuery = New SelectQuery ("Select *from Win32_LogicalDisk") 
Dim moSearch As ManagementObjectSearcher = New ManagementObject Searcher(tQuery) 
For Each mo As ManagementObject In moSearch.Get() 
Console.WriteLine("Drive {0}, FreeSpace {1}", mo("Name"), mo("FreeSpace")) 
Next 


D. Dim tQuery As SelectQuery = New SelectQuery ("Win32_LogicalDisk") 
Dim moSearch As ManagementObjectSearcher = New ManagementObjectSearcher(tQuery) 
For Each mo As ManagementObject In moSearch.Get() 
Console.WriteLine("Drive {0}, FreeSpace {1}", mo("Name"), mo("FreeSpace")) 
Next 






















Answer: D 

Explanation: 

The correct way to have your code display what is required in the scenario would be to write the 
code specified in the answer this will list the drive letters and available free space. 

Incorrect Answers: 

A: The usage of the Win32_LogicalDisk management object is incorrect as this will not return the 
drive letter and furthermore the usage of the NumberOfBlocks property should not be used 
because it will return the block size of each disk rather than the free space. 
B: The usage of the Win32_LogicalDisk management object is incorrect as this will not return the 
drive letter and furthermore the usage of the NumberOfBlocks property should not be used 
because it will return the block size of each disk rather than the free space. 
ManagementQuery class 
C: The usage of the Win32_LogicalDisk management object is incorrect as this will not return the 
drive letter and furthermore the usage of the NumberOfBlocks property should not be used 
because it will return the block size of each disk rather than the free space. 










QUESTION NO: 159 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application. You require finding the current IP 
address of the local computer and need to create a SelectQuery object in your application that enables the retrieval of the current IP address. 

What should you do? 

A. Dim tQuery As SelectQuery = New SelectQuery ("SELECT IPAddress FROM _ 
Win32_NetworkAdapterConfiguration ") 
B. Dim tQuery As SelectQuery = New SelectQuery ("SELECT IPXAddress FROM _ 
Win32_NetworkAdapterConfiguration") 
C. Dim tQuery As SelectQuery = New SelectQuery ("SELECT NetworkAddress FROM _ 
Win32_NetworkAdapter") 
D. Dim tQuery As SelectQuery = New SelectQuery ("SELECT MacAddress FROM _ 
Win32_NetworkAdapter") 




















Answer: A 

Explanation: 

The proper way to go in the scenario would be to query the Win32_NetworkAdapterConfiguration 
object as this property is associated with the network adapter configuration. 

Incorrect Answers: 

B: This method should not be used as there is no statement about an IPXAddress in the scenario. 
C: This should not be used as it is an unimplemented method which returns nothing by default. 
Subscribe to management events by using the ManagementEventWatcher class. 
D: This method is used to return the machine address for a network adapter which is a unique 48bit 
id assigned to the network card by the manufacturer. 










QUESTION NO: 160 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application. You are required to 
asynchronously monitor the creation of new Windows processes and write the following code: 

Dim eQuery As WqlEventQuery = New WqlEventQuery("__InstanceCreationEvent", _ 
New TimeSpan(0, 0, 5), "TargetInstance is a ""Win32_Process""") 

Dim meWatcher As ManagementEventWatcher = New ManagementEventWatcher() 
meWatcher.Query = eQuery 

You are in the process of adding additional code for the asynchronous monitor to work and need 
to know which code segment to use. What code segment should you use? (Each correct answer presents part of the solution. Choose 
TWO) 

A. meWatcher.Stop() 
B. Dim mObj As ManagementBaseObject = meWatcher.WaitForNextEvent() 
C. AddHandler meWatcher.EventArrived, AddressOf Process_Created 
D. meWatcher.Start() 




















Answer: C,D 

Explanation: 

The correct method would be for you to start with using the Start method of the 
ManagementEventWatcher class to asynchronously monitor the creation of processes. In order 
for you to receive notifications an event handler should be added. 

Incorrect Answers: 

A: This is the correct method used to have the monitor stop monitoring events. 
B: The usage of the method is used for waiting for when the events occur and leads to 
synchronous processing. 










QUESTION NO: 161 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 class library. You create the classes below: 

Public Class Book 
Public Name As String 
End Class 

Public Class Encyclopedia 
Inherits Book 
Public Volume As Integer 
End Class 

You are required to serialize the objects in the encyclopedia class to a disk file. 

What should you do? 

A. The <Serializable> attribute should be added to the Book class and the <Serializable> attribute 
should be added to the Encyclopedia class 
B. The <Serializable> attribute should be added to the Book class only 
C. The <Serializable> attribute should be added to the Encyclopedia class only 
D. The <Serializable> attribute should be added to the Encyclopedia class and the 
<NonSerialized> attribute should be added to the Name field 




















Answer: A 

Explanation: 

As the Serializable attribute is not inherited by the derived classes you should add the attribute to 
both classes in the scenario. 

Incorrect Answers: 

B: If you only marked one of the classes with the Serializable attribute you would not be capable of 
completing your scenario objective. 
C: If you only marked one of the classes with the Serializable attribute you would not be capable of 
completing your scenario objective. 
SerializationEntry structure and SerializationInfo class 
D: If you configured the application this way the program would return a runtime error, meaning 
this should not be used. 
ObjectManager class 










QUESTION NO: 162 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 application and create the following class in the 
application: 


Public Class Model 
Public Name As String 
End Class 


You are required to deserialize the data in testmodel.xml in an object of the Model type. The 
contents of testmodel.xml sre shown below, if you encounter unknown elements the method 
named Model_Unknown should be executed: 


<?xml version="1.0" encoding="utf-8"?> 
<Model xmlns:xsi="http://www.CertKiller.com/XMLSchema-instance" 
xmlns:xsd="http://www.CertKiller.com/XMLSchema"> 
<Number>123</Number> 
<Name>Model1</Name> 
<Style>Business</Style> 
<Size>Large</Size> 
</Model> 

What should you do? 

A. Private Sub DeserializeModel(ByVal filename As String) 
Dim xSerial As XmlSerializer = New XmlSerializer(GetType(Model)) 
AddHandler xSerial.UnknownElement, AddressOf Model_Unknown 
Using fStream As FileStream = New FileStream(filename, FileMode.Open) 
Dim testModel As Model = CType(xSerial.Deserialize(fStream), Model) 
End Using 
End Sub 

B. Private Sub DeserializeModel(ByVal filename As String) 
Dim xSerial As XmlSerializer = New XmlSerializer(GetType(Model)) 
Using fStream As FileStream = New FileStream(filename, FileMode.Open) 
Dim testModel As Model = CType(xSerial.Deserialize(fStream), Model) 
End Using 
End Sub 

C. Private Sub DeserializeModel(ByVal filename As String) 
Dm xSerial As XmlSerializer = New XmlSerializer(GetType(Model)) 
AddHandler xSerial.UnknownAttribute, AddressOf Model_Unknown 
Using fStream As FileStream = New FileStream(filename, FileMode.Open) 
Dim testModel As Model = CType(xSerial.Deserialize(fStream), Model) 
End Using 
End Sub 

D. Private Sub DeserializeModel(ByVal filename As String) 
Dim xSerial As XmlSerializer = New XmlSerializer(GetType(Model)) 
AddHandler xSerial.UnreferencedObject, AddressOf Model_Unknown 
Using fStream As FileStream = New FileStream(filename, FileMode.Open) 
Dim testModel As Model = CType(xSerial.Deserialize(fStream), Model) 
End Using 
End Sub 





















Answer: A 

Explanation: 

The proper way to achieve the scenario objective is shown in the answer, the UnknownElement 
event will be raised when the XmlSerializer encounters an XML element such as number, style 
and size. 

Incorrect Answers: 

B: The other events should not be considered for use in the scenario because the 
UnknownAttribute event is raised when such an event is encountered. Further more the 
UnreferencedObject should not be used as this event is raised when types are encountered that 
are not being used. 
Control serialization by using serialization attributes. 

C: The other events should not be considered for use in the scenario because the 
UnknownAttribute event is raised when such an event is encountered. Further more the 
UnreferencedObject should not be used as this event is raised when types are encountered that 
are not being used. 
D: The other events should not be considered for use in the scenario because the 
UnknownAttribute event is raised when such an event is encountered. Further more the 
UnreferencedObject should not be used as this event is raised when types are encountered that 
are not being used. 










QUESTION NO: 163 

You work as an application developer at CertKiller.com. You have just completed the creation of 
an application that receives order data from CertKiller.com's partner company in XML format. 


The XML has to be utilized to create an Order object that is consumed by the new application. 


The following exhibit displays an example of CertKiller.com's partner company's XML data: 


<?xml version="1.0" encoding="utf-8"?> 
<Order id="101"> 
<Shipping> 
<Instructions> 
Come to front door and ring door bell. 
No other options. 
</Instructions> 
<Address> 
<Street>536 CertKiller Lane</Street> 
<City>Miami</City> 
<State>FL</State> 
<Zip>70536</Zip> 
</Address> 
</Shipping> 
<Date>2006-07-12T00:00:00-04:00</Date> 
<Details> 
<SalesProduct InStock="true" Taxable="true"> 
<Name>Lounge Suite</Name> 
<Quantity>1</Quantity> 
<Price>200.00</Price> 
</SalesProduct> 
<Product InStock="false"> 
<Name>Plasma Television</Name> 
<Quantity>2</Quantity> 
<Price>26.999.00</Price> 
</Product> 
</Details> 
</Order> 


You plan to use the XmlSerializer class to deserialize the XML data into an Order object. When 
you learn that CertKiller.com's partner company's XML also contains Shipping object data, you 
decide to deserialize the shipping object after the Shipping element is detected during 
deserialization. 


To achieve this, you need to use a certain event of the XmlSerializer class. 


What event should you use? 


A. UnknownElement 
B. UnknownNode 
C. UnreferencedObject 
D. UnknownAttribute 




















Answer: B 

Explanation: 

The UnknownNode event is fired when an unexpected element or node is detected that does not 
map to the XmlSerializer object's expected type. The UnknownNode event included the 
XmlNodeEventArgs , which allows access to the entire node of the XML data. This would allow 
easy deserialization for the Shipping object. 

Incorrect Answers: 

A: These options would not allow easy deserialization for the Shipping object. 
C: These options would not allow easy deserialization for the Shipping object. 
D: These options would not allow easy deserialization for the Shipping object. 










QUESTION NO: 164 

You work as the application developer at CertKiller.com. You make use of Visual Studio 2005 as 
your application development platform. 

You are developing a .NET Framework 2.0 application and write the code below as your own 
code: 

Public Class Book Public Name As String 
End Class 


Public Class Library 
<XmlAray("ID1")> _ 
<XmlArayItem("ID2")> _ 
Public Book As Book() 
End Class 


You are required to create an object of the Library type and serialize it to disk in a file named 
CertKillerbooks.xml and write the following code: 


Dim books As Book() = New Book() {New Book(), New Book(), New Book()} 
books(0).Name = "Book Name 1" 
books(1).Name = "Book Name 2" 
books(2).Name = "Book Name 3" 


Dim library As Library = New Library() 
library.Books = books 


Dim CKSerializer As XmlSerializer = New XmlSerializer(GerType(library)) 
Using CKWriter As StreamWriter = New StreamWriter("CertKillerbooks.xml") 
CKSerializer.Serialize(CKWriter, library) 
End Using 


You are required to choose from the following selection which output will be generated by the 
program. 


What should you do? 


A. <Library> 
<ID1> 
<Book> 
<ID2>Book Name 1</ID2> 
</Book> 
<Book> 
<ID2>Book Name 2</ID2> 
</Book> 
<Book> 
<ID2>Book Name 3</ID2> 
</Book> 
</ID1> 
</Library> B. <Library> 
<Books> 
<ID1> 
<ID2>Book Name 1</ID2> 
</ID1> 
<ID1> 
<ID2>Book Name 2</ID2> 
</ID1> 
<ID1> 
<ID2>Book Name 3</ID2> 
</ID1> 
</Books> 
</Library> 

C. <Library> 
<ID2> 
<ID1> 
<Name>Book Name 1</Name> 
</ID1> 
<ID1> 
<Name>Book Name 2</Name> 
</ID1 
<ID1> 
<Name>Book Name 3</Name> 
</ID1> 
</ID2> 
</Library> 

D. <Library> 
<ID1> 
<ID2> 
<Name>Book Name 1</Name> 
</ID2> 
<ID2> 
<Name>Book Name 2</Name> 
</ID2> 
<ID2> 
<Name>Book Name 3</Name> 
</ID2> 
</ID1> 
</Library> 





















Answer: D Explanation: 

The proper and best way for you to achieve your scenario objective would be to use the code 
specified in the answer this will serialize the required data into the CertKillerbooks.xml file. 

Incorrect Answers: 

A: The other mentioned methods should not be considered for use as they will most likely change 
the name of the array element to which it is applied. 
SoapFormatter class (Refer System.Runtime.Serialization.Formatters.Soap namespace) 
B: The other mentioned methods should not be considered for use as they will most likely change 
the name of the array element to which it is applied. 
BinaryFormatter class (Refer System.Runtime.Serialization.Formatters.Binary namespace) 
C: The other mentioned methods should not be considered for use as they will most likely change 
the name of the array element to which it is applied. 
Implement XML Serialization interfaces to provide custom formatting for XML serialization. 










QUESTION NO: 165 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 remoting application. Your computer system relies on 
run-time type validation. You are required to deserialize a remote stream by using the 
BinaryFormatter class in your application whilst you configure the BinaryFormatter object to 
protect against any deserialization attacks by deserializing only certain types associated with only 
the most basic remoting functionality. 

What should you do? 

A. The TypeFormat property should be set to FormatterTypeStyle.TypesAlways 
B. The TypeFormat property should be set to FormatterTypeStyle.TypesWhenNeeded 
C. The FilterLevel property should be set to TypeFilterLevel.Full 
D. The FilterLevel property must be set to TypeFilterLevel.Low 




















Answer: D 

Explanation: 

The best choice for you in the scenario would be to use the FilterLevel property of the 
BinaryFormatter object set to TypeFilter.Low which deserializes only the most basic remoting 
functionality helping to protect against deserialization attacks. 

Incorrect Answers: 

A: The setting can not be used to set the deserialization of types because it just configures how 
the types are laid out in the deseriliazation stream. 
B: The setting can not be used to set the deserialization of types because it just configures how 
the types are laid out in the deseriliazation stream. 

C: This setting should no be used as you will be deserializing all types and this offers no protection 
against deserialization attacks in the scenario. 










QUESTION NO: 166 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 geographical information system for the company and 
create a class named CertKillerCode. You are required to serialize all public and non-public data 
of the CertKillerCode class whilst you ensure that you produce the smallest byte stream so that 
the smallest load is placed upon network resources. 

What should you do? 

A. The XmlSerializationWriter class should be used 
B. The XmlSerializer class should be used 
C. The BinaryFormatter class should be used 
D. The SoapFormatter class should be used 




















Answer: C 

Explanation: 

To successfully serialize all the public and non-public data you should make use of the 
BinaryFormatter class because in addition the BinaryFormatter class produces the most compact 
byte stream compared to other serialization classes. 

Incorrect Answers: 

A: The XmlSerializer class should not be used as this class only serializes public properties and 
fields and the XmlSerializationWriter class is used to controls serialization by using the 
XmkSerialization class and fails to meet requirements. 
File class and FileInfo class 
B: The XmlSerializer class should not be used as this class only serializes public properties and 
fields and the XmlSerializationWriter class is used to controls serialization by using the 
XmkSerialization class and fails to meet requirements. 
Directory class and DirectoryInfo class 
D: The SoapFormatter class could be used as it will allow you to serialize public and non-public 
data but the result of the stream will be a verbose and will consume more network resources.Part 
4: Access files and folders by using the File System classes. (Refer System.IO namespace) 










QUESTION NO: 167 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 resource management utility. You write the code below 
as part of your program: 

Dim CKDirInfo As DirectoryInfo = New DirectoryInfo("c:\CK_Docs1") 

CKDirInfo.MoveTo("d:\CK_Docs 2") 

Both of the required folders exist when you run the application and the code has the required 
permissions to work with c:\Test1 and c:\King2. You are required to select the outcome when you 
execute your application. 

What should you do? 

A. The c:\CK_Docs1 directory will be moved within the d:\CK_Docs 2 to become d:\CK_Docs 
2\CK_Docs 1. 
B. The c:\ CK_Docs1 directory will be renamed to d:\ CK_Docs2. 
C. An Argument exception will be thrown by the code. 
D. An IOException will be thrown by the code. 




















Answer: D 

Explanation: 

In the scenario the target directory already exists therefore the method in question will throw an 
IOException as it wants to create the folder. 

Incorrect Answers: 

A: This will not be the outcome of the situation you should have specified c:\King2\Test1 as the 
target directory then this would be correct. 
B: The Directory will only be renamed if the target does not exist in the scenario the targets exists. 
C: This will only be thrown if in the event the target directory is an empty string. 
DriveInfo class and DriveType enumeration 










QUESTION NO: 168 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 financial application and are busy developing a module 
that backs up the critical data on a separate hard drive. You are required to decide which properties of the DriveInfo class to use and find the type of file system like FAT or NTFS and the 
drive free space and the user disk quota should be ignored by the application. 

What should you do? 

A. Use the DriveFormat and TotalFreeSpace properties of the DriveInfo class. 
B. Use the DriveType and AvailableFreeSpace properties of the DriveInfo class. 
C. Use the VolumeLabel and TotalSize properties of the DriveInfo class. 
D. Use the DriveType and TotalSize properties of the DriveInfo class. 
E. Use the DriveFormat and AvailableFreeSpace properties of the DriveInfo class. 




















Answer: A 

Explanation: 

The only choice that would work with your requirement is the DriveFormat and TotalFreeSpace 
properties of the DriveInfo class; this will display what you need. 

Incorrect Answers: 

B: The DriveType property should not be used as it only specifies whether the drive is a DVD 
ROM or fixed drive etc. The AvailableFreeSpace property should also not be used as the user disk 
quota would be taken into account. 
C: The VolumeLabel property should not be used in the scenario as it is used to give a name to 
the fixed disk.The TotalSize property should also not be used as it will specify the entire disk 
space not just free space. 
D: The DriveType property should not be used as it only specifies whether the drive is a DVD 
ROM or fixed drive etc. 
FileSystemInfo class and FileSystemWatcher class 
E: The AvailableFreeSpace property should not be used as the user disk quota would be taken 
into account. 










QUESTION NO: 169 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 resource management utility that will be used to 
monitor for the creation of a file with the .res extension in c:\CK_Doc1. When such a file is created 
you will execute code to read and process its contents. You are required to write the code that 
enables you to monitor the creation of the .res file. 

What should you do? (Choose two) 

A. Dim CKWatcher As FileSystemWatcher = New FileSystemWatcher() 
CKWatcher.Path = "c:\CK_Docs1" 
CKWatcher.Filter = "*.res" 

B. CKWatcher.WaitForChanged(WatcherChangeTypes.Created) 
C. CKWatcher.NotifyFilter = NotifyFilters.CreationTime 
D. CKWatcher.EnableRaisingEvents = True 
E. Dim CKWatcher As FileSystemWatcher = New FileSystemWatcher() 
CKWatcher.Filter = c:\CK_Docs1\*.res" 




















Answer: A,B 

Explanation: 

The firs step will be to create the FileSystemWatcher object and set its path and filter properties 
and finally the WaitForChanged method should be invoked in the scenario this will let you achieve 
your objective. 

Incorrect Answers: 

C: This method should not be used in the scenario as it is used to specify which of the notification 
events are invoked in the scenario when a file is changed. 
D: This property should only be created when you have coded event handlers in the scenario that 
is the only time this method would be use full. 
E: This method should not ever be considered for use in the scenario because the filter property is 
used to specify the file pattern only the path should not be included there. 
Path class 










QUESTION NO: 170 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 data analysis application. You have no information 
about the inherent structure of a file when it is supplied to the program for reading data. You are 
required to read the contents of the file byte-by-byte and make use of a custom algorithm to find its 
format whilst selecting a class that allows you to read the files contents byte-by-byte. 

What should you do? 

A. Use the FileStream class. 
B. Use the BinaryReader class. 
C. Use the StreamReader class. 
D. Use the StringReader class. 




















Answer: A 

Explanation: The purpose and function of the FileStream class is to allow the user to be able to view the 
required files byte-by-byte. 

Incorrect Answers: 

B: The BinaryReader class is use full if you know the binary format for the data to read but should 
not be considered for use in the scenario. 
C: This method is use full if you want to read character data in a particular encoding, but is not 
useful for reading any other data. 
D: This class is used for reading text from a string and is not use full for reading any other data. 










QUESTION NO: 171 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 text-processing application. You have access to an 
array of bytes named CKArray that contains your data. You are busy writing code that will be used 
to write the contents of the array to a disk file. If you are done with the write operation you also 
display the contents of the stream on the console to make sure that the write operation completes 
successfully. The code segment to read and write from the stream is shown below and the line 
numbers are reference only: 

01: Using fStream As FileStream = New FileStream("CKFile.txt", FileMode.Create) 
02: For i As Integer = 0 To CKArray.Length 
03: fStream.WriteByte(CKArray(i)) 
04: Next i 
05: 'Add code segment here 
06: For i As Integer = 0 To fStream.Length 
07: Console.WriteLine(fStream.ReadByte()) 
08: Next i 
09: End Using 
You add the appropriate code at line 05 to correctly print the contents of the stream. 

What segment should you add? 

A. fStream.Seek(0, SeekOrigin.End) 
B. fStream.Position = fStream.Length 
C. fStream.Seek(0, SeekOrigin.Current) 
D. fStream.Seek(0, SeekOrigin.Begin) 




















Answer: D Explanation: 

Because after every write operation is completed you need to reposition the stream so that you 
can read the contents from the beginning which is done with the statement in the answer, the first 
parameter will specify the offset, the second the reference point for the seek operation and the 
value SeekOrigin.Begin indicates that the reader should be positioned at the beginning of the 
stream. 

Incorrect Answers: 

A: The method in the statement is incorrect because you are referencing the end or the current 
part of the stream which you are trying to manipulate. 
B: This statement should not be used because it sets the current position of the stream to its 
length effectively referencing the end of the stream. 
Stream class 
C: The method in the statement is incorrect because you are referencing the end or the current 
part of the stream which you are trying to manipulate. 
MemoryStream class 










QUESTION NO: 172 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 banking Windows Forms application and are busy 
working on a function that retrieves the images of cancelled checks and displays them on the 
from. You currently have access to a method that reads the images from Microsoft SQL server as 
a series of bytes. You are required to select a class that allows you to transfer the image from SQL 
Server to the Windows Forms application whilst your solution reduces the need of a temporary 
buffers and files 

What should you do? 

A. Use the MemoryStream class. 
B. Use the NetworkStream class. 
C. Use the FileStream class. 
D. Use the BufferedStream class. 




















Answer: A 

Explanation: 

With the given scenario objective you should use the MemoryStream class which allows you to 
read the image data in memory and stream it to a Windows Forms application without creating any 
temporary buffers or files. Incorrect Answers: 

B: There is no connection established directly to the SQL Server database so using this option is 
out of the question. 
C: The streaming class in question in this option is incorrect because both require the creation of 
temporary files or buffers. 
D: The streaming class in question in this option is incorrect because both require the creation of 
temporary files or buffers. 
BufferedStream classPart 6: Manage the .NET Framework application data by using Reader and 
Writer classes. (Refer System.IO namespace) 










QUESTION NO: 173 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 


You are developing a .NET Framework 2.0 text manipulation application. You make use of the 
code below in your application: 


Dim CKBuilder As StringBuilder = New StringBuilder(":string:") 
Dim b() As Char = {"a"c, "b"c, "c"c, "d"c, "e"c, "f"c, "g"c} 
Dim CKWriter As StringWriter = New StringWriter(CKBuilder) 
CKWriter.Write(b, 0, 3) 
Console.WriteLine(CKBuilder) 
CKWriter.Close() 


You are required to select from the following what the output will be when you execute the 
application. 


What should you do? 


A. :string:abcdefg 
B. abc:string: 
C. abcstring 
D. :string:abc 




















Answer: D 

Explanation: 

Since the specific overload of the Write method takes character array and reads three characters 
starting from the index 0 and appends them to the underlying StringBuilder object this is the proper 
choice in the scenario. Incorrect Answers: 

A: Both of the streams are incorrect and should not be used because the StringWriter is sequential 
and will not go back and overwrite the characters that already exist in the underlying StringBuilder 
object. 
B: This is the incorrect response because the characters will append to the end of the underlying 
StringBuilder object in the scenario. 
TextReader class and TextWriter class 
C: Both of the streams are incorrect and should not be used because the StringWriter is sequential 
and will not go back and overwrite the characters that already exist in the underlying StringBuilder 
object. 
StreamReader class and StreamWriter class 










QUESTION NO: 174 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 graphical analysis application. You are about to save a 
graphical object from the application which is a collection of x and y points, each represented by 
using a single precision floating point number. You are required to keep the disk space usage to a 
minimum by the saved object. 

What should you do? 

A. Use the TextWriter class. 
B. Use the StreamWriter class. 
C. Use the StringWriter class. 
D. Use the BinaryWriter class. 




















Answer: D 

Explanation: 

The BinaryWriter class is used to store data in a binary format, which is used to provide the most 
compact format for storing data among the given classes. 

Incorrect Answers: 

A: The classes in question all save or store data in the text format, which will require more space 
than the binary format and therefore should not be used in the scenario.Part 7: Compress or 
decompress stream information in a .NET Framework application (refer System.IO.Compression 
namespace), and improve the security of application data by using isolated storage. (Refer 
System.IO.IsolatedStorage namespace) 
IsolatedStorageFile class 
B: The classes in question all save or store data in the text format, which will require more space 
than the binary format and therefore should not be used in the scenario.Part 7: Compress or 
decompress stream information in a .NET Framework application (refer System.IO.Compression 
namespace), and improve the security of application data by using isolated storage. (Refer 
System.IO.IsolatedStorage namespace) 

C: The classes in question all save or store data in the text format, which will require more space 
than the binary format and therefore should not be used in the scenario.Part 7: Compress or 
decompress stream information in a .NET Framework application (refer System.IO.Compression 
namespace), and improve the security of application data by using isolated storage. (Refer 
System.IO.IsolatedStorage namespace) 










QUESTION NO: 175 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application that uses a shared assembly 
personalizing the user interface of the application. The assembly in question is used by several 
other applications on the user's computer and any changes made to the user preferences in one 
application should be carried over to other applications. You are required to access the user's 
preferences for displaying the user interface. 

What should you do? 

A. The IsolatedStorageFile.GetUserStoreForDomain method should be used 
B. The IsolatedStorageFile.GetMachineStoreForDomain method should be used 
C. The IsolatedStorageFile.GetMachineStoreForAssembly method should be used 
D. The IsolatedStorageFile.GetUserStoreForAssembly method should be used 




















Answer: D 

Explanation: 

To successfully read the user's preferences you should make use of the 
IsolatedStorageFile.GetUserStoreForAssembly method should be used. The method retrieves 
assembly-specific and user-specific data from the isolated storage. 

Incorrect Answers: 

A: This method should not be used in the scenario as it is designed too retrieve isolated storage 
that is application domain and assembly specific. 
B: The settings in question should not be used because the methods are machine-scoped rather 
than user scoped. 
IsolatedStorageFileStream class 
C: The settings in question should not be used because the methods are machine-scoped rather 
than user scoped. 
DeflateStream class 











QUESTION NO: 176 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS554. You write the 
following code in the application line numbers are for reference only: 

01: Public Function ProcCount() As Integer 
02: Dim envPerm As EnvironmentPermission = _ 
03: New EnvironmentPermission( _ 
04: EnvironmentPermissionAccess.Read, _ 
05: "NUMBER_OF_PROCESSORS") 
06: 'Add code segment here 
07: Return Environment.ProcessorCount 
08: End Function 
The ProcCount method in the code will be used to return the number of processors on the 
computer running the code and the implementation of the method is completely transparent to the 
callers of the methods. You ensured that the ProcCount method has been granted permission to 
access environment variables and the callers to the code may not have permission to access the 
variables. 

The classes in the other assemblies are required to be able to successfully call the ProcCount 
method. You must add code at line 06 to override the security check whilst you ensure that any 
code you write does not affect the permissions that your code already has. 

What code segment should you add? 

A. envPerm.PermitOnly() 
B. envPerm.Demand() 
C. encPerm.Deny() 
D. envPerm.Assert() 




















Answer: D 

Explanation: 

The envPerm.Assert() method should be used in the scenario because the method allows your 
code and any code that you call to perform actions that your code has permissions to perform however the callers may not have permissions to perform. 

Incorrect Answers: 

A: The PermitOnly method should not be used in the scenario because it will result to the same 
action as calling Deny on all permissions other than the permission P and this will affect other 
permissions. 
B: This method should not be considered for use in the scenario because the Demand method 
requires all the callers to have permissions to perform the specific action. 
C: The Deny method should not be considered for usage in the scenario because the method will 
explicitly cause the Permission P to be denied and you are required to ensure permissions are 
applied to the code. 
Modify the Code Access security policy at the computer, user, and enterprise policy level by using 
the Code Access Security Policy tool (Caspol.exe). 










QUESTION NO: 177 

You work as an application developer at CertKiller.com. A fellow developer named Amy Walsh 
recently created an assembly that implements a custom permission set. 

CertKiller.comhas asked you to test this assembly. You start by copying the assembly to a test 
server named CERTKILLER-SR15 that has the Microsoft .NET 2.0 Framework installed. You then 
log on to the CERTKILLER-SR15 as a member of the local Administrators Windows group. 

You run the assembly, and receive a security exception. You perform a brief analysis of the 
security issues involved, and find that the assembly has not been assigned the appropriate 
permissions to run. 

You need to ensure that this assembly runs. 

What should you do? 

A. Use the permview.exe tool to modify the assembly's granted permissions. 
B. Use the sn.exe tool to modify the assembly's granted permissions. 
C. Use the caspol.exe tool to modify the assembly's granted permissions. 
D. Use the gacutil.exe tool to modify the assembly's granted permissions. 




















Answer: C 

Explanation: 

The caspol.exe command-line tool allows users to modify security permissions, permission sets, 
and code groups for an assembly at the machine, user, and enterprise policy levels. 

Incorrect Answers: A: The permview.exe tool only allows users to view declarative security of an assembly. 
B: The sn.exe tool allows developers to create a strong-named asymmetric key pair for strong-
named assemblies. 
D: The gacutil.exe tool allows users to manage the contents of the global assembly and download 
cache. 










QUESTION NO: 178 

You work as an application developer at CertKiller.com. CertKiller.com has a test server named 
CERTKILLER-SR09 that is frequently used by other CertKiller.com developers to test assemblies 
and applied security policies. 

You have just completed creating an assembly and want to test it on CERTKILLER-SR09.you 
need to ensure that all security policies on CERTKILLER-SR09 are reset to their default settings. 

What should you do? 

A. Run the caspol all -rollback command. 
B. Run the caspol all -reset command. 
C. Run the machine all -rollback command. 
D. Run the machine all -reset command. 




















Answer: B 

Explanation: 

The caspol.exe command-line tool allows users to modify security permissions, permission sets, 
and code groups for an assembly at the machine, user, and enterprise policy levels. The reset 
switch will set the specified security policy or policies back to their default state. The all switch 
refers to machine, user, and enterprise policy levels. 

Incorrect Answers: 

A: The rollback switch does not exist for the caspol.exe tool. 
C: The rollback switch does not exist for the caspol.exe tool. 
D: This option will not set all security policies back to their default state. 










QUESTION NO: 179 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application and are about to examine the code groups 
in machine, user, and enterprise policies. The user security policy file is located in 
c:\CertKiller\config\CertKillerSecurity.config and belongs to a user other than the currently logged on user. 

You are required to use code access security policy tool to inspect the security policy and need 
the required command. 

What should you do? 

A. Run the caspol -customall -resolvegroup "c:\CertKiller\config\CertKillerSecurity.config" 
command. 
B. Run the caspol -customer "c:\CertKiller\config\CertKillerSecurity.config" -listgroups command. 
C. Run the caspol -customer -resolvegroup "c:\CertKiller\config\CertKillerSecurity.config" 
command. 
D. Run the caspol -customall "c:\CertKiller\config\CertKillerSecurity.config" -listgroups command. 




















Answer: D 

Explanation: 

Since the -customall option is used to specify that the command applies to the enterprise, machine 
and custom user policy stored in the "c:\CertKiller\config\CertKillerSecurity.config file making this 
the correct option to use in the scenario. The -listgroup option is used to specify the code groups 
in the specified policies that need to be listed. 

Incorrect Answers: 

A: The usage of the -resolvegroup option in the scenario is incorrect because the -resolvegroup 
option is used to show the code groups that the specified user belongs to. 
B: The option in question in this answer should not be used in the scenario because the option is 
used to specify only the code groups of the specified user policy. 
C: The usage of the -resolvegroup option in the scenario is incorrect because the -resolvegroup 
option is used to show the code groups that the specified user belongs to. 










QUESTION NO: 180 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You create an 
assembly that implements a custom security object. The assembly resides in the CKPerm.exe file. 
The CKPerm.exe references the classes in the BasePerm.exe assembly. You are required to write 
a script that will be used to add the assembly to the full trust assembly list of the currently logged 
on user whilst the user will never have write access to the machine policy file. 

What should you do? (Choose two) A. Run the caspol -addfulltrust CKPerm.exe command. 
B. Run the caspol -addfulltrust BasePerm.exe command. 
C. Run the caspol -enterprise -addfulltrust BasePerm.exe command. 
D. Run the caspol -enterprise -addfulltrust CKPerm.exe command. 
E. Run the caspol -machine -addfulltrust BasePerm.exe command. 
F. Run the caspol -machine -addfulltrust CKPerm.exe command. 




















Answer: A,B 

Explanation: 

The caspol.exe tool is used to allow you to modify the code access security policy at the user 
level, machine level as well as the enterprise level and using the -addfulltrust option adds an 
assembly that implements a custom security object to a list of fully trusted assemblies. 

Incorrect Answers: 

C: In the event that there is no policy level specified the caspol.exe tool checks if the user has 
write permission to the machine policy file if so the machine level security policy will be used other 
wise the user-level policy will be used. 
D: In the event that there is no policy level specified the caspol.exe tool checks if the user has 
write permission to the machine policy file if so the machine level security policy will be used other 
wise the user-level policy will be used. 
E: In the event that there is no policy level specified the caspol.exe tool checks if the user has 
write permission to the machine policy file if so the machine level security policy will be used other 
wise the user-level policy will be used. 
F: In the event that there is no policy level specified the caspol.exe tool checks if the user has 
write permission to the machine policy file if so the machine level security policy will be used other 
wise the user-level policy will be used. 










QUESTION NO: 181 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on a CERTKILLER-WS536. You must add 
a new code group which adds FullTrust permissions to the code originating from 
www.CertKiller.com. You are required to use the code access security policy tool (Caspol.exe to 
add the code group whilst you ensure that you only affect the user level policy for the user running 
Caspol.exe 

What should you do? A. Run the caspol -user -addgroup -site www.CertKiller.com FullTrust command. 
B. Run the caspol -user -addgroup -zone Internet command. 
C. Run the caspol -user -addgroup -url www.CertKiller.com FullTrust command. 
D. Run the caspol -user -addgroup -pub -cert test.cer FullTrust command. 




















Answer: A 

Explanation: 

The correct thing to do in the scenario would be to make use of the segment that used -user to 
specify only the user level policy, the -addgroup argument to add a new code group to the code 
hierarchy and the -site argument that targets code that originated only from www.CertKiller.com. 

Incorrect Answers: 

B: This method should not be used in the scenario because it is used to simply add a new code 
group that is a member of the Internet Zone. 
AccessRule class 
C: This command should not be used in the scenario because it should be used to specify a 
complete url including the protocol like http:// etc. 
AuthorizationRule class and AuthorizationRuleCollection class 
D: The command should not be used in the scenario as the method does not specify a Web site 
and the -pub argument is used to identify the software publisher. 
PermissionSet class and NamedPermissionSet class 
CommonAce class, CommonAcl class, CompoundAce class, GeneralAce class, and GeneralAcl 
class 










QUESTION NO: 182 

You work as an application developer at CertKiller.com. CertKiller.com has been contracted by a 
local doctor's clinic to develop a client application using Microsoft .NET 2.0 that sends patient visit 
information to a remote server at the clinic's main office. 

This data must be transmitted via a secure network stream because it contains patient protected 
health information (PHI). The data will be sent from a windows application client on the doctor's 
notebook computer to a windows service hosted on a remote server. Both of these applications 
employ a certificate store for network identification. 

You need to create a secure data stream by adding certain classes to the client application. 

What classes should you add? (Choose three) 

A. The MD5CryptoServiceProvider class. 
B. The X509Certificate class. 
C. The NetworkStream class. 
D. The SslStream class. 
E. The TcpListener class. 
F. The TcpClient class. 




















Answer: B,D,F 

Explanation: 

You should use the X509Certificate class to store the server certificate and encrypt data, the 
SslStream class to create a secure channel, and the TcpClient class to establish the connection 
with the server application. 

Incorrect Answers: 

A: Using this option would only hash the data using the MD5 algorithm. 
DES class and DESCryptoServiceProvider class 
C: Using this option would not necessarily create a secure channel. 
DSA class and DSACryptoServiceProvider class 
E: This class is used by the server application.Part 4: Encrypt, decrypt, and hash data by using the 
System.Security.Cryptography classes. (Refer System.Security.Cryptography namespace) 
TripleDES and TripleDESCryptoServiceProvider class 










QUESTION NO: 183 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that will be used for transmitting contents 
over the Internet. You need to encrypt a data file before transmitting the file. The encryption is 
required to prevent any spoofing of the identity of the publisher of the data file. You decide to sign 
the data using the publisher's private key. You encrypt the data with the publisher's public key as 
well. 

The receiver of the file will use a private key that only he knows to decrypt the data and the 
receiver has access to the publisher's public key also. The intended receiver of the file should be 
able to decrypt the encrypted file after it was received through the Internet transmission whilst the 
receiver should additionally be able to detect if the contents of the data file were tampered with. 

What should you do? 

A. The RSACryptoServiceProvider class should be used in the scenario 
B. The RijndaeManaged class should be used in the scenario 
C. The SHA1CryptoServiceProvider class should be used in the scenario 
D. The SHA1Managed class should be used in the scenario 




















Answer: A 

Explanation: 

Since the RSACryptoServiceProvider class implements an asymmetric cryptography algorithm 
that makes use of a set of related keys to encrypt and decrypt data this class is the correct choice 
in the scenario. 

Incorrect Answers: 

B: This class should not be used in the scenario because the RijndaeManaged class implements a 
symmetric cryptography algorithm that uses a single shared secret key for encrypting and 
decrypting data. 
C: The classes in these two options should not be used in the scenario because the classes both 
implement a hash algorithm that can be used to detect tampering but they can not be used to 
establish the identity of the data file's publisher. 
D: The classes in these two options should not be used in the scenario because the classes both 
implement a hash algorithm that can be used to detect tampering but they can not be used to 
establish the identity of the data file's publisher. 










QUESTION NO: 184 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application and are busy creating a default instance of 
the Rijndael symmetric algorithm class and configure it with a key that is generated from a 
password. The following code you wrote, line numbers are for reference only: 

01: Dim dub1 As Double = 0 
02: Dim salt(16) As Byte 
03: Dim pwdDeBytes As PasswordDeriveBytes = New PasswordDeriveBytes(pwd, salt) 
04: Dim key As Byte() = pwdDeBytes.GetBytes(16) 
05: Dim cryptoRij As Rijndael = Rijndael.Create() 
06: cryptoRij.Key = key 
The variable that is named salt acts as a seed to the key derivation algorithm. You are required to 
insert additional code before line 03 that stores a random number in the salt variable. 

What code segment should you add? 

A. Dim rNum As RandomNumberGenerator = RandomNumberGenerator.Create() 
rNum.GetBytes(salt) 
B. Dim CKGuid as Guid = New Guid() 
salt = CKGuid.ToByteArray() 
C. Dim enc as Encoding = New ASCIIEncoding() 
salt = enc.GetBytes(DateTime.Now.ToString()) 
D. Dim rNum as Random = New Random() 
rNum.NextBytes(salt) 




















Answer: A 

Explanation: 

The correct thing to do in the scenario at hand would be for you to use the code segment 
RandomNumberGenerator class as it represents a cryptographically secure random number. 

Incorrect Answers: 

B: The Guid method should not be considered for use in the scenario as this is only use full for 
creating a unique number that will be use full for computer, network and component identification. 
C: The Date and time should not ever be considered as an instance because that would be a very 
predictable number. 
D: The class should never be considered for use because the Random class generates pseudo 
random numbers that may be repeatable or predictable. 










QUESTION NO: 185 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 Windows application on CERTKILLER-WS536 which 
is used as collateral. You write the following code in the application: 

Dim testplain As Byte() 

The byte array testplain contains the data that needs to be protected and the length of the data 
stored in the byte array is always a multiple of 16. You want only the threads running under the 
current user context to be able to unprotect the data whilst the protected data will be stored in a 
different byte array. The original contents from the testplain byte array must remain unmodified. 
You are required to select which code segment to use if the application will be executed on 
computers running Windows XP Professional. 

What should you do? 

A. Use ProtectedMemory.Protect(testplain, MemoryProtectionScope.SameLogon) 
B. Use ProtectedMemory.Protect(testplain, Nothing, DataProtectionScope.LocalMachine) 
C. Use ProtectedMemory.Protect(testplain, MemoryProtectionScope.SameProcess) 
D. Use ProtectedData.Protect(testplain, Nothing, DataProtectionScope.CurrentUser) 




















Answer: D 

Explanation: 

The ProtectedData.Protect method is used to return a protected copy of the data in the testplain 
byte array whilst the content of the byte array remains unaffected making this the correct option to 
use in the scenario. 

Incorrect Answers: 

A: The methods in the option should not be used in the scenario because this method is used to 
store the protected data in the original copy of the byte array and the original array should remain 
unaffected. 
B: The usage of this method is incorrect as you will allow any process running on the local 
computer to be able to unprotect the data. 
C: The methods in the option should not be used in the scenario because this method is used to 
store the protected data in the original copy of the byte array and the original array should remain 
unaffected. 










QUESTION NO: 186 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. The application 
will be used to send data over the internet. You are required to ensure that the sent data is not 
modified or tampered with during transmission, the secrecy of the data transmission is not 
considered important. 

You recently decided to implement a hash value for the data by using a secret key and transmit 
the data along with the hash value. The receiver of the data should be able to detect whether the 
data or the hash value has been modified whilst the receiver should have access to the secret key 
that was used for computing the hash value. You must additionally ensure that a key sequence of 
160 bits should be acceptable. 

What should you do? 

A. The DESCryptoServiceProvider class should be used to encode the data prior to transmission 
B. The HMACMD5 class should be used to encode the data prior to transmission 
C. The MACTripleDES class should be used to encode the data prior to transmission 
D. The HMACSHA1 class should be used to encode the data prior to transmission 




















Answer: D 

Explanation: 

The SHA1 has function is used by the HMACSHA1 class to compute a Has-based Message 
Authentication Code (HMAC) and additionally HMAC can be used to check if a message has been 
modified during the transmission. 

Incorrect Answers: 

A: The class should not be considered for use in the scenario because the class is used to encode 
the data to protect and maintain its secrecy. 
SecurityPermission class 
B: The class should not be used because the scenario requires a hash sequence of 160 bits and 
the class only provides a hash sequence of 128 bits. 
PrincipalPermission class 
C: The class should never be considered for use in the scenario because the class uses a secret 
key of length 16 or 24 bytes whilst producing a hash sequence of 8 bytes.Part 5: Control 
permissions for resources by using the System.Security.Permission classes. (Refer 
System.Security.Permission namespace) 
FileIOPermission class 










QUESTION NO: 187 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 Windows application that will be used to allow 
CertKiller.com users to download training video files to the local hard drive. The application will 
require permissions for file input and output operations in order to execute, if no permissions are 
available for input or output operations the program should not execute whilst you ensure the 
application is secure. 

What should you do? 

A. The following attribute should be applied at the assembly level: 
<Assembly: FileIOPermission(SecurityAction.RequestOptional, Unrestricted:=True)> 
B. The following attribute should be applied at the class level: 
<FileIOPermission(SecurityAction.Assert, Unrestricted:=True)> 
C. The following attribute should be applied at the class level: 
<FileIOPermission(SecurityAction.Demand, Unrestricted:=True)> 
D. The following attribute should be applied at the assembly level: 
<Assembly: FileIOPermission(SecurityAction.RequestRefuse, Unrestricted:=True)> 
E. The following attribute should be applied at the assembly level: 
<Assembly: FileIOPermission(SecurityAction.RequestMinimum, Unrestricted:=True)> 




















Answer: E 

Explanation: 

The best choice seems to be requesting the minimum permissions that the application requires to 
perform the operations it was intended to perform in the scenario which is to download video files 
to the local hard drive. 

Incorrect Answers: 

A: The option in question specifies that the permissions required by the application are optional 
and should not be used in the scenario. 
B: The security in the scenario is required at the application level and this attributes should not be 
applied at the class level in the scenario. 
C: The security in the scenario is required at the application level and this attributes should not be 
applied at the class level in the scenario. 
D: This option should not be used as this will specify that the application be refused the required 
permissions to perform the required operations. 










QUESTION NO: 188 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS552 as your development computer. 

You are developing a .NET Framework 2.0 application on a CERTKILLER-WS552. You create a 
class named CertKillerDataAccess. You must configure the CertKillerDataAccess class to disallow 
access to the c:\CertKiller\cfg.dat file. You also want to restrict the access to c:\CertKiller\cfg.dat 
through a Universal Naming Convention (UNC) path or a mapped drive letter path. 

You are required additionally to be able to access all other files on the c: drive of the computer 
running the program 

What should you do? (Choose two) 

A. <FileIOPermissionAttribute(SecurityAction.RequestOptional, All:="C:\CertKiller\cfg.dat")> 
B. <FileIOPermissionAttribute(SecurityAction.RequestRefuse, All:="C:\CertKiller\cfg.dat")> 
C. <FileIOPermissionAttribute(SecurityAction.Demand, All:="C:\")> 
D. <FileIOPermissionAttribute(SecurityAction.RequestMinimum, All:"C:\")> 
E. <FileIOPermissionAttribute(SecurityAction.Deny, All:="C:\CertKiller\cfg.dat")> 
F. <FileIOPermissionAttribute (SecurityAction.PermitOnly, All:="C:\")> 




















Answer: E,F 

Explanation: 

The correct option in the scenario applies permissions only to the specified pathname so if the file 
is access using a different path such as \\Workstation1\C$\CertKiller\cfg.dat or by mapping a drive 
the permissions do not apply. 

Incorrect Answers: 

A: It is possible to use a combination of PermitOnly and deny to deny access to specific resources 
as in the above segment the first line uses SecurityAction.PermitOnly to specify access 
permissions are only available for path names starting c:\. 
B: It is possible to use a combination of PermitOnly and deny to deny access to specific resources 
as in the above segment the first line uses SecurityAction.PermitOnly to specify access 
permissions are only available for path names starting c:\. 
C: It is possible to use a combination of PermitOnly and deny to deny access to specific resources 
as in the above segment the first line uses SecurityAction.PermitOnly to specify access 
permissions are only available for path names starting c:\. 
D: It is possible to use a combination of PermitOnly and deny to deny access to specific resources 
as in the above segment the first line uses SecurityAction.PermitOnly to specify access 
permissions are only available for path names starting c:\. 
StrongNameIdentityPermission class 










QUESTION NO: 189 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 assembly using the code shown below: 

Public NotInheritable Class UtilProc 
Public Sub DoWork() 
' Additional code to go here 
End Sub 
End Class 

The code is capable of being called by a Web application or Web service. You are required to 
restrict the assemblies that are capable of calling the DoWork method so only assemblies signed 
with a specific public key should be able to call the DoWork method. 

What should you do? A. SecurityAction.LinkDemand should be passed as a parameter to the attribute 
B. The StrongNameIdentityPermission attribute should be applied to the DoWork method 
C. SecurityAction.InheritanceDemand should be passed as a parameter to the attribute 
D. The SecurityAction.Demand should be passed as a parameter to the attribute 
E. The GacIdentityPermission should be applied to the DoWork method 
F. The KeyContainerPermission should be applied to the DoWork method 




















Answer: A,B 

Explanation: 

By using the StrongNameIdentityPermission attribute you effectively ensure that only the 
assemblies that have been signed by a specific public key are capable of calling the DoWork 
method in the scenario, the SecurityAction.LinkDemand value further ensures that only the 
immediate caller is authorized. 

Incorrect Answers: 

C: This method should be used if you want to limit the scope of the attribute to only inheriting 
classes and the class is declared NotInheritable. 
D: This should not be used because you would be forcing everything in the call stack to be signed 
using the same public key and you can not sign dynamically created assemblies. 
E: This option should not be considered for usage as you will ensure that calling code should 
originate from the global assembly cache (GAC). 
UIPermission class 
F: This method should not be used in the scenario because this method is used to control access 
to specific key containers. 
UrlIdentityPermission class 










QUESTION NO: 190 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You write the 
class named TestScrapData. You are required to configure the TestScrapData class and limit its 
access to only the code originating from a specific Web site, www.CertKiller.com and its 
subdomains. 

The Web sites will be required to be access using HTTP, HTTPS and the FTP protocols. You are 
required to additionally configure code access permissions for the TestScrapData class 

What should you do? A. The SiteIdentityPermission class should be used in the scenario. 
B. The PublisherIdentityPermission class should be used in the scenario. 
C. The ZoneIdentityPermission class should be used in the scenario. 
D. The UrlIdentityPermission class should be used in the scenario. 




















Answer: A 

Explanation: 

To successfully achieve your scenario objective you must use the SiteIdentityPermission class to 
configure code access permissions for the callers from a specific Web site. 

Incorrect Answers: 

B: This class should not be used as it is designed for usage to configure permissions based on the 
identity of the software publisher. 
ApplicationTrust class and ApplicationTrustCollection class 
C: This class should not be used because it is used to configure code access permissions for the 
zone where the code originates and the Internet zone may contain to many Web-sites. 
Evidence class and PermissionRequestEvidence class 
D: This class should not be considered for use as it is used to configure access permissions for a 
Uniform Resource Locator (URL). 
CodeGroup class, FileCodeGroup class, FirstMatchCodeGroup class, NetCodeGroup class, and 
UnionCodeGroup class 










QUESTION NO: 191 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. 

You are developing a .NET Framework 2.0 application that will be deployed throughout the 
network on all workstations which are all networked as part of a Microsoft Windows domain. The 
application you wrote requires certain permissions in order to run. As the domain administrator you 
configure the enterprise policy to grant the required permissions to the application which may be 
part of one or more code group. 

You must ensure that your application receives the sufficient permissions to run at all times whilst 
you override any policy changes made by the end users that lower the permissions required by the 
application to run. 

What should you do? 

A. The LevelFinal attribute should be applied to the application's code group on the enterprise 
policy level. 
B. The Exclusive attribute should be applied to the application's code group on the user policy 
level. 
C. The LevelFinal attribute should be applied to the application's code group on the user policy 
level. 
D. The Exclusive attribute should be applied to the application's code group on the enterprise 
policy level. 




















Answer: A 

Explanation: 

The FinalLevel attribute should be applied in the scenario to the application's code group on the 
enterprise level as this is the highest level of policy. 

Incorrect Answers: 

B: The Exclusive attribute should not be considered in the scenario for usage as the runtime will 
never grant permissions associated with the code group marked with the Exclusive attribute. 
C: This should not be done as you would enable the end users the capability of changing or 
altering security settings that will restrict the applications execution. 
D: The Exclusive attribute should not be considered in the scenario for usage as the runtime will 
never grant permissions associated with the code group marked with the Exclusive attribute. 










QUESTION NO: 192 

You work as an application developer at CertKiller.com. You are currently creating an application 
that requires role-based security. You are planning to utilize a database to store the user accounts 
and group membership data. 

You need to ensure that users are able to log on and off. You also need to ensure that the 
application you have created tracks the user accounts of these users, and restrict or allow access 
to code based on their group membership. You need to achieve this objective with as little 
developer effort as possible. 

What should you do to implement role-based security? 

A. Inherit from the GenericIdentity and GenericPrincipal classes. 
B. Make use of GenericIdentity and GenericPrincipal objects. 
C. Implement the IIdentity and IPrincipal interfaces. 
D. Make use of WindowsIdentity and WindowsPrincipal objects. 




















Answer: B 

Explanation: 

in this scenario, the GenericIdentity and GenericPrincipal objects could be implemented as 
follows: GenericIdentity curIdentity = new GenericIdentity ("CurrentUser"); 
string [] roles = { "Users", "Administrators" }; 
thread.CurrentPrincipal = GenericPrincipal (curIdentity, roles); 

This code instantiates a GenericIdentity object based upon a user name as a string object, 
instantiates a string array representing the roles to which that user belongs, instantiates a 
GenericPrincipal object specifying the GenericIdentity object and string array of roles as 
arguments, and assigns the new GenericPrincipal object to the CurrentPrincipal property of the 
current thread. By assigning the new principal to the CurrentPrincipal property of the current 
thread, role membership checks can be performed using the IsInRole method 

Incorrect Answers: 

A: These options require more developer effort than necessary. 
C: These options require more developer effort than necessary. 
NTAccount class and SecurityIdentifier class 
D: The WindowsIdentity and WindowsPrincipal classes are intended for use with windows domain 
stored accounts and groups only. 










QUESTION NO: 193 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You write the 
following code in the application, line numbers are for reference: 

01: Dim CKSecurity As FileSecurity = File.GetAccessControl("c:\root\config.crn") 
02: Dim myName As String = String.Empty 
03: Console.WriteLine("Owner name: {0}", myName) 
You are required to write additional code before line 03 that will be used to allow you to print a 
user-friendly owner name of the c:\king\root\config.crn. 

What should you do? 

A. Dim sID As SecurityIdentifier = CKSecurity.GetGroup(GetTyp(SecurityIdentifier)) 
myName = sID.Value 
B. Dim sID As SecurityIdentifier = CKSecurity.GetOwner(GetType(SecurityIdentifier)) 
myName = sID.Value 
C. Dim ntAcc As NTAccount = CKSecurity.GetGroup(GetType(NTAccount)) 
myName = ntAcc.Value 
D. Dim ntAcc As NTAccount = CKSecurity.GetOwner(GetType(NTAccount)) 
myName = ntAcc.Value 




















Answer: D 

Explanation: 

Since the GetOwner method of the FileSecurity class gets the owner associated with the given file 
and the Value property of the NTAccount class represents a user-friendly owner name this 
particular code segment should be used. 

Incorrect Answers: 

A: In the scenario you are required to get the file owner instead of the primary group to which the 
owner belong and there for you should not use the two GetGroup method code segments. 
B: In the scenario you are required to get the file owner instead of the primary group to which the 
owner belong and there for you should not use the two GetGroup method code segments. 
C: The Value of the security identifier class provides a long string containing the security identifier 
corresponding to the windows account. 










QUESTION NO: 194 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS554. You write the 
code shown below: 

Public Class Shape 
Private shapeName As String 

Public Sub Shape(ByVal shapeName As String) 
Me.shapeName = shapeName 
End Sub 

Public Overridable Function GetName() As String 
Return shapeName 
End Function 

Private Sub DrawShape() 
'Additional code goes here 
End Sub 
End Class You later decide to have the application compiled and registered for COM interoperability. The 
other developers on your team complain that they are unable to create an instance of the Shape 
class in their COM applications. You are required to ensure that COM applications are able to 
create an instance of the Shape class. 

What should you do? 

A. The following code should be added to the Shape class: 
Public Sub New() 
End Sub 
B. The following ComVisible attribute to the Shape class: 
<ComVisible(True)> 
C. The definition of the GetName method should be modified as below: 
Public Function GetName() As String 
Return shapeName 
End Function 


D. The following ComVisible attribute should be added to each method of the Shape class: 
<ComVisible(True)> 




















Answer: A 

Explanation: 

Remember that only the classes that have a public default constructor can be instantiated from a 
COM application and the parameterized constructor which is not used by the COM and therefore 
you should add the code used in the answer. 

Incorrect Answers: 

B: The lines of code that are used in the scenario will not make any difference to the situation at 
hand currently in the scenario and should not be used. 
C: The class and public members are already visible to COM applications so your only problem 
lays with instantiating the class. 
D: The lines of code that are used in the scenario will not make any difference to the situation at 
hand currently in the scenario and should not be used. 










QUESTION NO: 195 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You write a new 
class named CertKillerProcess as shown below: Public Class CertKillerProcess 
Public Sub New() 
End Sub 

Public Sub GetState() 
'Additional code goes here 
End Sub 
Public Function ChangeCase(ByVal s As String) As String 
Return s.ToUpper() 
End Function 
End Class 

You compile the class to a file named CertKillerProcess.dll, the Component Object Model (COM) 
applications are required to be able to create instances of this class and invoke methods. The 
Com applications may need to bind type information at compile time. You are required to select 
which command line tool to use. 

What should you do? 

A. The Type Library Exporter tool (tlbexp.exe) should be used. 
B. The Type Library Importer tool (tlbimp.exe) should be used. 
C. The Assembly Registration tool (regasm.exe) should be used. 
D. The Native Image Generator tool (ngen.exe) should be used. 




















Answer: C 

Explanation: 

Because the Com applications expect to find runtime information about types in the Windows 
registry the usage of the Assembly Registration toll(Regasm.exe) reads an assembly creates 
entries required by the Com applications. 

Incorrect Answers: 

A: This tool is used to generate a Com library from an assembly and should not be considered for 
usage in the scenario. 
Platform Invoke 
B: This tool does exactly the opposite of the exporter tool and should also not be considered for 
usage in the scenario. 
D: The tool is used to generate a native image for managed code and reduces load times for the 
application but does not convert assemblies for use in COM applications. 










QUESTION NO: 196 You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS554. You are trying to 
port an old CertKiller.com management application that was written in unmanaged Windows code 
with no COM interfaces. The application you are developing makes calls to the old CertKiller.com 
management unmanaged library namedKingPerformance.dll. 

You are required to make a call to the GetPerformaceScore method of the unmanaged 
Performance.dll library. 

What should you do? 

A. The Type Library Exporter tool (tlbexp.exe) should be used. 
B. The Type Library Importer tool (tlbimp.exe) should be used. 
C. The Assembly Registration tool (regasm.exe) should be used. 
D. The Platform Invoke (DllImportAttribute) should be used. 




















Answer: D 

Explanation: 

The feature Platform Invoke is used to allow you to call methods that are in unmanaged libraries 
but you need to declare the unmanaged method in the managed code using the extern and static 
keywords with the DllImport attribute which is used to specify the unmanaged library. 

Incorrect Answers: 

A: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
B: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
Create a class to hold DLL functions. 
C: The tool should not be considered for usage in the scenario because the unmanaged dll file is 
not in COM and it only processes COM type libraries. 
Create prototypes in managed code. 










QUESTION NO: 197 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 Windows application on CERTKILLER-WS536. Your application needs to call the GetComputerName method in the library named kernel32.dll to 
display the computer name. You write the code below: 

<DllImport("kernel32.dll")> Public Shared Function GetComputerNamer( _ 
ByVal IpBuffer As StringBuilder, ByRef IpnSize As Integer) As Boolean 
End Function 

You are required to call the method as ComputerName based on your coding standards whilst you 
ensure that your code can be cancelled on any Windows operating system. You need to know 
how to modify the DllImport attribute to call the GetComputerName method. 

What should you do? 

A. The Entrypoint property must be set to "ComputerName". 
B. The CharSet property must be set to CharSet.Unicode. 
C. The CharSet property must be set to CharSet.Ansi. 
D. The EntryPoint property must be set to "GetComputerName". 
E. The CharSet property must be set to CharSet.Auto. 




















Answer: D,E 

Explanation: 

The correct method to use in the scenario is to modify the DllImport attribute and set the 
EntryPoint property to "GetComputerName" which is the name of the method invoked in 
kernel32.dll but the .NET method should be declared as ComputerName. 

Incorrect Answers: 

A: The methods used in the options could be used but require that the code be changed 
significantly and you should not consider using the options in the scenario as they are bound to 
fail. 
System.Reflection.Emit namespace. 
B: The methods used in the options could be used but require that the code be changed 
significantly and you should not consider using the options in the scenario as they are bound to 
fail. 
Assembly class 
C: The methods used in the options could be used but require that the code be changed 
significantly and you should not consider using the options in the scenario as they are bound to 
fail. 










QUESTION NO: 198 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. The application 
will be used to list the available public types and methods in the CertKiller.com assembly. You 
named the assembly strongly and it is installed in the global assembly cache (GAC) and an 
assembly with the same identity is stored at c:\CertKiller\assemb\CertKiller.com.dll. 

You are required to dynamically load the CertKiller.com assembly into your application whilst you 
ensure that the assembly is loaded from c:\CertKiller\assemb\CertKiller.com.dll rather than the 
global assembly cache (GAC). 

What code segment should you use? 

A. Dim assemb As Assembly = Assembly.LoadFrom("c:\CertKiller\assemb\CertKiller.com.dll") 
B. Dim assemb As Assembly = Assembly.LoadFile("c:\CertKiller\assemb\CertKiller.com.dll") 
C. Dim assemb As Assembly = Assembly.ReflectionOnlyLoad("CertKiller.com") 
D. Dim assemb As Assembly = Assembly.Load("CertKiller.com") 
E. Dim assemb As Assembly = _ 
Assembly.ReflectionOnlyLoadFrom("c:\CertKiller\assemb\CertKiller.com.dll") 




















Answer: E 

Explanation: 

To correctly load the Assembly class from the location c:\CertKiller\assemb\CertKiller.com.dll you 
should make used of the method used in the option of the scenario. 

Incorrect Answers: 

A: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
B: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
C: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 
Assembly attributes 
D: The other methods of the assembly class will request the common language runtime (CLR) to 
resolve the location of the assembly based on its identity therefore these options should not be 
used in the scenario even though you provide the full absolute path as a parameter. 










QUESTION NO: 199 You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS554. The application's 
assembly is named CertKillerApp and is stored in CertKillerApp.exe. You are busy using .NET 
Framework's Strong Name tool to generate a pair for CertKillerApp.exe shown below: 

Sn.exe -k CertKillerAppKey 

You are required to use the key pair to build the CertKillerApp.exe as a strong named assembly. 

What should you do? 

A. The AssemblyKeyFileAttribute class should be used. 
B. The AssemblyDelaySignAttribute class should be used. 
C. The AssemblyConfigurationAttribute class should be used. 
D. The AssemblyKeyNameAttribute should be used. 




















Answer: A 

Explanation: 

The Strong name tool is used to allow you to generate and manage keys for the strong name 
signing and by using the -k switch the tool generates a new key pair and stores it in the specified 
file. So using the AssemblyKeyFileAttribute is the correct way to go in the scenario. 

Incorrect Answers: 

B: This class should not be considered for use as it is designed to specify whether or not delayed 
signing should be used. 
MailAddress class and MailAddressCollection class 
C: The class should not be used in the scenario because the class is used to specify a build 
configuration for an assembly. 
SmtpClient class, SmtpPermission class, and SmtpPermissionAttribute class 
D: This class should not be used in the scenario because it is used to specify the name of a key 
container that should be used. 
Info classes 
Attachment class, AttachmentBase class, and AttachmentCollection class 










QUESTION NO: 200 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. You are developing a .NET Framework 2.0 application on CERTKILLER-WS554. The application 
will allow CertKiller.com users to send e-mails. The CertKiller.com users must be able to send e-
mail containing information like budget documents and images. You decide to use the .NET 
Framework 2.0 Attachment class to create the e-mail attachments within your application. 

You are required to specify the content in an attachment by using the attachment class 
constructors. 

What should you do? (Choose two) 

A. The Stream object attachment class should be used. 
B. The String object attachment class should be used. 
C. The Image object attachment class should be used. 
D. The XmlDocument object attachment class should be used. 
E. The SqlDataReader object attachment class should be used. 




















Answer: A,B 

Explanation: 

In the scenario the Attachment constructors allow you to create attachments from a filename, a 
String object, or a Stream object. 

Incorrect Answers: 

C: This method is incorrect and should not be used in the scenario because the Image object 
Attachment class cannot directly use an Image object. 
D: This method is incorrect and should not be used in the scenario because the XmlDocument 
Attachment class cannot directly use an XmlDocument object. 
E: This method is incorrect and should not be used in the scenario because the SqlDataReader 
Attachment class cannot directly make use of a SqlDataReader object. 
SmtpException class and SmtpFailedReceipientException class 










QUESTION NO: 201 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application that will be used to send e-mail. You 
develop the code shown below, line numbers for reference: 

01: Public Sub SendMessage(ByVal message As MailMessage, ByVal host As String) 
02: Dim client As SmtpClient = New SmtpClient(host) 
03: Try 
04: client.Send(message) 
05: Catch ex As SmtpFailedRecipientsException 
06: 
07: For i As Integer = 1 To ex.InnerExceptions.Length 
08: 
09: Next 
10: End Try 
11: End Sub 
The parameter MailMessage will be used to represent an e-mail message and the parameter host 
contains the address of a SMTP server. During the day the code will encounter SMTP error 450 
(mailbox busy) errors, when this occurs an attempt should be made to resend the mail message 
after five seconds. In the event that you encounter another error it should be recorded in the event 
log. 

You are required to add additional code at line 08 for handling the errors and need to write an 
expression that allows you to find the specific SMTP error returned by the SMTP server. 

What should you do? 

A. The ex.InnerExceptions(i).Data expression should be used 
B. The ex.InnerExceprions(i).Message expression should be used 
C. The ex.InnerExceptions(i).FailedRecipient expression should be used 
D. The ex.InnerExceptions(i).StatusCode expression should be used 




















Answer: D 

Explanation: 

In the scenario you should make use of the StatusCode expression because the expression can 
be used to return an enumeration of type SmtpStatusCode and gets the error code returned by the 
SMTP server in the scenario. 

Incorrect Answers: 

A: This expression should not be used in the scenario because this expression will be used to 
return a set of user-defined values corresponding to the exception. 
B: This expression should not be used in the scenario because it returns a descriptive message 
about the error and does not provide you specific information of the error returned by the SMTP 
server 
C: This expression should not be used in the scenario because it is used to have the e-mail 
address that had the problems returned and gives no information about the SMTP error. 










QUESTION NO: 202 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on CERTKILLER-WS554. The 
application will be used to allow CertKiller.com users to send e-mail messages and should allow 
CertKiller.com users to send HTML-based e-mails, but the users should not be able to use the 
HTML <img> tag to embed images in the HTML document 

The images are not externally hosted so instead the images must be sent as part of the e-mail 
message. You are required to select which class to use. 

What should you do? 

A. The AlternateView class should be used. 
B. The Attachment class should be used. 
C. The MailAddress class should be used. 
D. The LinkedResource class should be used. 




















Answer: D 

Explanation: 

In the scenario you should make use of the LinkedResource class as it is used to embed external 
resources in an e-mail attachment such as images in an HTML attachment. 

Incorrect Answers: 

A: The class in question could be used in the scenario but the AlternateView class itself cannot be 
used to embed images in the HTML document. 
B: The Attachment class should not be used in the scenario as the class only allows you to send 
images as an attachment. 
C: The usage of this class is incorrect as it is used to store the address information for e-mail 
messages in the scenario. 










QUESTION NO: 203 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 Windows Forms application on CERTKILLER-WS536. 
The Windows Forms application will be used by regional offices of CertKiller.com in various 
countries. You are required to customize the application so that the language, calendar and cultural 
conventions are changed based on the user's operating system settings. You additionally are 
required to identify the .Net Framework class that should be used for this requirement. 

What should you do? 

A. The cultureInfo class should be used. 
B. The TextInfo class should be used. 
C. The DateTimeFormtaInfo should be used. 
D. The CharUnicodeInfo should be used. 
E. The RegionInfo should be used. 




















Answer: A 

Explanation: 

The CultureInfo class should be used in the scenario because it contains culture-specific 
information and provides the information required for performing culture-specific operations like 
changing casing, formatting dates and numbers and comparing strings. 

Incorrect Answers: 

B: This class should not be used in the scenario because this class only affects the behavior such 
as text casing. 
C: This class should not be used in the scenario because this class only defines how the Date and 
Time values are formatted. 
D: This class should not be used in the scenario because this class is used to only retrieve 
information about a Unicode character. 
E: This class should not be used in the scenario because this class does not represent any 
preferences of the user and does not depend upon the culture. 










QUESTION NO: 204 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 Windows Forms application that must provide support 
for multiple languages and regional differences. You are required to define a custom culture based 
on an existing culture and region. An administrative user will install the custom culture on the end 
user's computer prior to the applications deployment. You are required to select which class to 
use. 

What should you do? A. The CultureAndRegionInfoBuilder class should be used 
B. The CustomAttributeBuilder class should be used 
C. The RegioInfo class should be used 
D. The CultureInfo class should be used 




















Answer: A 

Explanation: 

The correct option in the scenario would be to make use of the CultureAndRegionInfoBuilder class 
as this class is used to define a custom culture that is new or based upon an existing region and 
culture. 

Incorrect Answers: 

B: This class should not be used in the scenario because this class is used to define custom 
attributes which are used to associate declarative information. 
C: This class should not be used in the scenario because this class is used to access the region 
data for an already installed culture. 
D: This class should not be used in the scenario because this class can only be used to make use 
of cultures that have already been installed. 










QUESTION NO: 205 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application on CERTKILLER-WS536. You are required 
to provide locale-specific services to employees with the application. You must additionally ensure 
that you use a unique country identifier that can be used as a key to access a database record 
that contains specific information about a country whilst you use the minimum storage for storing 
the key. 

What should you do? 

A. CultureInfo.Name should be used as an identifier for a country. 
B. CultureInfo.GetHashCode should be used as an identifier for a country. 
C. RegionInfo.GetHashCode should be used as an identifier for a country. 
D. RegionInfo.Name should be used as an identifier for a country. 




















Answer: D 

Explanation: 

In the scenario you should make use of the RegionInfo.Name property as this property gets the 
name or ISO 3166 two-letter country/region code for the current RegionInfo object. Incorrect Answers: 

A: This method should not be used in the scenario as you will only receive the culture name 
instead of the country name and does not meet the objective. 
B: The usage of the GetHashCode property in the scenario is incorrect as the hash value 
generated can be used to tell whether the RegionInfo or CultureInfo objects are the same or not. 
Format date and time values based on the culture. 
C: The usage of the GetHashCode property in the scenario is incorrect as the hash value 
generated can be used to tell whether the RegionInfo or CultureInfo objects are the same or not. 










QUESTION NO: 206 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on CERTKILLER-WS554. You 
create the following variable in your code: 

Dim dateValue As DateTime 

You additionally write code to store time in the local time to the dateValue variable. You are 
required to serialize the value of the dateValue variable, if you serialize the DateTime object in one 
time zone and deserialized in a different time zone, the local time represented as a result should 
be automatically adjusted to the second time zone. You are to decide which expression to use. 

What should you do? 

A. The dateValue.ToString("yyyy-MM-ddTHH:mm:ss.fffffff", CultureInfo.InvariantCulture) 
expression should be used. 
B. The dateValue.ToBinary() expression should be used. 
C. The dateValue.Kind expression should be used. 
D. The dateValue.Ticks expression should be used. 




















Answer: B 

Explanation: 

To preserve the information that you are required to preserve in the scenario you should make use 
of the newToBinary and FromBinary method as these methods can be used to automatically 
adjust the local times. 

Incorrect Answers: 

A: The expression in question should not be used in the scenario because the expression will not 
preserver any of the required reserved information. 
C: This expression will be used to check whether the value indicates whether time is represented 
by the instance is based on local time. 
Format number values based on the culture. 
D: This expression is used to super fast serialize the required information but should not be 
considered when working with the local time. 










QUESTION NO: 207 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 enterprise application on aCERTKILLER-WS536 which 
is used as collateral. You write the code below in your application, line numbers are reference: 

01: Dim num As String 
02: Dim val As Integer 
03: num = " (37)" 
04: 
You are required to write additional code at line 04 that will be used to correctly parse the string 
value and assigns the result to the Integer variable named val. When you execute the code the 
variable is required to hold a value of -37. You must decide which code to use. 

What code segment should you use? 

A. val=Int32.Parse(num, NumberStyles.AllowLeadingSign And NumberStyles.AllowLeadingWhite) 
B. val=Int32.Parse(num, NumberStyles.AllowParentheses And NumberStyles.AllowLeadingWhite) 
C. val=Int32.Parse(num, NumberStyles.AllowLeadingSign Or NumberStyles.AllowLeadingWhite) 
D. val=Int32.Parse(num, NumberStyles.AllowParentheses Or NumberStyles.AllowLeadingWhite) 




















Answer: D 

Explanation: 

The NumberStyles.AllowParentheses value is used to indicate that the numeric string can have 
one pair of parentheses enclosing the number and the NumberStyles.AllowLeadingWhite value is 
used to indicate that a leading white-space character must be ignored during the parse. 

Incorrect Answers: 

A: This code should not be used in the scenario because the code is used to indicate that the 
numeric string can have a leading sign. 
B: This code should not be used in the scenario because the code is used to indicate that the 
numeric string can have a leading sign. 
C: The code in question should not be used in the scenario because the attributes of 
NumberStyles are set by using the bitwise inclusive Or on the field flags. 










QUESTION NO: 208 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 Windows Forms application that will be used by 
several CertKiller.com employees in several countries. The application is required to fully support 
customization of the user interface based on the user's preferences like the language currency 
and date and time formats. 

You are required to write code that will compare the name of two employees which are stored in 
variables named employee1 and employee2. You are required to ensure correct comparisons 
whilst taking care of the regional settings selected. 

What should you do? 

A. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.CurrentCulture) segment 
should be used. 
B. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.InvariantCulture) 
segment should be used. 
C. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.InstalledUICulture) 
segment should be used. 
D. The String.Compare(Fileemployee1, Fileemployee2, true, CultureInfo.CurrentUICulture) 
segment should be used. 




















Answer: A 

Explanation: 

The default behavior of the segment in question is to perform culture-sensitive comparisons and 
should definitely be considered for use in the scenario. 

Incorrect Answers: 

B: This code segment is incorrect and should not be used in the scenario because it will lead to 
culture-insensitive operations. 
C: This code segment is incorrect and should not be used in the scenario because this will used 
the culture that is installed with the operating system. 
D: This code segment is incorrect and should not be used in the scenario because this settings 
only used for changing the user's interface culture used by a thread. 










QUESTION NO: 209 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a large .NET Framework 2.0 application that is required to provide support for 
culture-specific information. You are required to parse a date and time string generated for a 
custom culture and to help the success of the parse operation you designate parse patterns that 
tare likely to succeed. You must additionally prevent the operation from failing whilst you select the 
method to use for parsing the string. 

What should you do? 

A. The ParseExact method should be used. 
B. The Parse method should be used. 
C. The TryPassExact method should be used. 
D. The TryParse method should be used. 




















Answer: C 

Explanation: 

The TryParseExact method should be used if you require parsing a date and time string generated 
from a custom culture. 

Incorrect Answers: 

A: The usage of these methods in the scenario would be incorrect because the methods do not 
provide error handling and the custom vulture can be complicated and difficult to parse. 
Enhance the user interface of a .NET Framework application by using brushes, pens, colors, and 
fonts. 
B: The usage of these methods in the scenario would be incorrect because the methods do not 
provide error handling and the custom vulture can be complicated and difficult to parse. 
Enhance the user interface of a .NET Framework application by using graphics, images, bitmaps, 
and icons. 
D: If you decide to use the TryParse method which attempt to parse a string using several implicit 
parse patterns that may all fail you will not achieve the scenario objective.Part 2: Enhance the user 
interface of a .NET Framework application by using the System.Drawing namespace. 










QUESTION NO: 210 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 application that will be used to manipulate graphics 
files in GIF, JPG and PNG formats. You are required to choose an appropriate data type to store 
graphic files whilst your solution must use the least amount of code. 

What should you do? 

A. The Icon class should be used. 
B. The Metafile class should be used. 
C. The Image class should be used. 
D. The Bitmap class should be used. 




















Answer: D 

Explanation: 

Because the Bitmap class is an implementation of the Image abstract class that is capable of 
working with several types of image formats this class should be considered for usage in the 
scenario. 

Incorrect Answers: 

A: This class should not be used in the scenario because the Icon class only allows you to work 
with small bitmap images. 
StringBuilder class 
B: This class should not be used in the scenario because this class can not be used to manipulate 
images in different formats. 
Regex class 
C: This class should not be used in the scenario because this class is an abstract class which 
requires functionality to be implemented which requires programming effort. 
Enhance the user interface of a .NET Framework application by using shapes and sizes.Part 3: 
Enhance the text handling capabilities of a .NET Framework application (refer System.Text 
namespace), and search, modify, and control text in a .NET Framework application by using 
regular expressions. (Refer System.RegularExpressions namespace) 










QUESTION NO: 211 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS536 as your development computer. 

You are developing a .NET Framework 2.0 text-processing application on CERTKILLER-WS536. 
You are busy defining the following regular expression of currency values: Dim tx As Regex = New Regex("^-?\d+(\.\d{2})?$") 

You are required to write code that will be used to find whether a string in the variable named king 
matches the regular expression or not. You are also required to use this code as the expression in 
a conditional statement and need to know which code segment to use. 

What should you do? 

A. Use the code segment: tx.Matches(king) 
B. Use the code segment: tx.Equals(king) 
C. Use the code segment: tx.Match(king) 
D. Use the code segment: tx.IsMatch(king) 




















Answer: D 

Explanation: 

In order for you to successfully indicate whether the regular expression finds a match in the input 
string you should make use of the IsMatch(king) segment in the scenario. 

Incorrect Answers: 

A: This segment should not be used in the scenario because the Matches method is used to 
search an input string for all occurrences of a regular expression and returns all the successful 
matches. 
B: This segment should not be used in the scenario because this method is used to determine 
whether any two Object instances are equal. 
C: This segment should not be used in the scenario because the Matches method is used to 
search an input string for an occurrence of a regular expression and returns the precise results as 
a single successful match. 
Match class and MatchCollection class 










QUESTION NO: 212 

You work as the application developer at CertKiller.com. CertKiller.com uses Visual Studio.NET 
2005 as its application development platform. You use a Windwos XP Professional client 
computer named CERTKILLER-WS554 as your development computer. 

You are developing a .NET Framework 2.0 application on a CERTKILLER-WS554. The 
application will be used globally and must be able to represent characters in the following 
languages: English, Chinese Traditional, Hebrew and Tamil. Your application is required to 
provide error detection for invalid sequences of characters whilst your application must also 
optimize storage. 

What should you do? A. Encode the characters in your application using the UTF8Encoding class. 
B. Encode the characters in your application using the UTF7Encoding class. 
C. Encode the characters in your application using the UTF32Encoding class. 
D. Encode the characters in your application using the UTF16Encoding class. 




















Answer: A 

Explanation: 

To successfully enable error detection and make the class instance more secure you should make 
use of the UTF8Encoding class in the scenario. 

Incorrect Answers: 

B: The Encoding class used in this option UTF7Encoding does not provide any error detection and 
should not be used in the scenario. 
C: The Encoding classes in these options should not be used in the scenario because the 
UTF16Encoding class represents each character as a sequence of one to two 16-bit integers and 
the UTF32Encoding represents each code point as a 32-bit integer. 
D: The Encoding classes in these options should not be used in the scenario because the 
UTF16Encoding class represents each character as a sequence of one to two 16-bit integers and 
the UTF32Encoding represents each code point as a 32-bit integer. 










QUESTION NO: 213 

You work as the application developer at CertKiller.com. To get information on a specific method 
named myMethod, you use Reflection. You need to find out if myMethod can be accessed from a 
derived class. 

Which of the following properties should you call from the myMethod class? 

A. Call the IsAssembly property. 
B. Call the IsVirtual property. 
C. Call the IsStatic property. 
D. Call the IsFamily property. 




















Answer: D 

Explanation: 

The IsFamily property determines whether the method is accessible onlsecy to the class and 
descendant classes. 

IsAssembly determines accessibility from within the assembly. 

IsVirtual indicates whether the method is virtual. IsStatic indicates whether the method is static. 











QUESTION NO: 214 

You work as the application developer at CertKiller.com. You create a new class that uses 
unmanaged resources, but which still has references to managed resources on other objects. 

You want users of the new class to be able to explicitly release resources when the class instance 
is no longer required. 

What should you do next? 

Choose the three actions which you should perform. Each correct answer presents only part of the 
complete solution. 

A. Define the existing class so that it inherits from the WeakReference class. 
B. Define the existing class so that it applies the IDisposable interface. 
C. Create a new class destructor which calls methods on other objects to release the managed 
resources. 
D. Create a new class destructor that releases the unmanaged resources. 
E. Create a new Dispose method that calls System.GC.Collect to force garbage collection. 
F. Create a new Dispose method that releases unmanaged resources and which also calls 
methods on other objects to release the managed resources. 




















Answer: B,D,F 

Explanation: 

It is necessary to implement the IDisposable interface if you need to release unmanaged 
resources or want explicit control of the life of managed resources. A class destructor should be 
created to release the unmanaged resources and this should be called from within the Dispose 
method. The dispose method should also release the managed resources. 

Inheriting from WeakReference would result in the garbage collector releasing resources even 
though there may be valid references. 

The managed resources should be released in the Dispose method. 

System.GC.Collect could be used, however it is more efficient to manually release the managed 
resources. The GC incurs overhead and may have only recently been called anyway. The 
question states resources should be released explicitly. 









QUESTION NO: 215 

You work as the application developer at CertKiller.com. You are developing a debug build of an 
existing application. You want to locate a specific line of code which resulted in the exception 
occurring. 

Choose the property of the Exception class that you should use to accomplish the task. 

A. Data property 
B. Message property 
C. StackTrace property 
D. Source property 




















Answer: C 

Explanation: 

The StackTrace property provides a listing of the current call stack. Information such as the 
method calls and line numbers are shown. 

Data will return additional user-defined information about the exception 

Message describes the current exception but will not give details about the source code line 
number. 

Source represents the name of the application or object that caused the error. 











QUESTION NO: 216 

You work as the application developer at CertKiller.com. You need to modify the code of an 
application. The application uses two threads named thread A and thread B. You want thread B to 
complete executing before thread A starts executing. 

How will you accomplish the task? 

A. Define thread A to run at a lower priority. 
B. Define thread B to run at a higher priority. 
C. Implement the WaitCallback delegate to synchronize the threads. 
D. Call the Sleep method of thread A. 
E. Call the SpinLock method of thread A. 




















Answer: C 

"Pass Any Exam. Any Time." 

How will you accomplish the task? Answer by arranging the relevant actions in the proper order. 

Microsoft 70-536: Practice Exam 

Explanation: 

Note: Some confusion why the answer is C. Using the ThreadPool and WaitCallBack will not 
synchronise the threads, they will run in the background in parallel 











QUESTION NO: 217 DRAG DROP 

You work as the application developer at CertKiller.com. You have been instructed to create an 
application that can provide information on the local computer only. The application is configured 
with a form that provides information on all logical drives and associated drive properties of the 
local computer. 

You must script a procedure that retrieves the properties of each logical drive of the local 
computer. 





















Answer: 










QUESTION NO: 218 

You work as the application developer at CertKiller.com. The global cache contains an assembly 
named CertKillerAss10. You are busy working on an assembly named CertKillerAss09. 
CertKillerAss9 includes a public method. 

You want the public method to be called from only CertKillerAss10. 

Choose the permission class which you should use. 

A. Use the GacIdentityPermission 
B. Use the PublisherIdentityPermission 
C. Use the DataProtectionPermission 
D. Use the StrongNameIdentityPermission 




















Answer: D 

Explanation: 

StrongNameIdentityPermission can be used to verify the identity of a calling assembly. 

GACIdentityPermission can be used to test whether a file is in the global assembly cache or not. 

PublisherIdentityPermission can be used to verify the identity of a publisher. 

DataPublisherPermission is used to control the ability to access encrypted data and memory. 











QUESTION NO: 219 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp12. 

CertKillerApp12 must be configured to receive events asynchronously. You define two instances 
named Wq1EventQuery and ManagementEventWatcher respectively. Wq1EventQuery will list 
those events and event conditions for which CertKillerApp12 should respond. 
ManagementEventWatcher will subscribe to all events matching the query. 

Which two additional actions should you still perform to enable CertKillerApp12 to receive events 
asynchronously? 

Choose two correct answers. Each answer presents only part of the complete solution. 

A. Call the Start method of the ManagementEventWatcher to start listening for events. 
B. To configure a listener for events, use the EventArrived event of the 
ManagementEventWatcher. 
C. To wait for the events, use the WaitFor NextEvent method of the ManagementEventWatcher. 
D. Create an event handler class that contains a method which receives an 
ObjectReadyEventArgs parameter. 
E. Use the Stopped event of the ManagementEventWatcher to configure a listener for events. 




















Answer: A,B 

Explanation: 

The ManagementEventWatcher will not start to listen (hence the app cannot respond to Async 
messages) until the start method is called. Once the ManagementEventWatcher is listening it will 
trigger an EventArrived event every time an event occurs that matches the query. You should 
provide a listener for the EventArrived event to perform any custom handling. 

WaitForNextEvent method is synchronous i.e the current thread will wait until a matching event 
occurs 

ObjectReadyEventArgs holds data for the ObjectReadyEvent. 

The Stopped event is triggered when the ManagmentEventWatcher cancels it's subscription i.e is 
no longer interested in receiving notification of events. 











QUESTION NO: 220 

You work as the application developer at CertKiller.com. You must specify a class which is 
optimized for key-based item retrieval from collections. Your class must cater for key-based item 
retrieval for small and large collections. 

Which of the following class types should you specify? 

A. Select the OrderedDictionary class. 
B. Select the HybridDictionary class. 
C. Select the ListDictionary class. 
D. Select the Hashtable class. 




















Answer: B 

Explanation: 

A HybridDictionary is implemented as a ListDictionary for small collections and a Hashtable for 
large collections. Hence it provides very efficient storage for both small and large collections. 

OrderedDictionary supports sorting based on the key. It has similar disadvantages for small collections to Hashtable on which it is based. 

ListDictionary is ideal for small collections because it is implemented as a light-weight linked list. 
Performance will suffer for large collections. 

HashTable is ideal for large collections, for small collections the overheads of such a sophisticated 
data structure do not compensate for the benefits. 











QUESTION NO: 221 

You work as the application developer at CertKiller.com. You are working on an application and 
want to use platform invoke services to call an unmanaged function from managed code. 

How will you accomplish the task? 

A. Create a class to store DLL functions. Create prototype methods by using the managed code. 
B. Use COM to register the assembly. Reference the managed code from COM. 
C. Export a type library for the managed code. 
D. Import a type library as an assembly. Create instances of COM object. 




















Answer: A 

Explanation: 

It is good practice to wrap the messy P-Invoke code with a .net class. The main benefit is to keep 
the client code tidy as the messy and cryptic code will be hidden away. Also better for 
maintenance e.g dll name or version changes. 

The question explicitly says the unmanaged code should be called with platform invoke services. 
Importing\exporting a type library is relevant for interoperation with COM. 











QUESTION NO: 222 

You work as the application developer at CertKiller.com. You must identify which specific type 
meets this criteria: ? 
Is always a number.? 
Is not greater than 65,535. 


Select the type you should use to meet the criteria. 


A. Choose System.UInt16 
B. Choose int 
C. Choose System.String 
D. Choose System.IntPtr 




















Answer: A 

Explanation: 

System.UInt16 is the most efficient type for storing positive whole numbers up to 65,536. 

An int type could be used but it is a lot wider than necessary. 

System.String is intended for storing immutable strings. 

System.IntPtr is a pointer to a memory address and it's size is determined by the runtime platform. 
It is primarily used for interoperation. 











QUESTION NO: 223 

You work as the application developer at CertKiller.com. You are working on an application named 
CertKillerApp11. CertKillerApp11 must be configured to execute a series of mathematical 
computations simultaneously. 

What should you do next to configure CertKillerApp11 to execute a series of mathematical 
computations simultaneously? 

A. Configure the IdealProcessor property of the ProcessThread object. 
B. Configure the ProcessorAffinity property of the ProcessThread object. 
C. Call the QueueUserWorkItem method of the ThreadPool class for each calculation which 
should be performed by CertKillerApp11. 
D. Configure the Process.GetCurrentProcess().BasePriority property to be High. 




















Answer: C 

Explanation: 

The ThreadPool class allows background tasks to run in parallel hence calculations can be 
queued to run as soon as a ThreadPool Worker thread becomes available. Because the 
ThreadPool can manage many worker threads, calculations will run in parallel. 

ProcessThread.IdealProcessor requests a preferred processor for the thread to run on, it will not 
however spawn a new thread - which is what is required here to enable concurrency. 

ProcessorAffinity gets or sets the processors that this thread can be scheduled to run on. 

Process.BasePriority gets the base priority of the process. 









QUESTION NO: 224 

You work as the application developer at CertKiller.com. An existing application used by 
CertKiller.com is named CertKillerApp15. CertKillerApp15 runs on a shared computer, and was 
compiled using .NET Framework version 1.0. The .NET Framework version 1.0 and .NET 
Framework version 1.1 is installed on the shared computer. 

You have been instructed to move CertKillerApp15 to a new computer. This computer has .NET 
Framework version 1.1 and .NET Framework version 2.0 installed. You verify that CertKillerApp15 
is only compatible with the .NET Framework 1.1. 

You must configure CertKillerApp15 to use .NET Framework version 1.1 after it has been moved 
to the new computer. 

What should you do next? 

A. Add this XML element to the CertKillerApp15configuration file: 
<configuration> 
<startup> 
<supportedRuntime version="1.1.4322" /> 
<startup> 
</configuration> 
B. Add this XML element to the CertKillerApp15configuration file: 
<configuration> 
<runtime> 
<assemblyBinding 
xmlns="urn:schemas-microsoft-com:asm.v1"> 
<dependentAssembly> 
<assemblyIdentity name="Application1" 
publicKeyToken="32ab4ba45e0a69a1" 
culture="neutral" /> 
<bindingRedirect oldVersion="1.0.3075.0" 
newVersion="1.1.4322.0"/> 
</dependentAssembly> 
</assemblyBinding> 
</runtime> 
</configuration> 
C. Add this XML element to the computerconfiguration file: 
<configuration> 
<startup> 
<requiredRuntime version="1.1.4322" /> 
<startup> 
</configuration> 

D. Add this XML element to the computerconfiguration file: 
<configuration> 
<runtime> 
<assemblyBinding 
xmlns="urn:schemas-microsoft-com:asm.v1"> 
<dependentAssembly> 
<assemblyIdentity name="Application1" 
publicKeyToken="32ab4ba45e0a69a1" 
culture="neutral" /> 
<bindingRedirect oldVersion="1.0.3075.0" 
newVersion="1.1.4322.0"/> 
</dependentAssembly> 
</assemblyBinding> 
</runtime> 
</configuration> 




















Answer: A 











QUESTION NO: 225 

You work as the application developer at CertKiller.com. You are developing a strong-named 
assembly named CertKillerAss3. CertKillerAss3 will be used by multiple applications. You plan to 
frequently rebuild CertKillerAss3 during the development lifecycle. Whenever CertKillerAss3 is 
rebuilt, you must ensure that it works as expected with all applications that will use it. 

You must configure the computer that you are using to create CertKillerAss3 so that all 
applications reference the latest build of CertKillerAss3. 

Choose the two actions which you should perform to achieve your goal. Each correct answer 
presents only part of the complete solution. 

A. Create a DEVPATH environment variable which points to the build output directory for 
CertKillerAss3. 
B. Include this XML element in the computer configuration file: 
<developmentMode developerInstallation="true"/> 
C. Include this XML element in the computer configuration file: 
<dependentAssembly> 
<assemblyIdentity name=" CertKillerAss3" 
publicKeyToken="32ab4ba45e0a69a1" 
language="en-US" version="*.*.*.*" /> 
<publisherPolicy apply="no" /> 
</dependentAssembly> 

D. Include this XML element in the configuration file of each application that must use 
CertKillerAss3: 
<supportedRuntime version="*.*.*.*" /> 
E. Include this XML element in the configuration file of each application that must use 
CertKillerAss3: 
<dependentAssembly> 
<assemblyIdentity name=" CertKillerAss3" 
publicKeyToken="32ab4ba45e0a69a1" 
language="en-US" version="*.*.*.*" /> 
<bindingRedirect newVersion="*.*.*.*"/> 
</dependentAssembly> 




















Answer: A,B 

Explanation: 

The developmentmode element in the machine configuration file tells the .net runtime to locate the 
assembly by using the DevPath environment variable. 

The SupportedRuntime element specifies which .net runtime versions the assembly supports. 

The DependentAssembly element is used to encapsulate the binding policy and assembly location 
for each assembly. 











QUESTION NO: 226 

You work as the application developer at CertKiller.com. You are developing a new class named 
CertKillerClass. CertKillerClass contains a method named CertKillerMethod, and a number of child 
objects which are serializable. CertKillerMethod will execute actions on all child objects. 

You want make to certain that CertKillerMethod is applied whenever CertKillerClass and its 
associated child objects are rebuilt. 

Choose the two actions which you should perform next? Each correct answer presents only part of 
the complete answer. 

A. Apply the OnDeserializing attribute to the CertKillerMethod method. 
B. Define CertKillerClass to implement the IDeserializationCallback interface. 
C. Define CertKillerClass to inherit from the ObjectManager class. 
D. Apply the OnSerialized attribute to CertKillerMethod. 
E. Create a GetObjectData method that calls CertKillerMethod. 
F. Create an OnDeserialization method that calls CertKillerMethod. 




















Answer: B,F 

Explanation: 

The iDeserializationCallback interface allows some custom code to be called after the complete 
object graph has been deserialized via the onDeserialization method. In this case the 
CertKillerMethod should be called in the onDeserialization method. 

Applying OnDeserializingAttribute to CertKillerMethod will not work because there is not guarantee 
that the complete object graph will have been deserialized. 

If CertKillerClass inherits from ObjectManager it will still have to implement 
iDeserializationCallback to perform actions after the complete object graph has been deserialized. 

The OnSerialized attribute signifies that a method should be called immediately after serialization 
of the object. 











QUESTION NO: 227 

You work as the application developer at CertKiller.com. You have created a new service 
application named CertKillerApp33. CertKillerApp33 must still be deployed into the CertKiller.com 
network. A CertKiller.com network administrator named Mia Hamm has already created a user 
account for CertKillerApp33. 

You must configure CertKillerApp33 to run in the context of this new user account. 

What should you do next? 

A. Before deploying CertKillerApp33, specify the StartType property of the ServiceInstaller class. 
B. Before deploying CertKillerApp33, specify the Account, Username, and Password properties of 
the ServiceProcessInstaller class. 
C. Install the service by using the CONFIG option of the net.exe command-line tool. 
D. Install the service by using the installutil.exe command-line tool. 




















Answer: B 

Explanation: 

The ServiceProcessInstaller class is automatically called during installation. It is the ideal place to 
specify the default service settings such as account credentials. 

ServiceInstaller.StartType controls how the service will start up e.g automatically or manually. It 

"Pass Any Exam. Any Time." 

You must set specific security settings for the new file. You must ensure that file inheritance of any 
default security settings is denied. 

What should you do next? Answer by arranging the relevant actions in the proper order. 

Microsoft 70-536: Practice Exam 

has nothing to do with a specific account. 
Net.exe with the config option is used to configure the server or workstation services. 
Installutil.exe can be used to install the service but it is not possible to specify or override service 


account credentials. They have to be specified in the ServiceProcessInstaller class. 












QUESTION NO: 228 DRAG DROP 

You work as the application developer at CertKiller.com. You are working on an application named 
CertKillerApp05. CertKillerApp05 is configured to create a new file on the local file system. 





















Answer: 










QUESTION NO: 229 
You work as the application developer at CertKiller.com. 

You are working on method to call a COM component, and must use declarative security to 
explicitly request the runtime to perform a full stack walk. Before allowing any callers to execute 
the method, they must have the required level of trust for COM interop. 

Choose the attribute that should be used on the method. 

A. Use this attribute: [SecurityPermission( 
SecurityAction::Demand, 
Flags=SecurityPermissionFlag::UnmanagedCode)] 
B. Use this attribute: [SecurityPermission( 
SecurityAction::LinkDemand, 
Flags=SecurityPermissionFlag::UnmanagedCode)] 
C. Use this attribute: [SecurityPermission( 
SecurityAction::Assert, 
Flags = SecurityPermissionFlag::UnmanagedCode)] 
D. Use this attribute: [SecurityPermission( 
SecurityAction::Deny, 
Flags = SecurityPermissionFlag::UnmanagedCode)] 




















Answer: A 

Explanation: 

A Demand should be used on the SecurityPermission attribute with the UnmanagedCode flag to 
force all callers in the call stack to have permission to call unmanaged components. 

LinkDemand will only force the immediate caller to have the permission. 

Assert will ignore the permissions of callers and allow them indiscriminately. 

Deny will explicitly deny access if the caller has the specified permission. This is the reverse of 
what is required. 











QUESTION NO: 230 DRAG DROP 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp09. CertKillerApp09 is configured to monitor free space on a hard disk drive. 

You must perform the configuration that will result in CertKillerApp09 monitoring free space at one 
minute intervals. You must also configure CertKillerApp09 to run in the background. What should you do next? Answer by arranging the relevant actions in the proper order. 

ActualTests.com



















Answer: 










QUESTION NO: 231 

You work as the application developer at CertKiller.com. You are creating a new custom-collection 
class. 

You must create the method that will be contained within the class. The method you need to 
create must return a type which is compatible with the Foreach statement. 

Choose the criterion which your method must meet to match your requirement. 

A. Your method has to return a type of either IEnumerator or IEnumerable. 
B. Your method has to return a type of IComparable. 
C. Your method has to explicitly contain a collection. 
D. Your method has to be the only iterator in the class. 




















Answer: A 

Explanation: 

Returning an IEnumerator will enable the ForEach statement. IEnumerable is a subtype of 
IEnumerator hence can also be up cast to IEnumerator. 

IComparable is used to enable comparisons for a user type. 

Explicitly containing a collection within the method will have no impact on the methods return type 
which is what the ForEach statement will operate on. 











QUESTION NO: 232 

You work as the application developer at CertKiller.com. You are creating a new custom event 
handler that will be set up to automatically print all open documents. The custom event handler 
must also assist in identifying how many document copies must be printed. 

You must determine which custom event arguments class to pass as a parameter to the custom 
event handler. 

Choose the code segment which you should use to accomplish this task. 

A. public class PrintingArgs { 
private int copies; 
public PrintingArgs(int numberOfCopies) { 
this.copies = numberOfCopies; 
} 
public int Copies { 
get { return this.copies; 
} 
}} 
B. public class PrintingArgs : EventArgs { 
private int copies; 
public PrintingArgs(int numberOfCopies) { 
this.copies = numberOfCopies; 
} 
public int Copies { 
get { return this.copies; 
} 
}} 


C. public class PrintingArgs { 
private EventArgs eventArgs; 
public PrintingArgs(EventArgs ea) { 
this.eventArgs = ea; 
}public EventArgs Args {get { return eventArgs; 
}}} 
D. public class PrintingArgs : EventArgs { 
private int copies; 
} 




















Answer: B 

Explanation: 

The event handler will require a parameter of type EventArgs or a derived type. The derived type 
in this example will question states that the event handler helps specify the number of documents 
that require printing, this information will have to come from the derived EventArgs class in the 
form of an instance variable. 

A & C do not derive from EventArgs hence cannot fit into the event handling model. 

D does not expose the copies instance variable. 











QUESTION NO: 233 

You work as the application developer at CertKiller.com. You are working on a new method 
named PersistToDB. PersistToDB returns no value, and takes the EventLogEntry parameter type. 

You must create the specific code segment which will enable you to test whether the new method 
works as expected. The code segment you use must be able to access entries from the 
application log of local computers, and must then pass only specific entries on to PersistToDB. 
The relevant entries to be passed to PersistToDB are Error events and Warning events from the 
source named mySource. 

Choose the code segment which would achieve your goal in these circumstances. 

A. EventLog myLog = new EventLog("Application", "."); 
foreach (EventLogEntry entry in myLog.Entries) 
{ 
if (entry.Source == "MySource") 
{ 
PersistToDB(entry); 
} 
} 

B. EventLog myLog = new EventLog("Application", "."); 
myLog.Source = "MySource"; 
foreach (EventLogEntry entry in myLog.Entries) 
{ 
if (entry.EntryType == (EventLogEntryType.Error & 
EventLogEntryType.Warning)) 
{ 
PersistToDB(entry); 
} 
} 
C. EventLog myLog = new EventLog("Application", "."); 
foreach (EventLogEntry entry in myLog.Entries) 
{ 
if (entry.Source == "MySource") 
{ 
if (entry.EntryType == EventLogEntryType.Error || 
entry.EntryType == EventLogEntryType.Warning) 
{ 
PersistToDB(entry); 
} 
} 
} 
D. EventLog myLog = new EventLog("Application", "."); 
myLog.Source = "MySource"; 
foreach (EventLogEntry entry in myLog.Entries) 
{ 
if (entry.EntryType == EventLogEntryType.Error || 
entry.EntryType == EventLogEntryType.Warning) 
{ 
PersistToDB(entry); 
} 




















Answer: C 

Explanation: 

It is necessary to create a new Application EventLog, iterate over all the EventLogEntries and call 
the PersistToDB method if the entry is a warning or error and the source is MySource. 

A will PersistToDb irrespective of the type of log entry. The question explicitly states only warnings and errors should be persisted. 

B features an incorrect test for warnings and errors. 

D&B do not ensure that only MySource entries are persisted. Instead they overwrite the source. 











QUESTION NO: 234 

You work as the application developer at CertKiller.com. You have created a new application 
named CertKillerApp05. CertKillerApp05 is configured to forward an e-mail message. The SMTP 
server on the local subnet is named CERTKILLER-SR31. 

You want to test CertKillerApp05. You decide to use a source address of mia@CertKiller.com; and 
a target address of dest@CertKiller.com. 

Choose the code segment which you should use to test whether CertKillerApp05 sends e-mail 
messages. 

A. MailAddress addrFrom = 
new MailAddress("mia@CertKiller.com", "Mia"); 
MailAddress addrTo = 
new MailAddress("dest@CertKiller.com", "Dest"); 
MailMessage message = new MailMessage(addrFrom, addrTo); 
message.Subject = "Hello"; 
message.Body = "Test Message"; 
message.Dispose(); 
B. string strSmtpClient = "CERTKILLER-SR31"; 
string strFrom = " mia@CertKiller.com"; 
string strTo = "dest@CertKiller.com"; 
string strSubject = "Hello"; 
string strBody = "Test Message"; 
MailMessage msg = 
new MailMessage(strFrom, strTo, strSubject, strSmtpClient); 
C. MailAddress addrFrom = new MailAddress("mia@CertKiller.com"); 
MailAddress addrTo = new MailAddress("dest@CertKiller.com"); 
MailMessage message = new MailMessage(addrFrom, addrTo); 
message.Subject = " Hello"; 
message.Body = "Test Message "; 
SmtpClient client = new SmtpClient("CERTKILLER-SR31"); 
client.Send(message); 
D. MailAddress addrFrom = 
new MailAddress("mia@CertKiller.com", "Mia"); 
MailAddress addrTo = 
new MailAddress("dest@CertKiller.com", "Dest"); 
MailMessage message = new MailMessage(addrFrom, addrTo); 
message.Subject = " Hello"; 
message.Body = " Test Message"; 
SocketInformation info = new SocketInformation(); 
Socket client = new Socket(info); 
System.Text.ASCIIEncoding enc = 
new System.Text.ASCIIEncoding(); 
byte[] msgBytes = enc.GetBytes(message.ToString()); 
client.Send(msgBytes); 






















Answer: C 

Explanation: 

To Send a simple mail message construct a MailMessage object and a SmptClient object. Call the 
SmtpClient.Send instance method supplying the MailMessage object as a parameter. 

A creates a MailMessage but then destroys it. 

B creates a MailMessage but then does not do anything with it. 

D tries to do something with sockets, this is unnecessary because there is a SMTP server 
available. The question implies delivering the mail via SMTP. 











QUESTION NO: 235 

You work as the application developer at CertKiller.com. You are working on a new application 
named CertKillerApp20. CertKillerApp20 is configured to perform a series of mathematical 
calculations. You create a class named CertKillerAppClass and create a procedure named 
CertKillerAppSP. CertKillerAppSP must execute on an instance of the class. 

You must configure the application's user interface so that it continues to respond for the duration 
that calculations are performed. You must write the code segment for calling the CertKillerAppSP 
procedure which will accomplish your objective. 

Choose the code segment which you should use. 

A. private void CertKillerAppSP() {...} private void DoWork(){ 
CertKillerAppClass myValues = new CertKillerAppClass(); 
Thread newThread = new Thread( 
new ThreadStart(CertKillerAppSP)); 
newThread.Start(myValues); 
} 

B. private void CertKillerAppSP() {...} private void DoWork(){ 
CertKillerAppClass myValues = new CertKillerAppClass(); 
ThreadStart delStart = new 
ThreadStart(CertKillerAppSP); 
Thread newThread = new Thread(delStart); 
if (newThread.IsAlive) {newThread.Start(myValues); 
}} 
C. private void CertKillerAppSP (CertKillerAppClass values) {...} private void DoWork(){ 
CertKillerAppClass myValues = new CertKillerAppClass(); 
Application.DoEvents(); 
CertKillerAppSP(myValues); 
Application.DoEvents(); 
} 
D. private void CertKillerAppSP(object values) {...} private void DoWork(){ 
CertKillerAppClass myValues = new CertKillerAppClass(); 
Thread newThread = new Thread( 
new ParameterizedThreadStart(CertKillerAppSP)); 
newThread.Start(myValues); 
} 




















Answer: D 

Explanation: 

It is a requirement that the UI continues to respond, hence CertKillerAppSP should execute in a 
separate thread. CertKillerAppSP requires a parameter hence you should use the 
ParameterizedThreadStart delegate. 

A& B attempt to supply a parameter to the ThreadStart delegate. This is not possible. 

C Does not run in a new thread and hence may leave the UI unresponsive. 











QUESTION NO: 236 

You work as the application developer at CertKiller.com. You create the following code segment: 

public delegate void FaxDocs(object sender, FaxArgs args); 

What should you do next to configure an event that will call FaxDocs? 

Choose the code segment which you should use. A. public static event FaxDocs Fax; 
B. public static event Fax FaxDocs; 
C. public class FaxArgs : EventArgs { 
private string coverPageInfo; 
public FaxArgs(string coverInfo) { 
this.coverPageInfo = coverPageInfo; 
} 
public string CoverPageInformation { 
get {return this.coverPageInfo; 
} 
}} 
D. public class FaxArgs : EventArgs { 
private string coverPageInfo; 
public string CoverPageInformation { 


get {return this.coverPageInfo; 
} 
}} 






















Answer: A 

Explanation: 

An event is declared by using the event keyword followed by a delegate type and then a name for 
the event. 

B fax is not a delegate type. 
C&D do not declare events. 











QUESTION NO: 237 

You work as the application developer at CertKiller.com. You create a code segment that will call a 
function from the Win32 Application Programming Interface (API) via platform invoke. The precise 
code segment is: 


string personName = "N?el"; 
string msg = "Thank you " + personName + " for coming ''!"; 
bool rc = User32API.MessageBox(0, msg, personName, 0); 


You must specify the prototype method that will efficiently assemble the string data. 


Choose the code segment which will accomplish the task. 
A. [DllImport("user32", CharSet = CharSet.Ansi)]public static extern bool MessageBox(int hWnd, 
String text, String caption, uint type); 
} 
B. [DllImport("user32", EntryPoint = "MessageBoxA", CharSet = CharSet.Ansi)]public static extern 
bool MessageBox(int hWnd, 
[MarshalAs(UnmanagedType.LPWStr)]String text, 
[MarshalAs(UnmanagedType.LPWStr)]String caption, 
uint type); 
} 
C. [DllImport("user32", CharSet = CharSet.Unicode)]public static extern bool MessageBox(int 
hWnd, String text, String caption, uint type); 
} 
D. [DllImport("user32", EntryPoint = "MessageBoxA", CharSet = CharSet.Unicode)]public static 
extern bool MessageBox(int hWnd, 
[MarshalAs(UnmanagedType.LPWStr)]String text, 
[MarshalAs(UnmanagedType.LPWStr)]String caption, 
uint type); 
} 




















Answer: C 











QUESTION NO: 238 

You work as the application developer at CertKiller.com. You create a method which will compress 
an array of bytes. A parameter named document is used to pass the array to your method. 

You want to compress the received array of bytes or data, and then want to return the result as an 
array of bytes. 

Choose the code segment which will achieve your goal. 

A. MemoryStream strm = new MemoryStream(document); 
DeflateStream deflate = new DeflateStream(strm, 
CompressionMode.Compress); 
byte[] result = new byte[document.Length]; 
deflate.Write(result, 0, result.Length); 
return result; 
B. MemoryStream strm = new MemoryStream(document); 
DeflateStream deflate = new DeflateStream(strm, 
CompressionMode.Compress); 
deflate.Write(document, 0, document.Length); 
deflate.Close(); 
return strm.ToArray(); 

C. MemoryStream strm = new MemoryStream(); 
DeflateStream deflate = new DeflateStream(strm, 
CompressionMode.Compress); 
deflate.Write(document, 0, document.Length); 
deflate.Close(); 
return strm.ToArray(); 
D. MemoryStream inStream = new MemoryStream(document); 
DeflateStream deflate = new DeflateStream(inStream, 
CompressionMode.Compress); 
MemoryStream outStream = new MemoryStream(); 
int b; 
while ((b = deflate.ReadByte()) != -1) { 
outStream.WriteByte((byte)b); 
} return outStream.ToArray(); 




















Answer: C 

Explanation: 

The document is compressed and written to a new MemoryStream using the Deflate class. Finally 
the compressed data can be returned as an array of bytes using the ToArray method of the 
MemoryStream. 

A does not compress and write the document, instead it is compressing and writing an empty 
array 

B & D are reading and writing to the same document. 











QUESTION NO: 239 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp05. CertKillerApp05 is configured to use SOAP to exchange data with other 
applications deployed on the CertKiller.com network. 

In your configuration, you specify that a class named Department inherits from ArrayList to pass 
objects to the other application. The Department object is named department. 

You must perform the configuration which will enable the application to serialize the Department 
object for transport via SOAP. 

Choose the code segment which will accomplish this task. A. SoapFormatter formatter = new SoapFormatter(); 
byte[] buffer = new byte[CertKiller.Capacity]; 
MemoryStream stream = new MemoryStream(buffer);foreach 
(object o in department) { 
formatter.Serialize(stream, o); 
} 
B. SoapFormatter formatter = new SoapFormatter(); 
byte[] buffer = new byte[department.Capacity]; 
MemoryStream stream = new MemoryStream(buffer); 
formatter.Serialize(stream, department); 
C. SoapFormatter formatter = new SoapFormatter(); 
MemoryStream stream = new MemoryStream(); 
foreach (object o in department) { 
formatter.Serialize(stream, o); 
} 
D. SoapFormatter formatter = new SoapFormatter(); 
MemoryStream stream = new MemoryStream(); 
formatter.Serialize(stream, department); 




















Answer: D 

Explanation: 

Simply serialize the entire object to a stream using a SoapFormatter. 

A&C attempt to serialize components of the object rather the object itself. 

B attempts to serialize to an array, however the array will not be big enough to store the serialized 
object because it is not sized on the entire object. 











QUESTION NO: 240 

You work as the application developer at CertKiller.com. You are developing a class definition. 
Your class definition must be able to interoperate with COM applications. 

You must create a code segment that will allow COM applications to create instances of the class. 
COM applications must also be able to call the method named GetAddress. 

Choose the code segment which you should use. 

A. public class Customer { 
string addressString; 
public Customer(string address) { addressString = address; 
} 
public string GetAddress() { return addressString; 
}} 


B. public class Customer { 
static string addressString; 
public Customer() { } 
public static string GetAddress() { return addressString; 
}} 
C. public class Customer { 
string addressString; 
public Customer() { } 
public string GetAddress() { return addressString; 
}} 
D. public class Customer { 
string addressString; 
public Customer() { } 
internal string GetAddress() { return addressString; 
}} 




















Answer: C 

Explanation: 

The class should be declared with a parameter less constructor and the getAddress() method 
should be public. 

A uses a constructor with Parameters. 

B uses static members that are not supported in COM 

D the method GetAddress() must be public to be accessible by COM. 











QUESTION NO: 241 

You work as the application developer at CertKiller.com. You are creating a class library which 
must be able to access system environment variables. 

You must set a call method which will only force a runtime SecurityException if the callers which 
are higher in the call stack, fail to have the required permissions. 

Choose the call method which will do this. A. Use set.Demand(); 
B. Use set.Assert(); 
C. Use set.PermitOnly(); 
D. Use set.Deny(); 




















Answer: A 

Explanation: 

Demand forces all callers in the call stack to have the specified permission. 

PermitOnly will instruct the runtime to reduce the access by only allowing callers with the 
permissions explicitly stated and nothing else. 

Assert will ignore the permissions of callers and allow them indiscriminately. 

Deny will explicitly deny access if the caller has the specified permission. 











QUESTION NO: 242 

You work as the application developer at CertKiller.com. You are creating a new method that will 
hash specific data with the Secure Hash Algorithm (SHA-1). 

The data must be passed to your method as a byte array named hashdata. The resultant data 
must then be passed to a byte array named hash. 

Choose the code segment which will achieve your goal. 

A. SHA1 sha = new SHA1CryptoServiceProvider(); 
byte[] hash = null; 
sha.TransformBlock( 
hashdata, 0, hashdata.Length, hash, 0); 
B. SHA1 sha = new SHA1CryptoServiceProvider(); 
byte[] hash = BitConverter.GetBytes(sha.GetHashCode()); 
C. SHA1 sha = new SHA1CryptoServiceProvider(); 
byte[] hash = sha.ComputeHash(hashdata); 
D. SHA1 sha = new SHA1CryptoServiceProvider(); 
sha.GetHashCode(); 
byte[] hash = sha.Hash; 




















Answer: C 

Explanation: Initialise SHA1 object and call the ComputeHash method supplying the hashdata as a parameter 
to return the hash code as an array of bytes. 

A TransferBlock is more appropriate for hashing part of a hashdata. Also it should be called with 
TransferEndBlock. 

B&C GetHashCode is the method inherited from the Object class. It will not perform a hash on the 
incoming hashdata. 











QUESTION NO: 243 

You work as the application developer at CertKiller.com. You are creating a new method that must 
hash specific data by applying the MD5 algorithm. 

You must write the hash of the incoming parameter by using the MD5 algorithm. The data must be 
passed to your method as a byte array named message. The resultant data must then be placed 
into a byte array. 

Choose the code segment which will achieve your goal. 

A. HashAlgorithm algo = HashAlgorithm.Create("MD5"); 
byte[] hash = algo.ComputeHash(message); 
B. HashAlgorithm algo = HashAlgorithm.Create("MD5"); 
byte[] hash = BitConverter.GetBytes(algo.GetHashCode()); 
C. HashAlgorithm algo; 
algo = HashAlgorithm.Create(message.ToString()); 
byte[] hash = algo.Hash; 
D. HashAlgorithm algo = HashAlgorithm.Create("MD5"); 
byte[] hash = null; 
algo.TransformBlock(hashdata, 0, message.Length, message, 0); 




















Answer: A 

Explanation: 

Create a HashAlgorithm object based on the MD5 algorithm and call the ComputerHash method 
that will return the hash as an array of bytes. 

B GetHashCode() will call the method inherited from object, it will not hash the message. 

C The parameter of the Create method should specify the type of hashing algorithm to use not the 
message to be hashed. D TransferBlock is more appropriate for hashing part of a message. Also it should be called with 
TransferEndBlock. 











QUESTION NO: 244 

You work as the application developer at CertKiller.com. You have created a new dynamic 
assembly named CertKillerAssembly and must ensure that the assembly is saved to disk. 

Choose the code segment which you should use. 

A. AssemblyName myAssemblyName = 
new AssemblyName(); 
myAssemblyName.Name = "CertKillerAssembly"; 
AssemblyBuilder myAssemblyBuilder = 
AppDomain.CurrentDomain.DefineDynamicAssembly 
(myAssemblyName, AssemblyBuilderAccess.Run); 
myAssemblyBuilder.Save("CertKillerAssembly.dll"); 
B. AssemblyName myAssemblyName = 
new AssemblyName(); 
myAssemblyName.Name = " CertKillerAssembly"; 
AssemblyBuilder myAssemblyBuilder = 
AppDomain.CurrentDomain.DefineDynamicAssembly 
(myAssemblyName, AssemblyBuilderAccess.Save); 
myAssemblyBuilder.Save("CertKillerAssembly.dll"); 
C. AssemblyName myAssemblyName = 
new AssemblyName(); 
AssemblyBuilder myAssemblyBuilder = 
AppDomain.CurrentDomain.DefineDynamicAssembly 
(myAssemblyName, AssemblyBuilderAccess.RunAndSave); 
myAssemblyBuilder.Save("CertKillerAssembly.dll"); 
D. AssemblyName myAssemblyName = 
new AssemblyName("CertKillerAssembly"); 
AssemblyBuilder myAssemblyBuilder = 
AppDomain.CurrentDomain.DefineDynamicAssembly 
(myAssemblyName, AssemblyBuilderAccess.Save); 
myAssemblyBuilder.Save("c:\\CertKillerAssembly.dll"); 




















Answer: B 

Explanation: 

Create an AssemblyName object and use it to construct an AssemblyBuilder with save privilege. 
Finally call the Save method on the AssemblyBuilder to write the assembly to disk. A Creates an assembly that does not have the privilege to save to disk. 

C does not provide a name the assembly 

D attempts to define a physical file location, this is not compatible with AssemblyBuilder.Save 











QUESTION NO: 245 

You work as the application developer at CertKiller.com. You are creating a new code segment 
which is to be used for user authentication and authorization purposes. The current application 
data store already stores the username, password, and roles. 


You must establish the user security context, which should be used for the authorization checks 
like IsInRole. To authorize the user, you have started developing the following code segment: 


if (!TestPassword(userName, password)) 
throw new Exception("user not authenticated"); 
String[] userRolesArray = LookupUserRoles(userName); 


From the options below, choose the code which will make the code segment complete. 


A. GenericIdentity ident = new GenericIdentity(userName); 
GenericPrincipal currentUser = 
new GenericPrincipal(ident, userRolesArray); 
Thread.CurrentPrincipal = currentUser; 
B. WindowsIdentity ident = new WindowsIdentity(userName); 
WindowsPrincipal currentUser = new WindowsPrincipal(ident); 
Thread.CurrentPrincipal = currentUser; 
C. NTAccount userNTName = new NTAccount(userName); 
GenericIdentity ident = new GenericIdentity(userNTName.Value); 
GenericPrincipal currentUser= new GenericPrincipal(ident, userRolesArray); 
Thread.CurrentPrincipal = currentUser; 
D. IntPtr token = IntPtr.Zero; 
token = LogonUserUsingInterop(userName, encryptedPassword); 
WindowsImpersonationContext ctx = 
WindowsIdentity.Impersonate(token); 




















Answer: A 

Explanation: Because the application storing the credentials, the GenericIdentity & GenericPrincipal classes 
should be used instead of the WindowsIdentity\Principal classes. 

B uses WindowsIdentity & WindowsPrincipal 

C incorrectly uses NTAccount to initialise a GenericPrincipal. GenericPrincipal requires an 
implementation of IIdentity. 

D the WindowsIdentity.Impersonate() is used for running code in the context of another user. 
Impersonation is not what is required. 











QUESTION NO: 246 

You work as the application developer at CertKiller.com. You are creating a new application 
named at CertKillerApp11. CertKillerApp11 will be used for a CertKiller.com business partner. The 
CertKiller business partner has offices in Hong Kong. 

You must write the code segment which will show all negative currency values by using a minus 
sign. 

Choose the code segment which you should use. 

A. NumberFormatInfo culture = 
new CultureInfo("zh-HK").NumberFormat; 
culture.NumberNegativePattern = 1; 
return numberToPrint.ToString("C", culture); 
B. NumberFormatInfo culture = 
new CultureInfo("zh-HK").NumberFormat; 
culture.CurrencyNegativePattern = 1; 
return numberToPrint.ToString("C", culture); 
C. CultureInfo culture = 
new CultureInfo("zh-HK"); 
return numberToPrint.ToString("-(0)", culture); 
D. CultureInfo culture = 
new CultureInfo("zh-HK"); 
return numberToPrint.ToString("()", culture); 




















Answer: B 

Explanation: 

Use CurrencyNegativePattern property set to 1 to display negative currency values with a minus 
sign. A will give a minus sign for negative numbers but not for negative currencies. 

C & D The culture has not been to display a minus sign for currency. 











QUESTION NO: 247 

You work as the application developer at CertKiller.com. You are developing a new application. 
You must define the code segment which will create a common language runtime (CLR) unit of 
isolation within the new application. 

Choose the code segment which you should use to accomplish this task. 

A. AppDomainSetup mySetup = AppDomain.CurrentDomain.SetupInformation; 
mySetup.ShadowCopyFiles = "true"; 
B. System.Diagnostics.Process myProcess; 
myProcess = new System.Diagnostics.Process(); 
C. AppDomain domain; 
domain = AppDomain.CreateDomain("CertKillerDomain"); 
D. System.ComponentModel.Component myComponent; 
myComponent = new System.ComponentModel.Component(); 




















Answer: C 

Explanation: 

Create a new ApplicationDomain using the AppDomain.CreateDomain() method. 

A ShadowCopyFiles property of AppDomainSetup controls whether shadow copying is enabled or 
disabled. 

B the Process class is used to represent an existing process running on a computer. 

D The ComponentModel.Component class is used for sharing components between applications. 











QUESTION NO: 248 

You work as the application developer at CertKiller.com. You are working on a new application 
named CertKillerApp05. CertKillerApp05 is configured to dynamically load assemblies from the 
application directory. 

You must define the code segment that will dynamically load an assembly named 
CertKillerAss25.dll into the current application domain. Choose the code segment which you should use to accomplish this task. 

A. AppDomain domain = AppDomain.CurrentDomain; 
string myPath = Path.Combine(domain.BaseDirectory,"CertKillerAss25.dll"); 
Assembly asm = Assembly.LoadFrom(myPath); 
B. AppDomain domain = AppDomain.CurrentDomain; 
string myPath = Path.Combine(domain.BaseDirectory,"CertKillerAss25.dll 
Assembly asm = Assembly.Load(myPath); 
C. AppDomain domain = AppDomain.CurrentDomain; 
string myPath = Path.Combine(domain.DynamicDirectory,"CertKillerAss25.dll"); 
Assembly asm = AppDomain.CurrentDomain.Load(myPath); 
D. AppDomain domain = AppDomain.CurrentDomain; 
Assembly asm = domain.GetData("CertKillerAss25.dll"); 




















Answer: A 

Explanation: 

The Assembly.LoadFrom() method can be called to dynamically load an assembly from file. 

B the Load method requires an AssemblyName object as a parameter. 

C it is not possible to use AppDomain.Load to load an assembly from file. 

D AppDomain.GetData gets information stored in the AppDomain for the specified assembly. It 
cannot load an assembly. 











QUESTION NO: 249 

You work as the application developer at CertKiller.com. You are creating a new code segment. 
You must ensure that the data contained within an isolated storage file, named Settings.dat, is 
returned as a string. Settings.dat is machine-scoped. 

Choose the code segment which will achieve your goal. 

A. IsolatedStorageFileStream isoStream; 
isoStream = new IsolatedStorageFileStream( "Settings.dat", FileMode.Open); 
string result = new StreamReader(isoStream).ReadToEnd(); 
B. IsolatedStorageFile isoFile; 
isoFile = IsolatedStorageFile.GetMachineStoreForAssembly(); 
IsolatedStorageFileStream isoStream; 
isoStream = new IsolatedStorageFileStream("Settings.dat", FileMode.Open, isoFile); 
string result = new StreamReader(isoStream).ReadToEnd(); 
C. IsolatedStorageFileStream isoStream; 
isoStream = new IsolatedStorageFileStream( "Settings.dat", FileMode.Open); 
string result = isoStream.ToString(); 
D. IsolatedStorageFile isoFile; 
isoFile = IsolatedStorageFile.GetMachineStoreForAssembly(); 
IsolatedStorageFileStream isoStream; 
isoStream = new IsolatedStorageFileStream("Settings.dat", FileMode.Open, isoFile); 
string result = isoStream.ToString(); 




















Answer: B 

Explanation: 

Retrieve the IsolatedStorageFile for the machine store. Use an IsolatedStorageFileStream to read 
from the desired file within the machine store. 

A & C do not get the IsolatedStorageFile for the machine context. 

D returns a string representation of the IsolatedStorageFileStream object not a String of the files 
contents as the question requests. 











QUESTION NO: 250 

You work as the application developer at CertKiller.com. You are creating a new class which 
contains a method named GetCurrentRate. GetCurrentRate extracts the current interest rate from 
a variable named currRate. currRate contains the current interest rate which should be used. 

You develop serialized representations of the class and now need to write a code segment which 
updates the currRate variable with the current interest rate if an instance of the class is 
deserialized. 

Choose the code segment which will accomplish this task. 

A. [OnSerializing]internal void UpdateValue (StreamingContext context) { 
currRate = GetCurrentRate(); 
} 
B. [OnSerializing]internal void UpdateValue(SerializationInfo info) { 
info.AddValue("currentRate", GetCurrentRate()); 
} 
C. [OnDeserializing]internal void UpdateValue(SerializationInfo info) { 
info.AddValue("currentRate", GetCurrentRate()); 
} 
D. [OnDeserialized]internal void UpdateValue(StreamingContext context) { 
currRate = GetCurrentRate(); 
} 




















Answer: D 

Explanation: 

A method with the OnDeserialized attribute will be called after Deserialization and any instance 
variables can be set. 

A & B the method will fire during serializing, the question is concerned with reconstructing the 
object during deserialization. 

C the OnDeserializing attribute is useful for default values. OnDeserializing attribute works with a 
method that contains a StreamContext parameter and not a SerializationInfo parameter. 











QUESTION NO: 251 

You work as the application developer at CertKiller.com. You have to develop a method which will 
clear a queue named badqueue. 

Choose the code segment which will accomplish this task. 

A. foreach (object e in badqueue) { 
q.Dequeue(); 
} 
B. foreach (object e in badqueue) { 
Enqueue(null); 
} 
C. badqueue.Clear(); 
D. badqueue.Dequeue(); 




















Answer: C 

Explanation: 

Simply call the Clear() method to empty a queue. 

A Dequeuing all of the items in a queue will also serve the same affect but it is a lot more 
roundabout. 

B attempts to re-queue items that are already in the queue 

D will de-queue only one item that is at the front of the queue. 









QUESTION NO: 252 

You work as the application developer at CertKiller.com. You have to develop an application 
named CertKillerApp21. When deployed, CertKillerApp21 will be used by numerous users on the 
same computer. CertKillerApp21 uses more than one assembly, and is configured to use isolated 
storage to store certain user information. 

You must create a new directory named UserInfo in the isolated storage area which is scoped to 
the current Microsoft Windows identity and assembly. 

Choose the code segment which will accomplish this task. 

A. IsolatedStorageFile store; 
store = IsolatedStorageFile.GetUserStoreForAssembly(); 
store.CreateDirectory("UserInfo"); 
B. IsolatedStorageFile store; 
store = IsolatedStorageFile.GetMachineStoreForAssembly(); 
store.CreateDirectory("UserInfo"); 
C. IsolatedStorageFile store; 
store = IsolatedStorageFile.GetUserStoreForDomain(); 
store.CreateDirectory("UserInfo"); 
D. IsolatedStorageFile store; 
store = IsolatedStorageFile.GetMachineStoreForApplication(); 
store.CreateDirectory("UserInfo"); 




















Answer: A 

Explanation: 

The user store for the assembly is the correct store that is required. It is returned by 
IsolatedStorageFile.GetUserStoreForAssembly(). 

B,C & D return Isolated Storage File stores of incorrect scope 











QUESTION NO: 253 

You work as the application developer at CertKiller.com. You are working on an existing 
application and must load a new assembly into this application. 

You must write the code segment that will require the common language runtime (CLR) to grant 
the assembly a permission set, as though the assembly was loaded from the local intranet zone. 
You must ensure that the default evidence for the assembly is overridden and must create the evidence collection. 

Choose the code segment which will accomplish this task. 

A. Evidence evidence = new Evidence( 
Assembly.GetExecutingAssembly().Evidence 
); 
B. Evidence evidence = new Evidence(); 
evidence.AddAssembly(new Zone(SecurityZone.Intranet)); 
C. Evidence evidence = new Evidence(); 
evidence.AddHost(new Zone(SecurityZone.Intranet)); 
D. Evidence evidence = new Evidence( 
AppDomain.CurrentDomain.Evidence 
); 




















Answer: C 

Explanation: 

Use the evidence.AddHost method to add Zone evidence. 

A simply gets the evidence of the Executing Assembly and assigns it to a new object, the 
question explicitly wants Intranet zone evidence. 

B Adds assembly evidence, the question asks for host evidence because it is concerned with 
where the assembly was loaded from.# 

D does not create an Evidence object with Intranet zone evidence. 











QUESTION NO: 254 

You work as the application developer at CertKiller.com. You are working on a new requirement. 
You have to create a class library that will open the network socket connections to computers on 
the CertKiller.com network. 

The class library must be deployed to the global assembly cache, with full trust granted. To cater 
for network socket connections being used, you develop this code segment: 

SocketPermission permission = 
new SocketPermission(PermissionState.Unrestricted); 
permission.Assert(); 

You discover though that there are certain existing applications which do not have the required permissions to open the network socket connections. You decide to cancel the assertion. 

Choose the code segment which will accomplish this task. 

A. CodeAccessPermission.RevertAssert(); 
B. CodeAccessPermission.RevertDeny(); 
C. permission.Deny(); 
D. permission.PermitOnly(); 




















Answer: A 

Explanation: 

CodeAccessPermission.ReverAssert() should be used to undo a previous Assert call. 

B is used to revert a previous deny call. 

C & D are used to reduce the CAS permissions, they do not undo a previous Assert call. 











QUESTION NO: 255 

You work as the application developer at CertKiller.com. You create a new service application 
named CertKillerApp29. You install CertKillerApp29 on five application servers running in the 
CertKiller.com network. You then apply the code segment shown below. Note that line numbers 
are only included for reference pruposes. 


01 public void StartService(string serverName){ 
02 ServiceController crtl = new 
03 ServiceController("CertKillerApp29"); 
04 if (crtl.Status == ServiceControllerStatus.Stopped){ 
05 } 
06 } 


You want CertKillerApp29 to start if it stops. You must create the routine which will start 
CertKillerApp29 on the server defined by the serverName input parameter. 


Choose the two lines of code which you should include in your code segment. Each correct 
answer presents only part of the complete solution. Choose two answers. 


A. Add this line of code between line 03 and line 04: crtl.ServiceName = serverName; 
B. Add this line of code between line 03 and line 04: crtl.MachineName = serverName; 
C. Add this line of code between line 03 and line 04:crtl.Site.Name = serverName; 
D. Add this line of code between line 04 and line 05:crtl.Continue(); 
E. Add this line of code between line 04 and line 05:crtl.Start(); 
F. Add this line of code between line 04 and line 05:crtl.ExecuteCommand(0); 




















Answer: B,E 

Explanation: 

The ServiceController is capable of controller services on other computers, the MachineName 
should be specified. The service should be started with the Start() method if it is in the stopped 
state. 

Setting the ServiceName to the machine name is incorrect. 

No such property as SiteName 

Continue cannot re-start a stopped service only a paused one. 

ExecuteCommand is used to fire a custom command on the service. 











QUESTION NO: 256 

You work as the application developer at CertKiller.com. You must write the code segment which 
will enable you to read the entire contents of a file named Data.txt into a single string variable. 

Choose the code segment that will do this. 

A. string result = null; 
StreamReader reader = new StreamReader("Data.txt"); 
result = reader.Read().ToString(); 
B. string result = null; 
StreamReader reader = new StreamReader("Data.txt"); 
result = reader.ReadToEnd(); 
C. string result = string.Empty; 
StreamReader reader = new StreamReader("Data.txt"); 
while (!reader.EndOfStream) { 
result += reader.ToString(); 
} 
D. string result = null; 
StreamReader reader = new StreamReader("Data.txt"); 
result = reader.ReadLine(); 




















Answer: B Explanation: 

Create a StreamReader based on the file and call the ReadToEnd() method to quickly read the 
entire file and return a string. 

A & D does not read the entire file. 

C calling ToString() on the reader will give a string representation of the stream and will not read 
from the stream. 











QUESTION NO: 257 

You work as the application developer at CertKiller.com. You are writing a method that will run 
through the credentials of the end user. Microsoft Windows groups must be used to authorize the 
user. 

You must develop the code segment which will recognize if the user exists in the local group 
named Sales. 

Choose the code segment that will do this. 

A. WindowsIdentity currentUser = WindowsIdentity.GetCurrent(); 
foreach (IdentityReference grp in currentUser.Groups) { 
NTAccount grpAccount = 
((NTAccount)grp.Translate(typeof(NTAccount))); 
isAuthorized = grpAccount.Value.Equals(Environment.MachineName + @"\Sales"); 
if (isAuthorized) break; 
} 
B. WindowsPrincipal currentUser = 
(WindowsPrincipal)Thread.CurrentPrincipal; 
isAuthorized = currentUser.IsInRole("Sales"); 
C. GenericPrincipal currentUser = 
(GenericPrincipal) Thread.CurrentPrincipal; 
isAuthorized = currentUser.IsInRole("Sales"); 
D. WindowsPrincipal currentUser = 
(WindowsPrincipal)Thread.CurrentPrincipal; 
isAuthorized = currentUser.IsInRole(Environment.MachineName); 




















Answer: B 

Explanation: 

To check the role membership of the current Windows user, user the IsInRole() method of the 
WindowsPrincipal in the current thread. A it is a lot more complicated to iterate through all the groups the user belongs to and checking for 
matches. The Principal classes are for this very purposes and should be used. 

C uses GenericPrincipal. WindowsPrincipal should be used for windows accounts. There is an 
invalid cast from WindowsPrincipal to GenericPrincipal. 

D does not specify the group correctly. 











QUESTION NO: 258 

You work as the application developer at CertKiller.com. You must create a code segment that will 
perform these tasks: 
Retrieves the name of each paused service.Passes the name to the Add method of Collection5. 


Choose the code segment which you should use. 


A. ManagementObjectSearcher searcher = 
new ManagementObjectSearcher( 
"Select * from Win32_Service where State = 'Paused'"); 
foreach (ManagementObject svc in searcher.Get()) { 
Collection5.Add(svc["DisplayName"]); 
} 
B. ManagementObjectSearcher searcher = 
new ManagementObjectSearcher( "Select * from Win32_Service", "State = 'Paused'"); 
foreach (ManagementObject svc in searcher.Get()) { 
Collection5.Add(svc["DisplayName"]); 
} 
C. ManagementObjectSearcher searcher = 
new ManagementObjectSearcher( 
"Select * from Win32_Service"); 
foreach (ManagementObject svc in searcher.Get()) { 
if ((string) svc["State"] == "'Paused'") { 
Collection5.Add(svc["DisplayName"]); 
}} 
D. ManagementObjectSearcher searcher = 
new ManagementObjectSearcher(); 
searcher.Scope = new ManagementScope("Win32_Service"); 
foreach (ManagementObject svc in searcher.Get()) { 
if ((string)svc["State"] == "Paused") { 
Collection5.Add(svc["DisplayName"]); 
}} 




















Answer: A 

Explanation: 

Use the ManagmentObjectSearcher to search for all services with a paused state. Iterate over the 
returned collection and add the display name to Collection5. 

B The constructor is invoked incorrectly. 

C & D the query is incorrect. The searcher does not restrict to paused services. 











QUESTION NO: 259 

You work as the application developer at CertKiller.com. You must create a code segment that will 
identify the first 100 bytes from a stream variable named CertKillerstream5. 

The initial 100 bytes must be transferred to a byte array named byteArray. The code segment you 
write must assign the transferred bytes to an integer variable named bytesTransferred 

Choose the code segment which you should use. 

A. bytesTransferred = CertKillerstream5.Read(byteArray, 0, 100); 
B. for (int i = 0; 
i < 100; 
i++) { 
CertKillerstream5.WriteByte(byteArray[i]); 
bytesTransferred = i; 
if (!CertKillerstream5.CanWrite) { 
break; 
}} 
C. while (bytesTransferred < 100) { 
CertKillerstream5.Seek(1, SeekOrigin.Current); 
byteArray[bytesTransferred++] = 
Convert.ToByte(CertKillerstream5.ReadByte()); 
} 
D. CertKillerstream5.Write(byteArray, 0, 100); 
bytesTransferred = byteArray.Length; 




















Answer: A 

Explanation: 

The Read() method accepts a byte array and the start position and number of bytes to read as 
parameters. B & D The question indicates that data should be read from the stream not written to it. 

C it is unnecessary to attempt to read byte by byte, the Read() method provides a very efficient 
way of reading into a byte array. 











QUESTION NO: 260 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp12. CertKillerApp12 will be used to store customer information on 
CertKiller.com's customers who are dispersed across the continent. 

You need to create internal utilities for CertKillerApp12, and need to collect information on all 
CertKiller.com's customers that are located in Canada. 

Choose the code segment which will perform this task. 

A. foreach (CultureInfo culture in CultureInfo.GetCultures(CultureTypes.SpecificCultures)) { // 
Output the region information...} 
B. CultureInfo cultureInfo = new CultureInfo("CA"); 
// Output the region information... 
C. RegionInfo regionInfo = new RegionInfo("CA"); 
// Output the region information... 
D. RegionInfo regionInfo = new RegionInfo(""); 
if (regionInfo.Name == "CA") { 
// Output the region information...} 




















Answer: C 

Explanation: 

The RegionInfo class can be used to get information about a region. 

A & B CultureInfo is used to control formatting, sorting & comparing of culture sensitive data. E.g 
currencies, calendar dates etc. 

D Does not initialise the RegionInfo object correctly i.e to Canada . 











QUESTION NO: 261 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp06. 

CertKillerApp06 will be used to transmit confidential financial information over the network. To secure the confidential data, you create an X509 Certificate object named certificate and create a 
TcpClient object named client. 

You must now create the code segment that creates an SslStream for communication by applying 
the Transport Layer Security 1.0 protocol. 

Choose the code segment which you should use. 

A. SslStream ssl = new SslStream(client.GetStream()); 
ssl.AuthenticateAsServer( 
certificate, false, SslProtocols.None, true); 
B. SslStream ssl = new SslStream(client.GetStream()); 
ssl.AuthenticateAsServer( 
certificate, false, SslProtocols.Ssl3, true); 
C. SslStream ssl = new SslStream(client.GetStream()); 
ssl.AuthenticateAsServer( 
certificate, false, SslProtocols.Ssl2, true); 
D. SslStream ssl = new SslStream(client.GetStream()); 
ssl.AuthenticateAsServer( 
certificate, false, SslProtocols.Tls, true); 




















Answer: D 











QUESTION NO: 262 

You work as the application developer at CertKiller.com. You are developing a new method that 
must pass data to another method named CertKillerMe2. Your method accepts a string parameter 
named message. 

The method you are writing must break the message parameter into individual lines of text. Each 
individual line must then be passed to the CertKillerMe2 method. 

Choose the code segment which you should use. 

A. StringReader reader = new StringReader(message); 
CertKillerMe2 (reader.ReadToEnd()); 
reader.Close(); 
B. StringReader reader = new StringReader(message); 
while (reader.Peek() != -1) { 
string line = reader.Read().ToString(); 
CertKillerMe2 (line); 
}reader.Close(); 
C. StringReader reader = new StringReader(message); 
CertKillerMe2 (reader.ToString()); 
reader.Close(); 
D. StringReader reader = new StringReader(message); 
while (reader.Peek() != -1) { 
CertKillerMe2 (reader.ReadLine()); 
}reader.Close(); 




















Answer: D 

Explanation: 

StringReader.ReadLine() allows for lines to be read line by line. 

A ReadToEnd() will read the entire stream. 

B Read() will not read the line but only the next character. 

C will not read from the message but will just give a string representation of the reader. 











QUESTION NO: 263 

You work as the application developer at CertKiller.com. You are developing a new method that 
must encrypt confidential data. The method must use the Data Encryption Standard (DES) 
algorithm. Your new method takes these parameters: 
A byte array, named message, that must be encrypted by applying the DES algorithm.A key, 
named key, which will be used to encrypt the data.The initialization vector, named iv. 


Once the data is encrypted, it must be added to the MemoryStream object. 


Choose the code segment which will encrypt the specified data and add it to the MemoryStream 
object. 


A. DES des = new DESCryptoServiceProvider(); 
des.BlockSize = message.Length; 
ICryptoTransform crypto = des.CreateEncryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(); 
CryptoStream cryptoStream = new CryptoStream(cipherStream, 
crypto, CryptoStreamMode.Write); 
cryptoStream.Write(message, 0, message.Length); 
B. DES des = new DESCryptoServiceProvider(); 
ICryptoTransform crypto = des.CreateDecryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(); 
CryptoStream cryptoStream = new CryptoStream(cipherStream, 
crypto, CryptoStreamMode.Write); 
cryptoStream.Write(message, 0, message.Length); 

C. DES des = new DESCryptoServiceProvider(); 
ICryptoTransform crypto = des.CreateEncryptor(); 
MemoryStream cipherStream = new MemoryStream(); 
CryptoStream cryptoStream = new CryptoStream(cipherStream, 
crypto, CryptoStreamMode.Write); 
cryptoStream.Write(message, 0, message.Length); 
D. DES des = new DESCryptoServiceProvider(); 
ICryptoTransform crypto = des.CreateEncryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(); 
CryptoStream cryptoStream = new CryptoStream(cipherStream, 
crypto, CryptoStreamMode.Write); 
cryptoStream.Write(message, 0, message.Length); 




















Answer: D 

Explanation: 

Use the DesCryptoServiceProvider to create a new encryptor.Create a CryptoStream that encrypt 
directly to the MemoryStream and call the Write() method to perform the encryption. 

A Uses a blocksize set to size of the entire message 

B creates a decryptor instead of an encryptor. 

C does not initialize the encryptor with the key and iv correctly. 











QUESTION NO: 264 

You work as the application developer at CertKiller.com. You have to create a new security policy 
for an application domain which must enforce the new CertKiller.com security policy. You write the 
code segment to do this: 

PolicyLevel policy = PolicyLevel.CreateAppDomainLevel(); 
PolicyStatement noTrustStatement = 
new PolicyStatement( 
policy.GetNamedPermissionSet("Nothing")); 
PolicyStatement fullTrustStatement = 
new PolicyStatement( 
policy.GetNamedPermissionSet("FullTrust")); You must now ensure that all loaded assemblies default to the Nothing permission set. In addition 
to this, when an assembly comes from a trusted zone, your security policy must grant the 
assembly the FullTrust permission set. You must create the code groups to do this. 

Choose the code segment which will achieve this objective. 

A. CodeGroup group1 = new FirstMatchCodeGroup( 
new ZoneMembershipCondition(SecurityZone.Trusted), 
fullTrustStatement); 
CodeGroup group2 = new UnionCoderoup( 
new AllMembershipCondition(), 
noTrustStatement); 
group1.AddChild(group2); 
B. CodeGroup group1 = new FirstMatchCodeGroup( 
new AllMembershipCondition(), 
noTrustStatement); 
CodeGroup group2 = new UnionCodeGroup( 
new ZoneMembershipCondition(SecurityZone.Trusted), 
fullTrustStatement); 
group1.AddChild(group2); 
C. CodeGroup group = new UnionCodeGroup( 
new ZoneMembershipCondition(SecurityZone.Trusted), 
fullTrustStatement); 
D. CodeGroup group = new FirstMatchCodeGroup( 
new AllMembershipCondition(), 
noTrustStatement); 




















Answer: B 











QUESTION NO: 265 

You work as the application developer at CertKiller.com. You have to define the code segment 
that will transfer the data of a byte array. The byte array is named dataToSend. Your code 
segment must use a NetworkStream object named netStream when transferring the data of the 
byte array. The cache size you use must be 8,192 bytes. 

Which code segment should you use to accomplish the task? 

A. MemoryStream memStream = new MemoryStream(8192); 
memStream.Write(dataToSend, 0, (int) netStream.Length); 
B. MemoryStream memStream = new MemoryStream(8192); 
netStream.Write(dataToSend, 0, (int) memStream.Length); 
C. BufferedStream bufStream = new BufferedStream(netStream, 8192); 
bufStream.Write(dataToSend, 0, dataToSend.Length); 
D. BufferedStream bufStream = new BufferedStream(netStream); 
bufStream.Write(dataToSend, 0, 8192); 




















Answer: C 

Explanation: 

To send data using a cache it is necessary to use a BufferedStream. The BufferedStream should 
be created with the cache size of 8192 bytes. 

A & B do not employ caching. 

D does not correctly initialise the BufferedStream to have a cache size of 8192 bytes. 











QUESTION NO: 266 

You work as the application developer at CertKiller.com. You are developing a new client 
application named CertKillerApp09. CertKillerApp09 must have a utility screen. The screen must 
show a thermometer; which must indicate what the current status of processes are which are 
being executed by the application. 

A rectangle, which will be the background of the thermometer, must be drawn on the screen. The 
rectangle must be filled with gradient shading, as shown in the accompanying exhibit. 


Which code segment should you use to accomplish the task? 

A. Rectangle rectangle = new Rectangle(10, 10, 450, 25); 
LinearGradientBrush rectangleBrush = 
new LinearGradientBrush(rectangle, Color.AliceBlue, 
Color.CornflowerBlue, 
LinearGradientMode.ForwardDiagonal); 
Pen rectanglePen = new Pen(rectangleBrush); 
Graphics g = this.CreateGraphics(); 
g.DrawRectangle(rectanglePen, rectangle); 
B. Rectangle rectangle = new Rectangle(10, 10, 450, 25); 
LinearGradientBrush rectangleBrush = 
new LinearGradientBrush(rectangle, Color.AliceBlue, 
Color.CornflowerBlue, 
LinearGradientMode.ForwardDiagonal); 
Pen rectanglePen = new Pen(rectangleBrush); 
Graphics g = this.CreateGraphics(); 
g.FillRectangle(rectangleBrush, rectangle); 


C. RectangleF rectangle = new RectangleF(10f, 10f, 450f, 25f); 
Point[] points = new Point[] {new Point(0, 0), 
new Point(110, 145)}; 
LinearGradientBrush rectangleBrush = 
new LinearGradientBrush(rectangle, Color.AliceBlue, 
Color.CornflowerBlue, 
LinearGradientMode.ForwardDiagonal); 
Pen rectanglePen = new Pen(rectangleBrush); 
Graphics g = this.CreateGraphics(); 
g.DrawPolygon(rectanglePen, points); 
D. RectangleF rectangle = new RectangleF(10f, 10f, 450f, 25f); 
SolidBrush rectangleBrush = 
new SolidBrush(Color.AliceBlue); 
Pen rectanglePen = new Pen(rectangleBrush); 
Graphics g = this.CreateGraphics(); 
g.DrawRectangle(rectangleBrush, rectangle); 




















Answer: B 

Explanation: 

Create a LineGradientBrush and supply to the FillRectangle() method of the graphics object. 

A DrawRectangle() will draw the outline of a rectangle without filling it. 

C draws an unfilled Polygon.. 

D Uses a SolidBrush and will not achieve the desired gradient fill 











QUESTION NO: 267 

You work as the application developer at CertKiller.com. You are creating a new method. Your 
method must be localized to Italy, and must search a string named searchList for a specific 
substring named searchValue. 

Which code segment should you use to perform this task? A. return searchList.IndexOf(searchValue); 
B. CompareInfo comparer = 
new CultureInfo("it-IT").CompareInfo; 
return comparer.Compare(searchList, searchValue); 
C. CultureInfo comparer = new CultureInfo("it-IT"); 
if (searchList.IndexOf(searchValue) 
> 0) { 
return true; 
} else { 
return false; 
} 
D. CompareInfo comparer = 
new CultureInfo("it-IT").CompareInfo; 
if (comparer.IndexOf(searchList, 
searchValue) > 0) { 
return true; 
} else { 
return false; 
} 




















Answer: D 











QUESTION NO: 268 

You work as the application developer at CertKiller.com. You are developing a new method that 
must decrypt, encrypted confidential data. The confidential data to decrypt is encrypted via the 
Triple DES (3-DES) algorithm. 


Your new method takes these parameters: 
A byte array, named cipherMessage that must be decrypted.A key, named keyThe initialization 
vector, named iv. 


Choose the code segment which will decrypt the specified data via the TripleDES class. The 
decrypted data must be in string. 


A. TripleDES des = new TripleDESCryptoServiceProvider(); 
des.BlockSize = cipherMessage.Length; 
ICryptoTransform crypto = des.CreateDecryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(cipherMessage); 
CryptoStream cryptoStream = 
new CryptoStream( 
cipherStream, crypto, CryptoStreamMode.Read); 
string message; 
message = new StreamReader(cryptoStream).ReadToEnd(); 


B. TripleDES des = new TripleDESCryptoServiceProvider(); 
des.FeedbackSize = cipherMessage.Length; 
ICryptoTransform crypto = des.CreateDecryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(cipherMessage); 
CryptoStream cryptoStream = 
new CryptoStream( 
cipherStream, crypto, CryptoStreamMode.Read); 
string message; 
message = new StreamReader(cryptoStream).ReadToEnd(); 
C. TripleDES des = new TripleDESCryptoServiceProvider(); 
ICryptoTransform crypto = des.CreateDecryptor(); 
MemoryStream cipherStream = new MemoryStream(cipherMessage); 
CryptoStream cryptoStream = 
new CryptoStream( 
cipherStream, crypto, CryptoStreamMode.Read); 
string message; 
message = new StreamReader(cryptoStream).ReadToEnd(); 
D. TripleDES des = new TripleDESCryptoServiceProvider(); 
ICryptoTransform crypto = des.CreateDecryptor(key, iv); 
MemoryStream cipherStream = new MemoryStream(cipherMessage); 
CryptoStream cryptoStream = 
new CryptoStream( 
cipherStream, crypto, CryptoStreamMode.Read); 
string message; 
message = new StreamReader(cryptoStream).ReadToEnd(); 




















Answer: D 











QUESTION NO: 269 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKiller06. CertKiller06 will be used by users to perform an electronic survey that 
contains 30 True-or-False based questions. 

You must set each answer to True. You also want to limit the amount of memory used by each 
survey. 

Choose the storage option that you should use. A. BitVector32 answers = new BitVector32(1); 
B. BitVector32 answers = new BitVector32(-1); 
C. BitArray answers = new BitArray (1); 
D. BitArray answers = new BitArray(-1); 




















Answer: B 

Explanation: 

C & D BitVector32 is more efficient than a BitArray when 32 or less binary flags are required. 
Primarily because it is a value type. 

Note: we are not sure why B is preferred to A. 











QUESTION NO: 270 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKiller15. CertKiller15 will be used to show processes running on remote computers. 
You need to write a method for the application. Your method must accomplish the following: 
Accept the name of the remote computer as a string parameter named strComputer.Return an 
ArrayList object that lists the names of each process running on that specific remote computer. 

Choose the code segment that will accomplish the task. 

A. ArrayList al = new ArrayList(); 
Process[] procs = Process.GetProcessesByName(strComputer); 
foreach (Process proc in procs) { 
al.Add(proc); 
} 
B. ArrayList al = new ArrayList(); 
Process[] procs = Process.GetProcesses(strComputer); 
foreach (Process proc in procs) { 
al.Add(proc); 
} 
C. ArrayList al = new ArrayList(); 
Process[] procs = Process.GetProcessesByName(strComputer); 
foreach (Process proc in procs) { 
al.Add(proc.ProcessName); 
} 
D. ArrayList al = new ArrayList(); 
Process[] procs = Process.GetProcesses(strComputer); 
foreach (Process proc in procs) { 
al.Add(proc.ProcessName); 
} 





















Answer: D 

Explanation: 

Call Processes.GetProcesses() supplying the name of the computer and then iterate through the 
returned collection of processes adding the process name to the arraylist. 

A & C use GetProcessByName() and return processes on the current computer only. 

B adds the entire process to the arraylist rather than just the process name. 











QUESTION NO: 271 

You work as the application developer at CertKiller.com. You are developing a new application 
and must write a code segment that will serialize an object named data, of type List<int>, in a 
binary format. 

Choose the code segment that will accomplish the task. 

A. BinaryFormatter formatter = new BinaryFormatter(); 
MemoryStream stream = new MemoryStream(); 
formatter.Serialize(stream, data); 
B. BinaryFormatter formatter = new BinaryFormatter(); 
MemoryStream stream = new MemoryStream(); 
for (int i = 0; 
i < data.Count; 
i++) { 
formatter.Serialize(stream, data[i]); 
} 
C. BinaryFormatter formatter = new BinaryFormatter(); 
byte[] buffer = new byte[data.Count]; 
MemoryStream stream = new MemoryStream(buffer, true); 
formatter.Serialize(stream, data); 
D. BinaryFormatter formatter = new BinaryFormatter(); 
MemoryStream stream = new MemoryStream(); 
data.ForEach(delegate(int num) 
{ formatter.Serialize(stream, num); 
} 
); 




















Answer: A Explanation: 

create a BinaryFormatter and a MemoryStream and simply use the formatter to serialize the data 
to the stream. 

B Collections support serialization, hence it is not required to try to serialize each item 
independently. 

C The MemoryStream is created to be non resizeable and it is not the correct size. 











QUESTION NO: 272 

You work as the application developer at CertKiller.com. You are developing a new method that 
must compress an array of bytes. The array of bytes which should be compressed must be 
passed to the method in a parameter named document 

Choose the code segment which will perform your task. 

A. MemoryStream inStream = new MemoryStream(document); 
GZipStream zipStream = new GZipStream(inStream, 
CompressionMode.Compress); 
byte[] result = new byte[document.Length]; 
zipStream.Write(result, 0, result.Length); 
return result; 
B. MemoryStream stream = new MemoryStream(document); 
GZipStream zipStream = new GZipStream(stream, 
CompressionMode.Compress); 
zipStream.Write(document, 0, document.Length); 
zipStream.Close(); 
return stream.ToArray(); 
C. MemoryStream outStream = new MemoryStream(); 
GZipStream zipStream = new GZipStream(outStream, 
CompressionMode.Compress); 
zipStream.Write(document, 0, document.Length); 
zipStream.Close(); 
return outStream.ToArray(); 
D. MemoryStream inStream = new MemoryStream(document); 
GZipStream zipStream = new GZipStream(inStream, 
CompressionMode.Compress); 
MemoryStream outStream = new MemoryStream(); 
int b; 
while ((b = zipStream.ReadByte()) != -1) { 
outStream.WriteByte((byte)b); 
} return outStream.ToArray(); 





















Answer: C 

Explanation: 

Create a new GZipStream that can compress data and writes to a new MemoryStream object. Call 
the Write() method of the GZipStream to comprss the bytes to the MemoryStream. 

A & B the GZipStream constructor should take a target stream not a source stream when 
compressing. The source data to compress is specified in the Write() method of GZipStream. 

D attempts to process byte by byte. This is unnecessary because the Write method can handle 
any number of bytes in one go. 











QUESTION NO: 273 

You work as the application developer at CertKiller.com. You are working on code segment that 
must use platform invoke to call a function from the Win32 Application Programming Interface 
(API). The code segment you have written is as follows: 

int rc = MessageBox(hWnd, text, caption, type); 

You must choose a method prototype. Choose the code segment that provides for this. 

A. [DllImport("user32")]public static extern int MessageBox(int hWnd, String text, 
String caption, uint type); 
B. [DllImport("user32")]public static extern int MessageBoxA(int hWnd, String text, 
String caption, uint type); 
C. [DllImport("user32")]public static extern int Win32API_User32_MessageBox( 
int hWnd, String text, String caption, uint type); 
D. [DllImport(@"C:\WINDOWS\system32\user32.dll")]public static extern int MessageBox(int 
hWnd, String text, 
String caption, uint type); 




















Answer: A 

Explanation: 

Mark the prototype with the Dllimport attribute specifying the library\dll that the function resides in. 


B creates a prototype for the MessageBoxA function not MessageBox . 
D it is not necessary to specify the physical path because user32.dll will be in the path 
environment variable. Also it will not work with versions of windows (some may use 
c:\winnt\system32) 










QUESTION NO: 274 

You work as the application developer at CertKiller.com. You are developing a new application 
that will print a report. The report must list language codes and region codes. 

Choose the code segment that will accomplish this task. 

A. foreach (CultureInfo culture in CultureInfo.GetCultures(CultureTypes.SpecificCultures)) { 
// Output the culture information...} 
B. CultureInfo culture = new CultureInfo(""); 
CultureTypes types = culture.CultureTypes; 
// Output the culture information... 
C. foreach (CultureInfo culture in CultureInfo.GetCultures(CultureTypes.NeutralCultures)) { 
// Output the culture information...} 
D. foreach (CultureInfo culture in CultureInfo.GetCultures(CultureTypes.ReplacementCultures)) { 
// Output the culture information...} 




















Answer: A 

Explanation: 

CultureTypes.SpecificCultures will filter all language codes that are specific to a country\region. 

B The CultureInfo object created is not associated with any cultures. 

C will yield only neutral cultures, they will not be specific to a country\region. 

D Replacement cultures are user-defined custom cultures. 











QUESTION NO: 275 

You work as the application developer at CertKiller.com. CertKiller.com has its headquarters in 
Chicago and a branch office in Mexico. 

You are developing a new application that will print a report. When the report is generated and 
printed by users in the Mexico branch office, the report must show the current date in the Mexican 
Spanish format. 

Which of the following code segments will accomplish the task? 

A. DateTimeFormatInfo dtfi = new CultureInfo("es-MX", false).DateTimeFormat; 
DateTime dt = new DateTime(DateTime.Today.Year, DateTime.Today.Month, 
DateTime.Today.Day); 
string dateString = dt.ToString(dtfi.LongDatePattern); 


B. Calendar cal = new CultureInfo("es-MX", false).Calendar; 
DateTime dt = new DateTime(DateTime.Today.Year, DateTime.Today.Month, 
DateTime.Today.Day); 
Strong dateString = dt.ToString(); 
C. string dateString = DateTimeFormatInfo.CurrentInfo GetMonthName(DateTime.Today.Month); 
D. string dateString = DateTime.Today.Month.ToString("es-MX"); 




















Answer: A 

Explanation: 

Create a Mexican Spanish CultureInfo object. Convert the date to a string using the 
DateTimeFormatInfo returned by the CultureInfo object. 

B does not use the CultureInfo object to convert the date to a string. 

C does not use the Mexican Spanish culture. 

D the DateTime.ToString() method cannot take a string code representation of the culture. 











QUESTION NO: 276 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp09. 

You are creating a method and want to view its output that returns a string. You are using 
Microsoft Visual Studio 2005 IDE to examine the method's output. You define the output of the 
method to the string variable named fName. You want certain information printed in a single line: 
This message must be printed: Test UnsuccessfulWhen the value of fName is not equal to " Kara 
Lang", the value of fName must be printed. 

The code segment that you use must simultaneously facilitate uninterrupted execution of 
CertKillerApp09. 

Which of the following code segments should you use to achieve your goal? 

A. Debug.Assert(fName == " Kara Lang", "Test Unsuccessful: ", fName); 
B. Debug.WriteLineIf(fName != " Kara Lang", fName, "Test Unsuccessful"); 
C. if (fName != " Kara Lang") { 
Debug.Print("Test Unsuccessful: "); 
Debug.Print(fName); 
} 

D. if (fName != " Kara Lang") { 
Debug.WriteLine("Test Unsuccessful: "); 
Debug.WriteLine(fName); 
} 




















Answer: B 

Explanation: 

Debug.WriteLineIf() will conditionally write the "Test Unsuccessful", it will not interrupt execution of 
the application. 

A an Assert will stop execution of the application in debug mode if the condition is not met. 

C & D could be used but they execute in the release configurations 











QUESTION NO: 277 

You work as the application developer at CertKiller.com. You are working on an application named 
CertKillerApp10. CertKillerApp10 must be configured to use role-based security and 
authentication. 

You must develop the code segment which will result in the runtime assigning an unauthenticated 
principal object to each running thread. 

Choose the code segment which will accomplish the task. 

A. AppDomain domain = AppDomain.CurrentDomain; 
domain.SetPrincipalPolicy(PrincipalPolicy.WindowsPrincipal); 
B. AppDomain domain = AppDomain.CurrentDomain; 
domain.SetThreadPrincipal(new WindowsPrincipal(null)); 
C. AppDomain domain = AppDomain.CurrentDomain; 
domain.SetAppDomainPolicy( 
PolicyLevel.CreateAppDomainLevel()); 

D. AppDomain domain = AppDomain.CurrentDomain; 
domain.SetPrincipalPolicy( 
PrincipalPolicy.UnauthenticatedPrincipal); 




















Answer: D 

Explanation: Setting the PrincipalPolicy for the AppDomain to UnauthenticatedPrincipal will default the Principal 
for each thread to an unauthenticated principal . 

A sets the policy to WindowsPrincipal, threads will have their principal set according the windows 
account that they are running as. 

B SetThreadPrincipal() does not set the default policy for all new threads. Also a WindowsPrincipal 
is used instead of UnauthenticatedPrincipal. 

C SetAppDomainPolicy is used to set the security policy level for the domain. 











QUESTION NO: 278 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp12. You must the write multicast delegate that accepts a DateTime argument. 

Choose the code segment which will accomplish the task. 

A. public delegate int PowerDeviceOn(bool result, 
DateTime autoPowerOff); 
B. public delegate bool PowerDeviceOn(object sender, 
EventArgs autoPowerOff); 
C. public delegate void PowerDeviceOn(DateTime autoPowerOff); 
D. public delegate bool PowerDeviceOn(DateTime autoPowerOff); 




















Answer: C 

Explanation: 

A & B the delegates do not accept an argument of type DateTime 

D The question does not explicitly mention a return type. Also with multicasting only the return 
value of the last method called as part of a multicast chain is returned. Hence return values do not 
tend to be very useful as far as multicasting is concerned. 











QUESTION NO: 279 

You work as the application developer at CertKiller.com. You create a new class named User. The 
User class contains this code segment: 


public class User { 
string userId, userName, jobTitleName; 
public string GetName() { return userName; 
} 
public string GetTitle() { return jobTitleName; 
} 

You want to expose the User class to COM in a type library. You also want the COM interface to 
facilitate forward-compatibility across new versions of the User class. 

What should you do to achieve your goal in these circumstances? 

A. Include this attribute with the class definition: [ClassInterface(ClassInterfaceType.None)]public 
class User { 
B. Include this attribute with the class definition: 
[ClassInterface(ClassInterfaceType.AutoDual)]public class User { 
C. Include this attribute with the class definition: [ComVisible(true)]public class User { 
D. Specify the interface for the User class and then add this attribute with the class definition: 
[ClassInterface(ClassInterfaceType.None)]public class User : IUser { 




















Answer: D 











QUESTION NO: 280 

You work as the application developer at CertKiller.com. You have been tasked with writing a 
multicast delegate that accepts a DateTime argument, and then returns a Boolean value. 

Which code segment should you use to accomplish the task? 

A. public delegate int PowerDeviceOn(bool, 
DateTime); 
B. public delegate bool PowerDeviceOn(Object, 
EventArgs); 
C. public delegate void PowerDeviceOn(DateTime); 
D. public delegate bool PowerDeviceOn(DateTime); 




















Answer: D 

Explanation: 

A & C does not return a type Bool 

B does not accept a parameter of type DateTime 











QUESTION NO: 281 You work as the application developer at CertKiller.com. You must write a code segment that 
includes an undo buffer function. You want the undo function to store data modifications, but it 
must only allow the storage of strings. You want the undo function to undo the most recently 
performed data modifications first. 

Which code segment should you use to achieve your goal? 

A. Use: Stack<string> undoBuffer = new Stack<string>(); 
B. Use: Stack undoBuffer = new Stack(); 
C. Use: Queue<string> undoBuffer = new Queue<string>(); 
D. Use: Queue undoBuffer = new Queue(); 




















Answer: A 

Explanation: 

A Stack caters for a last in first out scenario similar to what is required in an undo buffer. By using 
Generics you can force a strongly typed collection that takes strings only. 

B is not strongly typed for strings, it will take any type of object. 

C & D Queue is a First in First out collection, it is not appropriate in this instance. 











QUESTION NO: 282 

You work as the application developer at CertKiller.com. You write the definition for a class named 
Vehicle by defining the following code segment: 


public class Vehicle { 
[XmlAttribute(AttributeName = "category")] 
public string vehicleType; 
public string model; 
[XmlIgnore] 
public int year; 
[XmlElement(ElementName = "mileage")] 
public int miles; 
public ConditionType condition; 
public Vehicle() { 
} 
public enum ConditionType { 
[XmlEnum("Poor")] BelowAverage, 
[XmlEnum("Good")] Average, 
[XmlEnum("Excellent")] AboveAverage 
} 
} 

You next create an instance of the Vehicle class, and add the following data in the defined fields of 
the class instance: 


You must now identify the XML block that is generated when the Vehicle class instance is 
serialized. 

Choose the XML block that signifies the output of serializing the Vehicle class instance. 

A. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"" 
vehicleType="car"> 
<model>racer</model> 
<miles>15000</miles> 
<condition>AboveAverage</condition> 
</Vehicle> 
B. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
category="car"> 
<model>racer</model> 
<mileage>15000</mileage> 
<condition>Excellent</condition> 
</Vehicle> 
C. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
category="car"> 
<model>racer</model> 
<mileage>15000</mileage> 
<conditionType>Excellent</conditionType> 
</Vehicle> 
D. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
<category>car</category> 
<model>racer</model> 
<mileage>15000</mileage> 
<condition>Excellent</condition> 
</Vehicle> 




















Answer: B 

Explanation: 

The XML produced in B matches the class definition provided in the question. 

Category is declared to be an attribute of the Vehicle element, this is not the case in answer A 
and D. 

During XML Serialization by default the user type variables are mapped to XML elements. In the 
case of answer C, the type itself has been mapped instead of the instance variable. 











QUESTION NO: 283 

You work as the application developer at CertKiller.com. You create a code segment which will 
implement the class named CertKillerClass1. The code segment is shown here: 


MyMethod function. public class CertKillerClass1 { 
public int MyMethod(int arg) { 
return arg; 
}} 


You want the CertKillerClass1.MyMethod function to be dynamically called from a separate class 
within the assembly. 


Choose the code segment which you should use to accomplish the task. 


A. CertKillerClass1 myClass = new CertKillerClass1(); 
Type t = typeof(CertKillerClass1); 
MethodInfo m = t.GetMethod("MyMethod"); 
int i = (int)m.Invoke(this, new object[] { 1 }); 
B. CertKillerClass1 myClass = new CertKillerClass1(); 
Type t = typeof(CertKillerClass1); 
MethodInfo m = t.GetMethod("MyMethod"); 
int i = (int) m.Invoke(myClass, new object[] { 1 }); 

C. CertKillerClass1 myClass = new CertKillerClass1(); 
Type t = typeof(CertKillerClass1); 
MethodInfo m = t.GetMethod("CertKillerClass1.MyMethod"); 
int i = (int)m.Invoke(myClass, new object[] { 1 }); 
D. Type t = Type.GetType("CertKillerClass1"); 
MethodInfo m = t.GetMethod("MyMethod"); 
int i = (int)m.Invoke(this, new object[] { 1 }); 




















Answer: B 

Explanation: 

Use reflection to get MethodInfo object that corresponds to the MyMethod member function. Call 
the Invoke() method of MethodInfo 

A & D the Invoke method requires the object that the method will fire upon if its an instance 
method. myClass should have been passed. 

C the getMethod() does not require the classname . 











QUESTION NO: 284 

You work as the application developer at CertKiller.com. You are working on a component which 
serializes the Meeting class instances. The definition of the Meeting class is as follows: 


public class Meeting { 
private string title; 
public int roomNumber; 
public string[] invitees; 
public Interview(){ 
} 
public Interview (string t){ 
title = t; 
} } 


You configure the following procedure for your component: 


Meeting myMeeting = new Meeting("Objectives"); 
myMeeting.roomNumber=20; 
string[] attendees = new string[2]{"Amy", "Ally"}; 
myMeeting.invitees = attendees; 
XmlSerializer xs = new XmlSerializer(typeof(Meeting)); 
StreamWriter writer = new StreamWriter(@"C:\Meeting.xml"); 
xs.Serialize(writer, myMeeting); 
writer.Close(); 


You want to find out which XML block will be written to the C:\Meeting.xml file when the procedure 
is executed. 


Choose the XML block that shows which content will be written to the C:\Meeting.xml file? 


A. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<title>Objectives</title> 
<roomNumber>20</roomNumber> 
<invitee>Amy</invitee> 
<invitee>Ally</invitee> 
</Meeting> 
B. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
<string>Ally</string> 
</invitees> 
</Meeting> 
C. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
title="Objectives"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
<string>Ally</string> 
</invitees> 
</Meeting> 
D. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
</invitees> 
<invitees> 
<string>Ally</string> 
</invitees> 
</Meeting> 





















Answer: B 

Explanation: 

A & C show title member in the XML. Title is a private member hence will not be serialized to XML. 

D Shows multiple Invitees. There is only one object of type Invitees in the class definition. 











QUESTION NO: 285 

You work as the application developer at CertKiller.com. You want to modify the current security 
settings of a file named CertKillerData.xml, as follows: 
You must preserve all existing inherited access rules.You must prevent the access rules from 
inheriting future modifications 

Choose the code segment which will accomplish the task. 

A. FileSecurity security = new FileSecurity("CertKillerdata.xml", AccessControlSections.All); 
security.SetAccessRuleProtection(true, true); 
File.SetAccessControl("CertKillerdata.xml", security); 
B. FileSecurity security = new FileSecurity(); 
security.SetAccessRuleProtection(true, true); 
File.SetAccessControl("CertKillerdata.xml", security); 
C. FileSecurity security = File.GetAccessControl("CertKillerdata.xml"); 
security.SetAccessRuleProtection(true, true); 
D. FileSecurity security = File.GetAccessControl("CertKillerdata.xml"); 
security.SetAuditRuleProtection(true, true); 
File.SetAccessControl("CertKillerdata.xml", security); 




















Answer: A 

Explanation: 

Retrieve the full access control list for the file, prevent access rules from inheriting in the future by 
calling Security.SetAccessRuleProtection(). Finally call File.SetAccessControl() to apply the 
amended FileSecurity to the file. 

B does not preserve the existing access rules. It overwrites them. C does not apply the amended FileSecurity object back to the file. 

D FileSecurity.SetAuditRuleProtection() is used for controlling audit rules not access rules. 











QUESTION NO: 286 

You work as the application developer at CertKiller.com. You want to modify a method that returns 
an ArrayList named CertKillerAL. You want to write a code segment which will result in all changes 
made to CertKillerAL being performed in a thread-safe way. 

Choose the code segment which will accomplish the task. 

A. ArrayList CertKilleral = new ArrayList(); 
lock (CertKilleral.SyncRoot){ 
return CertKilleral; 
} 
B. ArrayList CertKilleral = new ArrayList(); 
lock (CertKilleral.SyncRoot.GetType()){ 
return CertKilleral; 
} 
C. ArrayList CertKilleral = new ArrayList(); 
Monitor.Enter(CertKilleral); 
Monitor.Exit(CertKilleral); 
return CertKilleral; 
D. ArrayList CertKilleral = new ArrayList(); 
ArrayList sync_ CertKilleral = ArrayList.Synchronized(CertKilleral); 
return sync_ CertKilleral; 




















Answer: D 

Explanation: 

A & C the lock will be released when the method returns. 

B Does not lock the arraylist but attempts to lock its type. 











QUESTION NO: 287 

You work as the application developer at CertKiller.com. You want to test a new method that 
examines running processes. Your method is configured to return an ArrayList that reveals the 
name and full path of each module loaded by a running process named 
C:\CertKillerApps\Process5. Choose the code segment that will show each module loaded by the specific running process? 

A. ArrayList ar = new ArrayList(); 
Process[] procs; 
ProcessModuleCollection modules; 
procs = Process.GetProcesses(@"Process5"); 
if (procs.Length > 0) {modules = procs[0].Modules; 
foreach (ProcessModule mod in modules) { 
ar.Add(mod.ModuleName); 
}} 
B. ArrayList ar = new ArrayList(); 
Process[] procs; 
ProcessModuleCollection modules; 
procs = 
Process.GetProcesses(@"C:\CertKillerApps\Process5.exe"); 
if (procs.Length > 0) { 
modules = procs[0].Modules; 
foreach (ProcessModule mod in modules) { 
ar.Add(mod.ModuleName); 
}} 
C. ArrayList ar = new ArrayList(); 
Process[] procs; 
ProcessModuleCollection modules; 
procs = Process.GetProcessesByName(@"Process5"); 
if (procs.Length > 0) { 
modules = procs[0].Modules; 
foreach (ProcessModule mod in modules) { 
ar.Add(mod.FileName); 
}} 
D. ArrayList ar = new ArrayList(); 
Process[] procs; 
ProcessModuleCollection modules; 
procs = Process.GetProcessesByName(@"C:\CertKillerApps\Process5.exe"); 
if (procs.Length > 0) { 
modules = procs[0].Modules; 
foreach (ProcessModule mod in modules) { 
ar.Add(mod.FileName); 
}} 




















Answer: C Explanation: 

Process.GetProcessesByName() should be used to return all the processes that match a process 
name. The modules collection exposes all the modules loaded by the process and can be added 
to an ArrayList. 

A & B GetProcesses() accepts a computer name for retrieving the processes on a remote 
computer. GetProcessesByName() should be used to return processes by their name. 

D the path of the process is not part of the process name. 











QUESTION NO: 288 

You work as the application developer at CertKiller.com. You create a new custom dictionary 
named MyDictionary. 

Choose the code segment which will ensure that MyDictionary is type safe? 

A. Class MyDictionary Implements Dictionary(Of String, String) 
B. Class MyDictionary Inherits HashTable 
C. Class MyDictionary Implements IDictionary 
D. Class MyDictionary 
End Class 
Dim t As New Dictionary(Of String, String) 
Dim dict As MyDictionary = CType(t, MyDictionary) 




















Answer: A 











QUESTION NO: 289 

You work as the application developer at CertKiller.com. You create a new class named User. The 
User class contains the following code segment: 

Private m_UserId As String 
Private m_ UserName As String 
Private m_JobTitleName As String 
Public Function GetName() As String 
Return m_UserName 
End Function 

Public Function GetTitle() As String 
Return m_JobTitleName End Function 
End Class 

You want the User class exposed to COM in a type library. You want the COM interface to 
facilitate forward-compatibility over all new versions of the User class. 

How should you go about generating the COM interface to accomplish these tasks? 

A. Incude this attribute with the class: definition.<ClassInterface(ClassInterfaceType.None)> _ 
Public Class User 
B. Incude this attribute with the class: definition.<ClassInterface(ClassInterfaceType.AutoDual)> _ 
Public Class User 
C. Incude this attribute with the class definition: <ComVisible(True)> _ 
Public Class User 
D. Specify the interface for the User class, and then include this attribute with the class definition: 
<ClassInterface(ClassInterfaceType.None)> _ 
Public Class UserImplements IUser 




















Answer: D 











QUESTION NO: 290 

You work as the application developer at CertKiller.com. You are developing a new application 
and must serialize the data object of type List(Of Integer) in a binary format. 

Choose the code segment which will implement this task. 

A. Dim formatter As New BinaryFormatter() 
Dim ms As New MemoryStream()formatter.Serialize(ms, data) 
B. Dim formatter As New BinaryFormatter() 
Dim ms As New MemoryStream() For i As Integer = 1 To 20 
formatter.Serialize(ms, data(i - 1)) 
Next 
C. Dim formatter As New BinaryFormatter() 
Dim buffer As New Byte(data.Count) {} 
Dim ms As New MemoryStream(buffer, True)formatter.Serialize(ms, data) 
D. Dim formatter As New BinaryFormatter() 
Dim ms As New MemoryStream()While ms.CanRead 
formatter.Serialize(ms, data) 
End While 




















Answer: A 









QUESTION NO: 291 

You work as the application developer at CertKiller.com. CertKiller.com has its headquarters in 
Chicago and a branch office in Hong Kong. The application you are developing will be used by all 
users located at the Hong Kong branch office. You want to show all negative currency values by 
using a minus sign. 

Which of the following code segments will accomplish the task? 

A. Dim objCulture As NumberFormatInfo = _ 
New CultureInfo("zh-HK").NumberFormatobjCulture.NumberNegativePattern = 1 
Return NumberToPrint.ToString("C", objCulture) 
B. Dim objCulture As NumberFormatInfo = _ 
New CultureInfo("zh-HK").NumberFormatobjCulture.CurrencyNegativePattern = 1 
Return NumberToPrint.ToString("C", objCulture) 
C. Dim objCulture As NumberFormatInfo = _ 
New CultureInfo("zh-HK").NumberFormatReturn NumberToPrint.ToString("-{0}", objCulture) 
D. Dim objCulture As NumberFormatInfo = _ 
New CultureInfo("zh-HK").NumberFormatReturn NumberToPrint.ToString("()", objCulture) 




















Answer: B 

Explanation: 

Use CurrencyNegativePattern property set to 1 to display negative currency values with a minus 
sign. 

A will give a minus sign for negative numbers but not for negative currencies. 

C & D The culture has not been to display a minus sign for currency. 











QUESTION NO: 292 

You work as the application developer at CertKiller.com. You are creating a new method that will 
hash specific data with the Secure Hash Algorithm (SHA-1). 

The data must be passed to your method as a byte array named message. The resultant data 
must then be passed to a byte array named hash. 

Choose the code segment which will achieve your goal. A. Dim objSHA As New SHA1CryptoServiceProvider 
Dim hash() As Byte = NothingobjSHA.TransformBlock(message, 0, message.Length, hash, 0) 
B. Dim objSHA As New SHA1CryptoServiceProvider 
Dim hash() As Byte = BitConverter.GetBytes(objSHA.GetHashCode) 
C. Dim objSHA As New SHA1CryptoServiceProvider 
Dim hash() As Byte = objSHA.ComputeHash(message) 
D. Dim objSHA As New SHA1CryptoServiceProviderobjSHA.GetHashCode() 
Dim hash() As Byte = objSHA.Hash 




















Answer: C 

Explanation: 

Initialise SHA1 object and call the ComputeHash method supplying the message as a parameter 
to return the hash code as an array of bytes. 

A TransferBlock is more appropriate for hashing part of a message. Also it should be called with 
TransferEndBlock. 

B&C GetHashCode is the method inherited from the Object class. It will not perform a hash on the 
incoming message. 











QUESTION NO: 293 

You work as the application developer at CertKiller.com. You create the following code segment: 

Public Delegate Sub FaxDocs(ByVal sender As Object, _ 
ByVal args as FaxArgs) 

What should you do next to configure an event that will call FaxDocs? 

Choose the code segment which you should use. 

A. Public Shared Event Fax As FaxDocs 
B. Public Shared Event FaxDocs As FaxArgs 
C. Public Class FaxArgs 
Inherits EventArgs 
Private coverPageInfo As String 
Public Sub New(ByVal coverInfo As String) 
Me.coverPageInfo = coverInfo 
End Sub 
Public ReadOnly Property CoverPageInformation As String 
Get 
Return Me.coverPageInfo 
End Get 
End Property 
End Class 

D. Public Class FaxArgs 
Inherits EventArgs 
Private coverPageInfo As String 
Public ReadOnly Property CoverPageInformation As String 
Get 
Return Me.coverPageInfo 
End Get 
End Property 
End Class 




















Answer: A 

Explanation: 

An event is declared by using the event keyword followed by a delegate type and then a name for 
the event. 

B fax is not a delegate type. 
C&D do not declare events. 











QUESTION NO: 294 

You work as the application developer at CertKiller.com. You are developing a new application. 
You must define the code segment which will create a common language runtime (CLR) unit of 
isolation within the new application. 

Choose the code segment which you should use to accomplish this task. 

A. Dim mySetup As AppDomainSetup = _ 
AppDomain.CurrentDomain.SetupInformationmySetup.ShadowCopyFiles = "true" 
B. Dim myProcess As System.Diagnostics.Process myProcess = New 
System.Diagnostics.Process() 
C. Dim domain As AppDomain domain = AppDomain.CreateDomain("CertKillerDomain") 
D. Dim myComponent As System.ComponentModel.ComponentmyComponent = New 
System.ComponentModel.Component() 




















Answer: C 

Explanation: Create a new ApplicationDomain using the AppDomain.CreateDomain() method. 

A ShadowCopyFiles property of AppDomainSetup controls whether shadow copying is enabled or 
disabled. 

B the Process class is used to represent an existing process running on a computer. 

D The ComponentModel.Component class is used for sharing components between applications. 











QUESTION NO: 295 

You work as the application developer at CertKiller.com. You are creating a class library which 
must be able to access system environment variables. 

You must set a call method which will only force a runtime SecurityException if the callers which 
are higher in the call stack, fail to have the required permissions. 

Choose the call method which will do this. 

A. Demand() 
B. Assert() 
C. PermitOnly() 
D. Deny() 




















Answer: A 

Explanation: 

Demand forces all callers in the call stack to have the specified permission. 

PermitOnly will instruct the runtime to reduce the access by only allowing callers with the 
permissions explicitly stated and nothing else. 

Assert will ignore the permissions of callers and allow them indiscriminately. 

Deny will explicitly deny access if the caller has the specified permission. 











QUESTION NO: 296 

You work as the application developer at CertKiller.com. You are creating a new custom event 
handler that will be set up to automatically print all open documents. The custom event handler 
must also assist in identifying how many document copies must be printed. You must determine which custom event arguments class to pass as a parameter to the custom 
event handler. 

Choose the code segment which you should use to accomplish this task. 

A. Public Class PrintingArgs 
Private _copies As Integer 
Public Sub New(ByVal numberOfCopies As Integer) 
Me._copies = numberOfCopies 
End Sub 
Public ReadOnly Property Copies() As Integer 
Get 
Return Me._copies 
End Get 
End Property 
End Class 
B. Public Class PrintingArgs 
Inherits EventArgs 
Private _copies As Integer 
Public Sub New(ByVal numberOfCopies As Integer) 
Me._copies = numberOfCopies 
End Sub 
Public ReadOnly Property Copies() As Integer 
Get 
Return Me._copies 
End Get 
End Property 
End Class 
C. Public Class PrintingArgs 
Private eventArgs As EventArgs 
Public Sub New(ByVal args As EventArgs) 
Me.eventArgs = args 
End Sub 
Public ReadOnly Property Args() As EventArgs 
Get 
Return eventArgs 
End Get 
End Property 
End Class 
D. Public Class PrintingArgs 
Inherits EventArgs 
Private copies As IntegerEnd Class 




















Answer: B 

Explanation: 

The event handler will require a parameter of type EventArgs or a derived type. The derived type 
in this example will question states that the event handler helps specify the number of documents 
that require printing, this information will have to come from the derived EventArgs class in the 
form of an instance variable. 

A & C do not derive from EventArgs hence cannot fit into the event handling model. 

D does not expose the copies instance variable. 











QUESTION NO: 297 

You work as the application developer at CertKiller.com. You are working on a new application 
named CertKillerApp05. CertKillerApp05 is configured to dynamically load assemblies from the 
application directory. 

You must define the code segment that will dynamically load an assembly named 
CertKillerAss25.dll into the current application domain. 

Choose the code segment which you should use to accomplish this task. 

A. Dim domain As AppDomain = AppDomain.CurrentDomain 
Dim myPath As String = _ Path.Combine(domain.BaseDirectory, "CertKillerAss25.dll") 
Dim asm As [Assembly] = [Assembly].LoadFrom(myPath) 
B. Dim domain As AppDomain = AppDomain.CurrentDomain 
Dim myPath As String = _ Path.Combine(domain.BaseDirectory, "CertKillerAss25.dll") 
Dim asm As [Assembly] = [Assembly].Load(myPath) 
C. Dim domain As AppDomain = AppDomain.CurrentDomain 
Dim myPath As String = _ Path.Combine(domain.DynamicDirectory, "CertKillerAss25.dll") 
Dim asm As [Assembly] = _ AppDomain.CurrentDomain.Load(myPath) 
D. Dim domain As AppDomain = AppDomain.CurrentDomain 
Dim asm As [Assembly] = domain.GetData("CertKillerAss25.dll") 




















Answer: A 

Explanation: 

The Assembly.LoadFrom() method can be called to dynamically load an assembly from file. 

B the Load method requires an AssemblyName object as a parameter. 

C it is not possible to use AppDomain.Load to load an assembly from file. D AppDomain.GetData gets information stored in the AppDomain for the specified assembly. It 
cannot load an assembly. 











QUESTION NO: 298 

You work as the application developer at CertKiller.com. You must write the code segment which 
will enable you to read the entire contents of a file named Data.txt into a single string variable. 

Choose the code segment that will do this. 

A. Dim result As String = Nothing 
Dim reader As New StreamReader("Data.txt")result = reader.Read().ToString() 
B. Dim result As String = Nothing 
Dim reader as New StreamReader("Data.txt")result = reader.ReadToEnd() 
C. Dim result As String = string.EmptyDim reader As New StreamReader("Data.txt") 
While Not reader.EndOfStream 
result &= reader.ToString() 
End While 
D. Dim result as String = Nothing 
Dim reader As New StreamReader("Data.txt")result = reader.ReadLine() 




















Answer: B 

Explanation: 

Create a StreamReader based on the file and call the ReadToEnd() method to quickly read the 
entire file and return a string. 

A & D does not read the entire file. 

C calling ToString() on the reader will give a string representation of the stream and will not read 
from the stream. 











QUESTION NO: 299 

You work as the application developer at CertKiller.com. You must create a code segment that will 
perform these tasks: ? 
Gets the name of each paused service. ? 
Passes the name to the Add method of Collection5. Gets the name of each paused service. ? 


Choose the code segment which you should use. 
A. Dim searcher As ManagementObjectSearcher = _New ManagementObjectSearcher( _ "Select 
* from Win32_Service where State = 'Paused'")For Each svc As ManagementObject In 
searcher.Get() 
Collection5.Add(svc("DisplayName")) 
Next 
B. Dim searcher As ManagementObjectSearcher = _New ManagementObjectSearcher ( _ "Select 
* from Win32_Service", "State = 'Paused'")For Each svc As ManagementObject In searcher.Get() 
Collection5.Add(svc("DisplayName")) 
Next 
C. Dim searcher As ManagementObjectSearcher = _ New ManagementObjectSearcher( _ "Select 
* from Win32_Service")For Each svc As ManagementObject In searcher.Get() 
If svc("State").ToString() = "'Paused'" Then 
Collection5.Add(svc("DisplayName")) 
End If 
Next 
D. Dim searcher As New ManagementObjectSearcher()searcher.Scope = New 
ManagementScope("Win32_Service")For Each svc As ManagementObject In searcher.Get() 
If svc("State").ToString() = "Paused" Then 
Collection5.Add(svc("DisplayName")) 
End If 
Next 




















Answer: A 

Explanation: 

Use the ManagmentObjectSearcher to search for all services with a paused state. Iterate over the 
returned collection and add the display name to Collection5. 

B The constructor is invoked incorrectly. 

C & D the query is incorrect. The searcher does not restrict to paused services. 











QUESTION NO: 300 

You work as the application developer at CertKiller.com. You are developing a new method that 
must pass data to another method named Process. Your method accepts a string parameter 
named message. 

The method you are writing must break the message parameter into individual lines of text. Each 
individual line must then be passed to the Process method. A. Dim reader As New 
StringReader(message)ProcessMessage(reader.ReadToEnd())reader.Close() 
B. Dim reader As New StringReader(message)While reader.Peek() <> -1 
Dim line as String = reader.Read().ToString() 
ProcessMessage(line) 
End Whilereader.Close() 
C. Dim reader As New StringReader(message)ProcessMessage(reader.ToString())reader.Close() 
D. Dim reader As New StringReader(message)While reader.Peek() <> -1 
ProcessMessage(reader.ReadLine()) 
End Whilereader.Close() 




















Answer: D 

Explanation: 

StringReader.ReadLine() allows for lines to be read line by line. 

A ReadToEnd() will read the entire stream. 

B Read() will not read the line but only the next character. 

C will not read from the message but will just give a string representation of the reader. 











QUESTION NO: 301 

You work as the application developer at CertKiller.com. You are writing a method that will 
execute by using the credentials of the end user. Microsoft Windows groups must be used to 
authorize the user. 

You must develop the code segment which will recognize if the user exists in the local group 
named Sales. 

Choose the code segment that will do this. 

A. Dim objUser As WindowsIdentity = WindowsIdentity.GetCurrentFor Each objGroup As 
IdentityReference In objUser.Groups 
Dim objNT As NTAccount = _ 
DirectCast(objGroup.Translate( _ 
Type.GetType("NTAccount")), NTAccount) 
Dim blnAuth As Boolean = objNT.Value.Equals( _ 
Environment.MachineName & "\Sales") 
If blnAuth Then Exit For 
Next 
B. Dim objUser As WindowsPrincipal = _ 
DirectCast(Thread.CurrentPrincipal, WindowsPrincipal) 
Dim blnAuth As Boolean = objUser.IsInRole("Sales") 
C. Dim objUser As GenericPrincipal = _ 
DirectCast(Thread.CurrentPrincipal, GenericPrincipal) 
Dim blnAuth As Boolean = objUser.IsInRole("Sales") 
D. Dim objUser As WindowsPrincipal = _ 
DirectCast(Thread.CurrentPrincipal, WindowsPrincipal) 
Dim blnAuth As Boolean = _ 
objUser.IsInRole(Environment.MachineName) 




















Answer: B 

Explanation: 

To check the role membership of the current windows user, user the IsInRole() method of the 
WindowsPrincipal in the current thread. 

A it is a lot more complicated to iterate through all the groups the user belongs to and checking for 
matches. The Principal classes are for this very purposes and should be used. 

C uses GenericPrincipal. WindowsPrincipal should be used for windows accounts. There is an 
invalid cast from WindowsPrincipal to GenericPrincipal. 

D does not specify the group correctly. 











QUESTION NO: 302 

You work as the application developer at CertKiller.com. You are creating a new method that must 
hash specific data by applying the MD5 algorithm. 

You must write the hash of the incoming parameter by using the MD5 algorithm. The data must be 
passed to your method as a byte array named message. The resultant data must then be placed 
into a byte array. 

Choose the code segment which will achieve your goal. 

A. Dim objAlgo As HashAlgorithm = HashAlgorithm.Create("MD5") 
Dim hash() As Byte = objAlgo.ComputeHash(message) 
B. Dim objAlgo As HashAlgorithm = HashAlgorithm.Create("MD5") 
Dim hash() As Byte = BitConverter.GetBytes(objAlgo.GetHashCode) 
C. Dim objAlgo As HashAlgorithmobjAlgo = HashAlgorithm.Create(message.ToString) 
Dim hash() As Byte = objAlgo.Hash 
D. Dim objAlgo As HashAlgorithm = HashAlgorithm.Create("MD5") 
Dim hash() As ByteobjAlgo.TransformBlock(message, 0, message.Length, hash, 0) 




















Answer: A 

Explanation: 

Create a HashAlgorithm object based on the MD5 algorithm and call the ComputerHash method 
that will return the hash as an array of bytes. 

B GetHashCode() will call the method inherited from object, it will not hash the message. 

C The parameter of the Create method should specify the type of hashing algorithm to use not the 
message to be hashed. 

D TransferBlock is more appropriate for hashing part of a message. Also it should be called with 
TransferEndBlock. 











QUESTION NO: 303 

You work as the application developer at CertKiller.com. CertKiller.com has its headquarters in 
Chicago and a branch office in Mexico. 

You are developing a new application that will print a report. When the report is generated and 
printed by users in the Mexico branch office, the report must show the current date in the Mexican 
Spanish format. 

Which of the following code segments will accomplish the task? 

A. Dim DTFormat As DateTimeFormatInfo = _ 
New CultureInfo("es-MX", False).DateTimeFormatDim DT As New DateTime( _ 
DateTime.Today.Year, DateTime.Today.Month, DateTime.Today.Day) 
Dim strDate As String = _ 
DT.ToString(DTFormat.LongDatePattern) 
B. Dim objCalendar As Calendar = _ 
New CultureInfo("es-MX", False).CalendarDim DT As New DateTime( _ 
DateTime.Today.Year, DateTime.Today.Month, DateTime.Today.Day) 
Dim strDate As String = DT.ToString 
C. Dim strDate As String = _ 
DateTimeFormatInfo.CurrentInfo.GetMonthName( _ 
DateTime.Today.Month) 
D. Dim strDate As String = _ 
DateTime.Today.Month.ToString("es-MX") 




















Answer: A 

Explanation: 

Create a Mexican Spanish CultureInfo object. Convert the date to a string using the 
DateTimeFormatInfo returned by the CultureInfo object. 

B does not use the CultureInfo object to convert the date to a string. 

C does not use the Mexican Spanish culture. 

D the DateTime.ToString() method cannot take a string code representation of the culture. 











QUESTION NO: 304 

You work as the application developer at CertKiller.com. You are working on an application named 
CertKillerApp10. CertKillerApp10 must be configured to use role-based security and 
authentication. 

You must develop the code segment which will result in the runtime assigning an unauthenticated 
principal object to each running thread. 

Choose the code segment which will accomplish the task. 

A. Dim objDomain As AppDomain = AppDomain.CurrentDomainobjDomain.SetPrincipalPolicy( _ 
PrincipalPolicy.WindowsPrincipal) 
B. Dim objDomain As AppDomain = 
AppDomain.CurrentDomainobjDomain.SetThreadPrincipal(New WindowsPrincipal(Nothing)) 
C. Dim objDomain As AppDomain = AppDomain.CurrentDomainobjDomain.SetAppDomainPolicy( 
_ 
PolicyLevel.CreateAppDomainLevel()) 
D. Dim objDomain As AppDomain = AppDomain.CurrentDomainobjDomain.SetPrincipalPolicy( _ 
PrincipalPolicy.UnauthenticatedPrincipal) 




















Answer: D 

Explanation: 

Setting the PrincipalPolicy for the AppDomain to UnauthenticatedPrincipal will default the Principal 
for each thread to an unauthenticated principal . 

A sets the policy to WindowsPrincipal, threads will have their principal set according the windows 
account that they are running as. 

B SetThreadPrincipal() does not set the default policy for all new threads. Also a WindowsPrincipal 
is used instead of UnauthenticatedPrincipal. 

C SetAppDomainPolicy is used to set the security policy level for the domain. 











QUESTION NO: 305 

You work as the application developer at CertKiller.com. You have to develop a method which will 
clear a queue named badqueue. 

Choose the code segment which will accomplish this task. 

A. Dim e As ObjectFor Each e In badqueueq.Dequeue() 
Next 
B. Dim e As ObjectFor Each e In badqueueq.Enqueue(Nothing) 
Next 
C. badqueue.Clear() 
D. badqueue.Dequeue() 




















Answer: C 

Explanation: 

Simply call the Clear() method to empty a queue. 

A Dequeuing all of the items in a queue will also serve the same affect but it is a lot more 
roundabout. 

B attempts to re-queue items that are already in the queue 

D will de-queue only one item that is at the front of the queue. 











QUESTION NO: 306 

You work as the application developer at CertKiller.com. You are working on a new requirement. 
You have to create a class library that will open the network socket connections to computers on 
the CertKiller.com network. 

The class library must be deployed to the global assembly cache, with full trust granted. To cater 
for network socket connections being used, you develop this code segment: 

Dim objPermission As SocketPermission = New 
_SocketPermission(System.Security.Permissions.PermissionState.Unrestricted)objPermission.As 
sert() You discover though that there are certain existing applications which do not have the required 
permissions to open the network socket connections. You decide to cancel the assertion. 

Choose the code segment which will accomplish this task. 

A. CodeAccessPermission.RevertAssert() 
B. CodeAccessPermission.RevertDeny() 
C. objPermission.Deny() 
D. objPermission.PermitOnly() 




















Answer: A 

Explanation: 

CodeAccessPermission.ReverAssert() should be used to undo a previous Assert call. 

B is used to revert a previous deny call. 

C & D are used to reduce the CAS permissions, they do not undo a previous Assert call. 











QUESTION NO: 307 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp05. CertKillerApp05 is configured to use SOAP to exchange data with other 
applications deployed on the CertKiller.com network. 

In your configuration, you specify that a class named Department inherits from ArrayList to pass 
objects to the other application. The Department object is named depart. 

You must perform the configuration which will enable the application to serialize the Department 
object for transport via SOAP. 

Choose the code segment which will accomplish this task. 

A. Dim formatter As New SoapFormatter() 
Dim buffer As Byte() = New Byte(dept.Capacity) {} 
Dim myStream As New MemoryStream(buffer) Dim o As ObjectFor Each o In dept 
formatter.Serialize(myStream, o) 
Next 
B. Dim formatter As New SoapFormatter() 
Dim buffer As Byte() = New Byte(dept.Capacity) 
Dim myStream As New MemoryStream(buffer)formatter.Serialize(myStream, dept) 
C. Dim formatter As New SoapFormatter() 
Dim myStream As New MemoryStream() 
Dim o as ObjectFor Each o In dept 
formatter.Serialize(myStream, o) 
Next 
D. Dim formatter As New SoapFormatter() 
Dim myStream As New MemoryStream()formatter.Serialize(myStream, dept) 




















Answer: D 

Explanation: 

Simply serialize the entire object to a stream using a SoapFormatter. 

A&C attempt to serialize components of the object rather the object itself. 

B attempts to serialize to an array, however the array will not be big enough to store the serialized 
object because it is not sized on the entire object. 











QUESTION NO: 308 

You work as the application developer at CertKiller.com. You are working on code segment that 
must use platform invoke to call a function from the Win32 Application Programming Interface 
(API). The code segment you have written is as follows: 

Dim r As Integer = MessageBox(hWnd, strText, strCaption, strType) 

You must choose a method prototype. Choose the code segment that provides for this. 

A. <DllImport("user32")> _Function MessageBox( _ 
ByVal hWnd As IntPtr, ByVal text As String, _ 
ByVal Caption As String, ByVal t As UInt32) As IntegerEnd Function 
B. <DllImport("user32")> _Function MessageBoxA( _ 
ByVal hWnd As IntPtr, ByVal text As String, _ 
ByVal Caption As String, ByVal t As UInt32) As IntegerEnd Function 
C. <DllImport("user32")> _Function Win32API_User32_MessageBox ( _ 
ByVal hWnd As IntPtr, ByVal text As String, _ 
ByVal Caption As String, ByVal t As UInt32) As IntegerEnd Function 
D. <DllImport("C:\WINDOWS\system32\user32.dll ")> _Function MessageBox( _ 
ByVal hWnd As IntPtr, ByVal text As String, _ 
ByVal Caption As String, ByVal t As UInt32) As IntegerEnd Function 




















Answer: A Explanation: 

Mark the prototype with the Dllimport attribute specifying the library\dll that the function resides in. 

B creates a prototype for the MessageBoxA function not MessageBox . 
C it is not necessary to specify the physical path because user32.dll will be in the path 
environment variable. Also it will not work with versions of windows (some may use 
c:\winnt\system32) 












QUESTION NO: 309 

You work as the application developer at CertKiller.com. You want to modify the current security 
settings of a file named CertKillerData.xml, as follows: 
You must preserve all existing inherited access rules.You must prevent the access rules from 
inheriting future modifications 

Choose the code segment which will accomplish the task. 

A. Dim objSecurity As New FileSecurity( _ 
" CertKillerData.xml", AccessControlSections.All)objSecurity.SetAccessRuleProtection(True, True) 
File.SetAccessControl("CertKillerData.xml", objSecurity) 
B. Dim objSecurity As New FileSecurity()objSecurity.SetAccessRuleProtection(True, True) 
File.SetAccessControl("CertKillerData.xml", objSecurity) 
C. Dim objSecurity As FileSecurity = 
_File.GetAccessControl("CertKillerData.xml")objSecurity.SetAccessRuleProtection(True, True) 
D. Dim objSecurity As FileSecurity =_ 
File.GetAccessControl("CertKillerData.xml")objSecurity.SetAuditRuleProtection(True, True) 
File.SetAccessControl("CertKillerData.xml", objSecurity) 




















Answer: A 

Explanation: 

Retrieve the full access control list for the file, prevent access rules from inheriting in the future by 
calling Security.SetAccessRuleProtection(). Finally call File.SetAccessControl() to apply the 
amended FileSecurity to the file. 

B does not preserve the existing access rules. It overwrites them. 

C does not apply the amended FileSecurity object back to the file. 

D FileSecurity.SetAuditRuleProtection() is used for controlling audit rules not access rules. 









QUESTION NO: 310 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp09. 

You are creating a method and want to view its output that returns a string. You are using 
Microsoft Visual Studio 2005 IDE to examine the method's output. You define the output of the 
method to the string variable named fName. You want certain information printed in a single line: 
This message must be printed: Test UnsuccessfulWhen the value of fName is not equal to "Kara 
Lang", the value of fName must be printed. 

The code segment that you use must simultaneously facilitate uninterrupted execution of 
CertKillerApp09. 

Which of the following code segments should you use to achieve your goal? 

A. Debug.Assert(fName = "Kara Lang", "Test Unsuccessful: ", fName) 
B. Debug.WriteLineIf(fName <> " Kara Lang", _ fName, "Test Unsuccessful") 
C. If fName <> " Kara Lang" Then 
Debug.Print("Test Unsuccessful: ") 
Debug.Print(fName) 
End If 
D. If fName <> " Kara Lang" Then 
Debug.WriteLine("Test Unsuccessful: ") 
Debug.WriteLine(fName) 
End If 




















Answer: B 

Explanation: 

Debug.WriteLineIf() will conditionally write the "Test Unsuccessful", it will not interrupt execution of 
the application. 

A an Assert will stop execution of the application in debug mode if the condition is not met. 

C & D could be used but they execute in the release configurations 











QUESTION NO: 311 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp12. CertKillerApp12 will be used to store customer information on 
CertKiller.com's customers who are dispersed across the continent. You need to create internal utilities for CertKillerApp12, and need to collect information on all 
CertKiller.com's customers that are located in Canada. 

Choose the code segment which will perform this task. 

A. For Each objCulture As CultureInfo In _CultureInfo.GetCultures(CultureTypes.SpecificCultures) 
...Next 
B. Dim objCulture As New CultureInfo("CA") 
... 
C. Dim objRegion As New RegionInfo("CA") 
... 
D. Dim objRegion As New RegionInfo("")If objRegion.Name = "CA" Then 
...End If 




















Answer: C 

Explanation: 

The RegionInfo class can be used to get information about a region. 

A & B CultureInfo is used to control formatting, sorting & comparing of culture sensitive data. E.g 
currencies, calendar dates etc. 

D Does not initialise the RegionInfo object correctly i.e to Canada . 











QUESTION NO: 312 

You work as the application developer at CertKiller.com. You have created a new application 
named CertKillerApp05. CertKillerApp05 is configured to forward an e-mail message. The SMTP 
server on the local subnet is named CERTKILLER-SR31. 

You want to test CertKillerApp05. You decide to use a source address of mia@CertKiller.com; and 
a target address of dest@CertKiller.com. 

Choose the code segment which you should use to test whether CertKillerApp05 sends e-mail 
messages. 

A. Dim MailFrom As New MailAddress("mia@CertKiller.com", "Mia") 
Dim MailTo As New MailAddress("dest@CertKiller.com", "Dest") 
Dim Message As New MailMessage(MailFrom, MailTo)Message.Subject = "Hello"Message.Body 
= "Testing"Message.Dispose() 
B. Dim SMTPClient As String = "CERTKILLER-SR31" 
Dim MailFrom As String = mia@CertKiller.com 
Dim MailTo As String = dest@CertKiller.com 
Dim Subject As String = "Hello" 
Dim Body As String = "Testing"Dim Message As New MailMessage(MailFrom, MailTo, Subject, 
SMTPClient) 


C. Dim MailFrom As New MailAddress("mia@CertKiller.com", "Mia") 
Dim MailTo As New MailAddress("dest@CertKiller.com", "Dest") 
Dim Message As New MailMessage(MailFrom, MailTo)Message.Subject = "Hello"Message.Body 
= "Testing" 
Dim objClient As New SmtpClient("CERTKILLER-SR31")objClient.Send(Message) 
D. Dim MailFrom As New MailAddress("mia@CertKiller.com", "Mia") 
Dim MailTo As New MailAddress("dest@CertKiller.com", "Dest")) 
Dim Message As New MailMessage(MailFrom, MailTo)Message.Subject = "Hello"Message.Body 
= "Testing" 
Dim Info As New SocketInformationDim Client As New Socket(Info) 
Dim Enc As New ASCIIEncodingDim Bytes() As Byte = 
Enc.GetBytes(Message.ToString)Client.Send(Bytes) 




















Answer: C 

Explanation: 

To Send a simple mail message construct a MailMessage object and a SmptClient object. Call the 
SmtpClient.Send instance method supplying the MailMessage object as a parameter. 

A creates a MailMessage but then destroys it. 

B creates a MailMessage but then does not do anything with it. 

D tries to do something with sockets, this is unnecessary because there is a SMTP server 
available. The question implies delivering the mail via SMTP. 











QUESTION NO: 313 

You work as the application developer at CertKiller.com. CertKiller.com has its headquarters in 
Chicago and a branch office in Mexico. 

You are developing a new application that will print a report. When the report is generated and 
printed by users in the Mexico branch office, the report must show the current date in the Mexican 
Spanish format. 

Which of the following code segments will accomplish the task? A. Dim DTFormat As DateTimeFormatInfo = _ 
New CultureInfo("es-MX", False).DateTimeFormatDim DT As New DateTime( _ 
DateTime.Today.Year, DateTime.Today.Month, DateTime.Today.Day) 
Dim strDate As String = _ 
DT.ToString(DTFormat.LongDatePattern) 
B. Dim objCalendar As Calendar = _ 
New CultureInfo("es-MX", False).CalendarDim DT As New DateTime( _ 
DateTime.Today.Year, DateTime.Today.Month, DateTime.Today.Day) 
Dim strDate As String = DT.ToString 
C. Dim strDate As String = _ 
DateTimeFormatInfo.CurrentInfo.GetMonthName( _ 
DateTime.Today.Month) 
D. Dim strDate As String = _ 
DateTime.Today.Month.ToString("es-MX") 




















Answer: A 











QUESTION NO: 314 

You work as the application developer at CertKiller.com. You are creating a new code segment. 
You must ensure that the data contained within an isolated storage file, named Settings.dat, is 
returned as a string. Settings.dat is machine-scoped. 

Choose the code segment which will achieve your goal. 

A. Dim objStream As IsolatedStorageFileStreamobjStream = New IsolatedStorageFileStream( _ 
"Settings.dat", FileMode.Open) 
Dim result As String = New StreamReader(objStream).ReadToEnd 
B. Dim objFile As IsolatedStorageFileobjFile = 
IsolatedStorageFile.GetMachineStoreForAssemblyDim objStream As 
IsolatedStorageFileStreamobjStream = New IsolatedStorageFileStream( _ 
"Settings.dat", FileMode.Open, objFile) 
Dim result As String = New StreamReader(objStream).ReadToEnd 
C. Dim objStream As IsolatedStorageFileStreamobjStream = New IsolatedStorageFileStream( _ 
"Settings.dat", FileMode.Open) 
Dim result As String objStream.toString 
D. Dim objFile As IsolatedStorageFileobjFile = 
IsolatedStorageFile.GetMachineStoreForAssemblyDim objStream As 
IsolatedStorageFileStreamobjStream = New IsolatedStorageFileStream( _ 
"Settings.dat", FileMode.Open, objFile) 
Dim result As String = objStream.ToString 




















Answer: B 

Explanation: 

Retrieve the IsolatedStorageFile for the machine store. Use an IsolatedStorageFileStream to read 
from the desired file within the machine store. 

A & C do not get the IsolatedStorageFile for the machine context. 

D returns a string representation of the IsolatedStorageFileStream object not a String of the files 
contents as the question requests. 











QUESTION NO: 315 

You work as the application developer at CertKiller.com. You are developing a new method that 
must decrypt, encrypted confidential data. The confidential data to decrypt is encrypted via the 
Triple DES (3-DES) algorithm. 


Your new method takes these parameters: 
A byte array, named cipherMessage that must be decrypted.A key, named keyThe initialization 
vector, named iv. 


Choose the code segment which will decrypt the specified data via the TripleDES class. The 
decrypted data must be in string. 


A. Dim objDES As New TripleDESCryptoServiceProviderobjDES.BlockSize = 
cipherMessage.LengthDim objCrypto As ICryptoTransform = _ 
objDES.CreateDecryptor(key, iv) 
Dim cipherStream As New MemoryStream(cipherMessage) 
Dim cryptoStream As New CryptoStream( _ 
cipherStream, objCrypto, CryptoStreamMode.Read) 
Dim message As Stringmessage = New StreamReader(cryptoStream).ReadToEnd 
B. Dim objDES As New TripleDESCryptoServiceProviderobjDES.FeedbackSize = 
cipherMessage.LengthDim objCrypto As ICryptoTransform = _ 
objDES.CreateDecryptor(key, iv) 
Dim cipherStream As New MemoryStream(cipherMessage) 
Dim cryptoStream As New CryptoStream( _ 
cipherStream, objCrypto, CryptoStreamMode.Read) 
Dim message As Stringmessage = New StreamReader(cryptoStream).ReadToEnd 
C. Dim objDES As New TripleDESCryptoServiceProvider 
Dim objCrypto As ICryptoTransform = _ 
objDES.CreateDecryptor() 
Dim cipherStream As New MemoryStream(cipherMessage) 
Dim cryptoStream As New CryptoStream( _ 
cipherStream, objCrypto, CryptoStreamMode.Read) 
Dim message As Stringmessage = New StreamReader(cryptoStream).ReadToEnd 


D. Dim objDES As New TripleDESCryptoServiceProvider 
Dim objCrypto As ICryptoTransform = _ 
objDES.CreateDecryptor(key, iv) 
Dim cipherStream As New MemoryStream(cipherMessage) 
Dim cryptoStream As New CryptoStream( _ 
cipherStream, objCrypto, CryptoStreamMode.Read) 
Dim message As Stringmessage = New StreamReader(cryptoStream).ReadToEnd 




















Answer: D 











QUESTION NO: 316 

You work as the application developer at CertKiller.com. You are creating a new class which 
contains a method named GetCurrentRate. GetCurrentRate extracts the current interest rate from 
a variable named currRate. currRate contains the current interest rate which should be used. 

You develop serialized representations of the class and now need to write a code segment which 
updates the currRate variable with the current interest rate if an instance of the class is 
deserialized. 

Choose the code segment which will accomplish this task. 

A. <OnSerializing> _Friend Sub UpdateValue (ByVal context As StreamingContext) 
currRate = GetCurrentRate() 
End Sub 
B. <OnSerializing> _ Friend Sub UpdateValue(ByVal info As SerializationInfo) 
info.AddValue("currentRate", GetCurrentRate()) 
End Sub 
C. <OnDeserializing> _ Friend Sub UpdateValue(ByVal info As SerializationInfo) 
info.AddValue("currentRate", GetCurrentRate()) 
End Sub 
D. <OnDeserialized> _Friend Sub UpdateValue (ByVal context As StreamingContext) 
currRate = GetCurrentRate() 
End Sub 




















Answer: D 

Explanation: 

A method with the OnDeserialized attribute will be called after Deserialization and any instance 
variables can be set. A & B the method will fire during serializing, the question is concerned with reconstructing the 
object during deserialization. 

C the OnDeserializing attribute is useful for default values. OnDeserializing attribute works with a 
method that contains a StreamContext parameter and not a SerializationInfo parameter. 











QUESTION NO: 317 

You work as the application developer at CertKiller.com. You have to develop an application 
named CertKillerApp21. When deployed, CertKillerApp21 will be used by numerous users on the 
same computer. CertKillerApp21 uses more than one assembly, and is configured to use isolated 
storage to store certain user information. 

You must create a new directory named UserInfo in the isolated storage area which is scoped to 
the current Microsoft Windows identity and assembly. 

Choose the code segment which will accomplish this task. 

A. Dim objStore As IsolatedStorageFileobjStore = 
IsolatedStorageFile.GetUserStoreForAssemblyobjStore.CreateDirectory("UserInfo") 
B. Dim objStore As IsolatedStorageFileobjStore = 
IsolatedStorageFile.GetMachineStoreForAssemblyobjStore.CreateDirectory("UserInfo") 
C. Dim objStore As IsolatedStorageFileobjStore = 
IsolatedStorageFile.GetUserStoreForDomainobjStore.CreateDirectory("UserInfo") 
D. Dim objStore As IsolatedStorageFileobjStore = 
IsolatedStorageFile.GetUserStoreForApplicationobjStore.CreateDirectory("UserInfo") 




















Answer: A 

Explanation: 

The user store for the assembly is the correct store that is required. It is returned by 
IsolatedStorageFile.GetUserStoreForAssembly(). 

B,C & D return Isolated Storage File stores of incorrect scope 











QUESTION NO: 318 

You work as the application developer at CertKiller.com. You are creating a new method. Your 
method must be localized to Italy, and must search a string named searchList for a specific 
substring named searchValue. Which code segment should you use to perform this task? 

A. Return SearchList.IndexOf(SearchValue) 
B. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoReturn objComparer.Compare(SearchList, SearchValue) 
C. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoIf SearchList.IndexOf(SearchValue) > 0 Then 
Return TrueElse 
Return FalseEnd If 
D. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoIf objComparer.IndexOf(SearchList, SearchValue) > 0 Then 
Return TrueElse 
Return FalseEnd If 




















Answer: D 











QUESTION NO: 319 

You work as the application developer at CertKiller.com. You are developing a new method that 
must encrypt confidential data. The method must use the Data Encryption Standard (DES) 
algorithm. Your new method takes these parameters: 
A byte array, named message, that must be encrypted by applying the DES algorithm.A key, 
named key, which will be used to encrypt the data.The initialization vector, named iv. 


Once the data is encrypted, it must be added to the MemoryStream object. 


Choose the code segment which will encrypt the specified data and add it to the MemoryStream 
object. 


A. Dim objDES As New DESCryptoServiceProviderobjDES.BlockSize = message.Length 
Dim objCrypto As ICryptoTransform = obj 
DES.CreateDecryptor(key, iv) 
Dim cipherStream As New MemoryStream 
Dim cryptoStream As New CryptoStream(cipherStream, objCrypto, CryptoStreamMode.Write) 
B. Dim objDES As New DESCryptoServiceProvider 
Dim objCrypto As ICryptoTransform = objDES.CreateDecryptor(key, iv) 
Dim cipherStream As New MemoryStream 
Dim cryptoStream As New CryptoStream(cipherStream, objCrypto, CryptoStreamMode.Write) 
cryptoStream.Write(message, 0, message.Length) 
C. Dim objDES As New DESCryptoServiceProvider 
Dim objCrypto As ICryptoTransform = obj 
DES.CreateDecryptor() 
Dim cipherStream As New MemoryStream 
Dim cryptoStream As New CryptoStream(cipherStream, objCrypto, CryptoStreamMode.Write) 
cryptoStream.Write(message, 0, message.Length) 


D. Dim objDES As New DESCryptoServiceProvider 
Dim objCrypto As ICryptoTransform = obj 
DES.CreateEncryptor(key, iv) 
Dim cipherStream As New MemoryStream 
Dim cryptoStream As New CryptoStream(cipherStream, objCrypto, CryptoStreamMode.Write) 
cryptoStream.Write(message, 0, message.Length) 




















Answer: D 

Explanation: 

Use the DesCryptoServiceProvider to create a new encryptor.Create a CryptoStream that encrypt 
directly to the MemoryStream and call the Write() method to perform the encryption. 

A Uses a blocksize set to size of the entire message 

B creates a decryptor instead of an encryptor. 

C does not initialise the encryptor with the key and iv correctly. 











QUESTION NO: 320 

You work as the application developer at CertKiller.com. You create a new service application 
named CertKillerApp29. You install CertKillerApp29 on five application servers running in the 
CertKiller.com network. You then apply the code segment shown below. Note that line numbers 
are only included for reference pruposes. 


01 Public Sub StartService(ByVal serverName As String) 
02 Dim crtl As ServiceController = _ 
03 New ServiceController("CertKillerApp29") 
04 If crtl.Status = ServiceControllerStatus.Stopped Then 
05 End If 
06 End Sub 


You want CertKillerApp29 to start if it stops. You must create the routine which will start 
CertKillerApp29 on the server defined by the serverName input parameter. 


Choose the two lines of code which you should include in your code segment. Each correct 
answer presents only part of the complete solution. Choose two answers. 
A. Add this of code between line 03 and line 04: crtl.ServiceName = serverName 
B. Add this of code between line 03 and line 04: crtl.MachineName = serverName 
C. Add this of code between line 03 and line 04: crtl.Site.Name = serverName 
D. Add this of code between line 04 and line 05: crtl.Continue() 
E. Add this of code between line 04 and line 05: crtl.Start() 
F. Add this of code between line 04 and line 05: crtl.ExecuteCommand(0) 




















Answer: B,E 

Explanation: 

The ServiceController is capable of controller services on other computers, the MachineName 
should be specified. The service should be started with the Start() method if it is in the stopped 
state. 

Setting the ServiceName to the machine name is incorrect. 

No such property as SiteName 

Continue cannot re-start a stopped service only a paused one. 

ExecuteCommand is used to fire a custom command on the service. 











QUESTION NO: 321 

You work as the application developer at CertKiller.com. You are working on a new application 
named CertKillerApp20. CertKillerApp20 is configured to perform a series of mathematical 
calculations. 

You create a class named CertKillerAppClass and create a procedure named CertKillerAppSP. 
CertKillerAppSP must execute on an instance of the class. 

You must configure the application's user interface so that it continues to respond for the duration 
that calculations are performed. You must write the code segment for calling the CertKillerAppSP 
procedure which will accomplish your objective. 

Choose the code segment which you should use. 

A. Private Sub CertKillerAppSP()...End Sub Private Sub DoWork() 
Dim myValues As New CertKillerAppClass() 
Dim newThread As New Thread( _ 
New ThreadStart(AddressOf CertKillerAppSP)) 
newThread.Start(myValues) 
End Sub 

B. Private Sub CertKillerAppSP()...End Sub Private Sub DoWork() 
Dim myValues As New CertKillerAppClass() 
Dim delStart As New ThreadStart( _AddressOf CertKillerAppSP) 
Dim newThread As New Thread(delStart)If newThread.IsAlive ThennewThread.Start(myValues) 
End If 
End Sub 
C. Private Sub CertKillerAppSP ( _ByVal values As CertKillerAppClass)...End Sub Private Sub 
DoWork() 
Dim myValues As New CertKillerAppClass() 
Application.DoEvents() 
CertKillerAppSP(myValues) 
Application.DoEvents() 
End Sub 
D. Private Sub CertKillerAppSP ( _ByVal values As Object)...End Sub Private Sub DoWork() 
Dim myValues As New CertKillerAppClass() 
Dim newThread As New Thread( _ 
New ParameterizedThreadStart( _AddressOf CertKillerAppSP)) 
newThread.Start(myValues) 
End Sub 




















Answer: D 

Explanation: 

It is a requirement that the UI continues to respond, hence CertKillerAppSP should execute in a 
separate thread. CertKillerAppSP requires a parameter hence you should use the 
ParameterizedThreadStart delegate. 

A& B attempt to supply a parameter to the ThreadStart delegate. This is not possible. 

C Does not run in a new thread and hence may leave the UI unresponsive. 











QUESTION NO: 322 

You work as the application developer at CertKiller.com. You are creating a new method. Your 
method must be localized to Italy, and must search a string named searchList for a specific 
substring named searchValue. 

Which code segment should you use to perform this task? 

A. Return SearchList.IndexOf(SearchValue) 
B. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoReturn objComparer.Compare(SearchList, SearchValue) 
C. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoIf SearchList.IndexOf(SearchValue) > 0 Then 
Return TrueElse 
Return FalseEnd If 
D. Dim objComparer As CompareInfo = _ 
New CultureInfo("it-IT").CompareInfoIf objComparer.IndexOf(SearchList, SearchValue) > 0 Then 
Return TrueElse 
Return FalseEnd If 




















Answer: D 











QUESTION NO: 323 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKiller15. CertKiller15 will be used to show processes running on remote computers. 
You need to write a method for the application. Your method must accomplish the following: 
Accept the name of the remote computer as a string parameter named strComputer.Return an 
ArrayList object that lists the names of each process running on that specific remote computer. 

Choose the code segment that will accomplish the task. 

A. Dim al As New ArrayList() 
Dim procs As Process() = _ Process.GetProcessesByName(strComputer) 
Dim proc As ProcessFor Each proc In procs 
al.Add(proc) 
Next 
B. Dim al As New ArrayList() 
Dim procs As Process() = Process.GetProcesses(strComputer) 
Dim proc As ProcessFor Each proc In procs 
al.Add(proc) 
Next 
C. Dim al As New ArrayList() 
Dim procs As Process() = _ Process.GetProcessesByName(strComputer) 
Dim proc As ProcessFor Each proc In procs 
al.Add(proc.ProcessName) 
Next 
D. Dim al As New ArrayList() 
Dim procs As Process() = Process.GetProcesses(strComputer) 
Dim proc As ProcessFor Each proc In procs 
al.Add(proc.ProcessName) 
Next 





















Answer: D 

Explanation: 

Call Processes.GetProcesses() supplying the name of the computer and then iterate through the 
returned collection of processes adding the process name to the arraylist. 

A & C use GetProcessByName() and return processes on the current computer only. 

B adds the entire process to the arraylist rather than just the process name. 











QUESTION NO: 324 

You work as the application developer at CertKiller.com. You want to modify a method that returns 
an ArrayList named CertKillerAL. You want to write a code segment which will result in all changes 
made to CertKillerAL being performed in a thread-safe way. 

Choose the code segment which will accomplish the task. 

A. Dim CertKilleral As ArrayList = New ArrayList() 
SyncLock 
CertKilleral.SyncRoot 
Return CertKilleral 
End SyncLock 
B. Dim CertKilleral As ArrayList = New ArrayList() 
SyncLock 
CertKilleral.SyncRoot.GetType() 
Return CertKilleral 
End SyncLock 
C. Dim CertKilleral As ArrayList = New ArrayList() 
Monitor.Enter(CertKilleral) 
Monitor.Exit(CertKilleral) 
Return CertKilleral 
D. Dim al As ArrayList = New ArrayList() 
Dim sync_ CertKilleral as ArrayList = ArrayList.Synchronized(CertKilleral) 
Return sync_ CertKilleral 




















Answer: D 

Explanation: 

A & C the lock will be released when the method returns. B Does not lock the arraylist but attempts to lock its type. 











QUESTION NO: 325 

You work as the application developer at CertKiller.com. You are developing an application named 
CertKillerApp12. You must the write multicast delegate that accepts a DateTime argument. 

Choose the code segment which will accomplish the task. 

A. Public Delegate Function PowerDeviceOn( _ 
ByVal result As Boolean, _ 
ByVal autoPowerOff As DateTime) _ 
As Integer 
B. Public Delegate Function PowerDeviceOn( _ 
ByVal sender As Object, _ 
ByVal autoPowerOff As EventArgs) _ 
As Boolean 
C. Public Delegate Sub PowerDeviceOn( _ 
ByVal autoPowerOff As DateTime) 
D. Public Delegate Function PowerDeviceOn( _ 
ByVal autoPowerOff As DateTime) _ 
As Boolean 




















Answer: C 

Explanation: 

A & B the delegates do not accept an argument of type DateTime 

D The question does not explicitly mention a return type. Also with multicasting only the return 
value of the last method called as part of a multicast chain is returned. Hence return values do not 
tend to be very useful as far as multicasting is concerned. 











QUESTION NO: 326 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp06. 

CertKillerApp06 will be used to transmit confidential financial information over the network. To 
secure the confidential data, you create an X509 Certificate object named certificate and create a 
TcpClient object named client. 

You must now create the code segment that creates an SslStream for communication by applying 
the Transport Layer Security 1.0 protocol. 

Choose the code segment which you should use. 

A. Dim objSSL As New SslStream(client.GetStream)objSSL.AuthenticateAsServer(certificate, 
False, _ 
SslProtocols.None, True) 
B. Dim objSSL As New SslStream(client.GetStream)objSSL.AuthenticateAsServer(certificate, 
False, _ 
SslProtocols.Ssl3, True) 
C. Dim objSSL As New SslStream(client.GetStream)objSSL.AuthenticateAsServer(certificate, 
False, _ 
SslProtocols.Ssl2, True) 
D. Dim objSSL As New SslStream(client.GetStream)objSSL.AuthenticateAsServer(certificate, 
False, _ 
SslProtocols.Tls, True) 




















Answer: D 











QUESTION NO: 327 

You work as the application developer at CertKiller.com. You want to test a new method that 
examines running processes. Your method is configured to return an ArrayList that reveals the 
name and full path of each module loaded by a running process named 
C:\CertKillerApps\Process5. 

Choose the code segment that will show each module loaded by the specific running process? 

A. Dim ar As New ArrayList() 
Dim procs As Process() 
Dim modules As ProcessModuleCollectionprocs = Process.GetProcesses("Process5")If 
procs.Length > 0 Thenmodules = procs(0).Modules 
For Each pm As ProcessModule In Modules 
ar.Add(pm.ModuleName) 
Next 
End If 
B. Dim ar As New ArrayList() 
Dim procs As Process() 
Dim modules As ProcessModuleCollectionprocs = 
Process.GetProcesses("C:\TestApps\Process5.exe")If procs.Length > 0 Thenmodules = 
procs(0).Modules 
For Each pm As ProcessModule In Modules 
ar.Add(pm.ModuleName) 
Next 
End If 

C. Dim ar As New ArrayList() 
Dim procs As Process() 
Dim modules As ProcessModuleCollectionprocs = Process.GetProcessesByName("Process5")If 
procs.Length > 0 Thenmodules = procs(0).Modules 
For Each pm As ProcessModule In Modules 
ar.Add(pm.FileName) 
Next 
End If 
D. Dim ar As New ArrayList() 
Dim procs As Process() 
Dim modules As ProcessModuleCollectionprocs = 
_Process.GetProcessesByName("C:\TestApps\Process5.exe")If procs.Length > 0 Thenmodules = 
procs(0).Modules 
For Each pm As ProcessModule In Modules 
ar.Add(pm.FileName) 
Next 
End If 




















Answer: C 

Explanation: 

Process.GetProcessesByName() should be used to return all the processes that match a process 
name. The modules collection exposes all the modules loaded by the process and can be added 
to an ArrayList. 

A & B GetProcesses() accepts a computer name for retrieving the processes on a remote 
computer. GetProcessesByName() should be used to return processes by their name. 

D the path of the process is not part of the process name. 











QUESTION NO: 328 

You work as the application developer at CertKiller.com. You have to define the code segment 
that will transfer the data of a byte array. The byte array is named dataToSend. Your code 
segment must use a NetworkStream object named netStream when transferring the data of the 
byte array. The cache size you use must be 8,192 bytes. 

Which code segment should you use to accomplish the task? A. Dim memStream As New MemoryStream(8192)memStream.Write(dataToSend, 0, _ 
CType(netStream.Length, Integer)) 
B. Dim memStream As New MemoryStream(8192)netStream.Write(dataToSend, 0, _ 
CType(memStream.Length, Integer)) 
C. Dim bufStream As New BufferedStream(netStream, 8192) 
bufStream.Write(dataToSend, 0, dataToSend.Length) 
D. Dim bufStream As New BufferedStream(netStream) 
bufStream.Write(dataToSend, 0, 8192) 




















Answer: C 

Explanation: 

To send data using a cache it is necessary to use a BufferedStream. The BufferedStream should 
be created with the cache size of 8192 bytes. 

A & B do not employ caching. 

D does not correctly initialise the BufferedStream to have a cache size of 8192 bytes. 











QUESTION NO: 329 

You work as the application developer at CertKiller.com. You must write a code segment that 
includes an undo buffer function. You want the undo function to store data modifications, but it 
must only allow the storage of strings. You want the undo function to undo the most recently 
performed data modifications first. 

Which code segment should you use to achieve your goal? 

A. Dim undoBuffer As New Stack(Of String) 
B. Dim undoBuffer As New Stack() 
C. Dim undoBuffer As New Queue(Of String) 
D. Dim undoBuffer As New Queue() 




















Answer: A 

Explanation: 

A Stack caters for a last in first out scenario similar to what is required in an undo buffer. By using 
Generics you can force a strongly typed collection that takes strings only. 

B is not strongly typed for strings, it will take any type of object. 

C & D Queue is a First in First out collection, it is not appropriate in this instance. 









QUESTION NO: 330 

You work as the application developer at CertKiller.com. You are working on an existing 
application and must load a new assembly into this application. 

You must write the code segment that will require the common language runtime (CLR) to grant 
the assembly a permission set, as though the assembly was loaded from the local intranet zone. 
You must ensure that the default evidence for the assembly is overridden and must create the 
evidence collection. 

Choose the code segment which will accomplish this task. 

A. Dim objEvidence As New Evidence( _ 
Assembly.GetExecutingAssembly.Evidence 
B. Dim objEvidence As New EvidenceobjEvidence.AddAssembly( _ 
New Zone(SecurityZone.Intranet)) 
C. Dim objEvidence As New EvidenceobjEvidence.AddHost( _ 
New Zone(SecurityZone.Intranet)) 
D. Dim objEvidence As New Evidence( _ 
AppDomain.CurrentDomain.Evidence) 




















Answer: C 

Explanation: 

Use the evidence.AddHost method to add Zone evidence. 

A simply gets the evidence of the Executing Assembly and assigns it to a new object, the 
question explicitly wants Intranet zone evidence. 

B Adds assembly evidence, the question asks for host evidence because it is concerned with 
where the assembly was loaded from.# 

D does not create an Evidence object with Intranet zone evidence. 











QUESTION NO: 331 

You work as the application developer at CertKiller.com. You are creating a new code segment 
which is to be used for user authentication and authorization purposes. The current application 
data store already stores the username, password, and roles. 

You must establish the user security context, which should be used for the authorization checks 
like IsInRole. To authorize the user, you have started developing the following code segment: 


If TestPassword(UserName, Password) = False Then 
Throw New Exception("user not authenticated") 
End If 
Dim RolesArray() As String = LookUpUserRoles(UserName) 


From the options below, choose the code which will make the code segment complete. 


A. Dim objID As New GenericIdentity(UserName) 
Dim objUser As New GenericPrincipal(objID, RolesArray) 
Thread.CurrentPrincipal = objUser 
B. Dim objID As New WindowsIdentity(UserName) 
Dim objUser As New WindowsPrincipal(objID) 
Thread.CurrentPrincipal = objUser 
C. Dim objNT As New NTAccount(UserName) 
Dim objID As New GenericIdentity(objNT.Value) 
Dim objUser As New GenericPrincipal(objID, RolesArray) 
Thread.CurrentPrincipal = objUser 
D. Dim objToken As IntPtr = IntPtr.Zeroobj 
Token = LogonUserUsingInterop(UserName, EncryptedPassword) 
Dim objContext As WindowsImpersonationContext =_ 
WindowsIdentity.Impersonate(objToken) 




















Answer: A 

Explanation: 

Because the application storing the credentials, the GenericIdentity & GenericPrincipal classes 
should be used instead of the WindowsIdentity\Principal classes. 

B uses WindowsIdentity & WindowsPrincipal 

C incorrectly uses NTAccount to initialise a GenericPrincipal. GenericPrincipal requires an 
implementation of IIdentity. 

D the WindowsIdentity.Impersonate() is used for running code in the context of another user. 
Impersonation is not what is required. 











QUESTION NO: 332 

You work as the application developer at CertKiller.com. You create a code segment that will call a 
function from the Win32 Application Programming Interface (API) via platform invoke. The precise code segment is: 


Dim PersonName as String = "N?el" 
Dim Msg as String = " Thank you" + PersonName + " for coming ''!" 
Dim r As Boolean= User32API.MessageBox(0, Msg, PersonName, 0) 


You must specify the prototype method that will efficiently assemble the string data. 


Choose the code segment which will accomplish the task. 


A. <DllImport("user32", CharSet:=CharSet.Ansi)> _Public Function MessageBox(ByVal hWnd As 
Int32, _ByVal text As String, ByVal caption As String, _ByVal t As UInt32) As BooleanEnd 
Function 
B. <DllImport("user32", EntryPoint:="MessageBoxA", _CharSet:=CharSet.Ansi)> _Public Function 
MessageBox(ByVal hWnd As Int32, _<MarshalAs(UnmanagedType.LPWStr)> ByVal text As 
String, _<MarshalAs(UnmanagedType.LPWStr)> ByVal caption As String, _ByVal t As UInt32) As 
Boolean 
End Function 
C. <DllImport("user32", CharSet:=CharSet.Unicode)> _Public Function MessageBox(ByVal hWnd 
As Int32, _ByVal text As String, ByVal caption As String, _ByVal t As UInt32) As BooleanEnd 
Function 
D. DllImport("user32", EntryPoint:="MessageBoxA", _CharSet:=CharSet.Unicode)> _Public 
Function MessageBox(ByVal hWnd As Int32, _<MarshalAs(UnmanagedType.LPWStr)> ByVal text 
As String, _<MarshalAs(UnmanagedType.LPWStr)> ByVal caption As String, _ByVal t As UInt32) 
As BooleanEnd Function 




















Answer: C 











QUESTION NO: 333 

You work as the application developer at CertKiller.com. You have created a new dynamic 
assembly named MyAssembly and must ensure that the assembly is saved to disk. 

Choose the code segment which you should use. 

A. Dim objAssembly As New AssemblyName()objAssembly.Name = "MyAssembly"Dim objBuilder 
As AssemblyBuilder = _AppDomain.CurrentDomain.DefineDynamicAssembly( _objAssembly, 
AssemblyBuilderAccess.Run)objBuilder.Save("MyAssembly.dll") 
B. Dim objAssembly As New AssemblyName()objAssembly.Name = "MyAssembly"Dim objBuilder 
As AssemblyBuilder = _AppDomain.CurrentDomain.DefineDynamicAssembly( _objAssembly, 
AssemblyBuilderAccess.Save)objBuilder.Save("MyAssembly.dll") 
C. Dim objAssembly As New AssemblyName()objAssembly.Name = "MyAssembly"Dim objBuilder 
As AssemblyBuilder = _AppDomain.CurrentDomain.DefineDynamicAssembly( _objAssembly, 
AssemblyBuilderAccess.RunAndSave)objBuilder.Save("MyAssembly.dll") 
D. Dim objAssembly As New AssemblyName()objAssembly.Name = "MyAssembly"Dim objBuilder 
As AssemblyBuilder = _AppDomain.CurrentDomain.DefineDynamicAssembly( _objAssembly, 
AssemblyBuilderAccess.Save)objBuilder.Save("c:\MyAssembly.dll") 




















Answer: B 

Explanation: 

Create an AssemblyName object and use it to construct an AssemblyBuilder with save privilege. 
Finally call the Save method on the AssemblyBuilder to write the assembly to disk. 

A Creates an assembly that does not have the privilege to save to disk. 

C does not provide a name the assembly 

D attempts to define a physical file location, this is not compatible with AssemblyBuilder.Save 











QUESTION NO: 334 

You work as the application developer at CertKiller.com. You create a new class library, which 
contains the Department class. The class library is accessed by numerous applications. The 
Department class has this definition: 

Public Class Department 
Public name As String 
Public manager As String 
End Class 

Each specific application has its own custom configuration to store department-specific information 
in its application configuration file. The configuration code is as follows: 

<Department> 
<name>Hardware</name> 
<manager>AllyWagner</manager> 
</Department> 

You must define the code segment that creates a Department object instance. You must ensure 
that the field values retrieved from the application configuration file is used to create the 
Department object instance. Choose the code segment which will achieve your goal in these circumstances. 

A. Public Class deptElement 
Inherits ConfigurationElement 
Protected Overrides Sub DeserializeElement( _ 
ByVal reader As XmlReader, _ 
ByVal serializeCollectionKey As Boolean) 
Dim dept As Department = New Department() 
dept.name = ConfigurationManager.AppSettings("name") 
dept.manager = _ 
ConfigurationManager.AppSettings("manager") 
End Sub 
End Class 


B. Public Class deptElement 
Inherits ConfigurationElement 
Protected Overrides Sub DeserializeElement( _ 
ByVal reader As XmlReader, _ 
ByVal serializeCollectionKey As Boolean) 
Dim dept As Department = New Department() 
dept.name = reader.GetAttribute("name") 
dept.manager = reader.GetAttribute("manager") 
End Sub 
End Class 
C. Public Class deptHandler 
Implements IConfigurationSectionHandler 
Public Function Create(ByVal parent As Object, _ 
ByVal configContext As Object, _ 
ByVal section As System.Xml.XmlNode) As Object _ 
Implements IConfigurationSectionHandler.Create 
Dim dept As Department = new Department() 
dept.name = section.SelectSingleNode("name").InnerText 
dept.manager = _ 
section.SelectSingleNode("manager").InnerText 
Return dept 
End Function 
End Class 
D. Public Class deptHandler 
Implements IConfigurationSectionHandler 
Public Function Create(ByVal parent As Object, _ 
ByVal configContext As Object, _ 
ByVal section As System.Xml.XmlNode) As Object _ 
Implements IConfigurationSectionHandler.Create 
Dim dept As Department = new Department() 
dept.name = section.Attributes("name").Value 
dept.manager = section.Attributes("manager").Value 
Return dept 
End Function 
End Class 





















Answer: C 











QUESTION NO: 335 

You work as the application developer at CertKiller.com. You write the definition for a class named 
Vehicle by defining the following code segment: 

Public Class Vehicle 
<XmlAttribute(AttributeName:="category")> _ 
Public vehicleType As String 
Public model As String 
<XmlIgnore> _ 
Public year As Integer 
<XmlElement(ElementName:="mileage")> _ 

Public miles As Integer 
Public condition As ConditionType 
Public Sub New() 
End Sub 
Public Enum ConditionType 
<XmlEnum("Poor")> BelowAverage 
<XmlEnum("Good")> Average 
<XmlEnum("Excellent")> AboveAverage 
End Enum 
End Class 

You next create an instance of the Vehicle class, and add the following data in the defined fields of 
the class instance: 
You must now identify the XML block that is generated when the Vehicle class instance is 
serialized. 

Choose the XML block that signifies the output of serializing the Vehicle class instance. 

A. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"" 
vehicleType="car"> 
<model>racer</model> 
<miles>15000</miles> 
<condition>AboveAverage</condition> 
</Vehicle> 
B. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
category="car"> 
<model>racer</model> 
<mileage>15000</mileage> 
<condition>Excellent</condition> 
</Vehicle> 
C. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
category="car"> 
<model>racer</model> 
<mileage>15000</mileage> 
<conditionType>Excellent</conditionType> 
</Vehicle> 
D. <?xml version="1.0" encoding="utf-8"?> 
<Vehicle 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"> 
<category>car</category> 
<model>racer</model> 
<mileage>15000</mileage> 
<condition>Excellent</condition> 
</Vehicle> 




















Answer: B 

Explanation: 

The XML produced in B matches the class definition provided in the question. 

Category is declared to be an attribute of the Vehicle element, this is not the case in answer A 
and D. 

During XML Serialization by default the user type variables are mapped to XML elements. In the 
case of answer C, the type itself has been mapped instead of the instance variable. 











QUESTION NO: 336 

You work as the application developer at CertKiller.com. You create a method which will compress 
an array of bytes. A parameter named document is used to pass the array to your method. 

You want to compress the received array of bytes or data, and then want to return the result as an 
array of bytes. 

Choose the code segment which will achieve your goal. 

A. Dim objStream As New MemoryStream(document) 
Dim objDeflate As New DeflateStream(objStream, CompressionMode.Compress) 
Dim result(document.Length) As Byteobj 
Deflate.Write(result, 0, result.Length)Return result 
B. Dim objStream As New MemoryStream(document) 
Dim objDeflate As New DeflateStream(objStream, CompressionMode.Compress)obj 
Deflate.Write(document, 0, document.Length)obj 
Deflate.Close()Return objStream.ToArray 
C. Dim objStream As New MemoryStream() 
Dim objDeflate As New DeflateStream(objStream, CompressionMode.Compress)obj 
Deflate.Write(document, 0, document.Length)obj 
Deflate.Close()Return objStream.ToArray 
D. Dim objStream As New MemoryStream() 
Dim objDeflate As New DeflateStream(objStream, CompressionMode.Compress) 
Dim outStream As New MemoryStreamDim b As IntegerWhile (b = objDeflate.ReadByte) 
outStream.WriteByte(CByte(b)) 
End While 
Return outStream.ToArray 




















Answer: C Explanation: 

The document is compressed and written to a new MemoryStream using the Deflate class. Finally 
the compressed data can be returned as an array of bytes using the ToArray method of the 
MemoryStream. 

A does not compress and write the document, instead it is compressing and writing an empty 
array 

B & D are reading and writing to the same document. 











QUESTION NO: 337 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKillerApp11. 

CertKillerApp11 will be used to retrieve values from a custom section of the application 
configuration file. The application configuration file's custom section uses XML as follows: 

<ProjectSection name="NewProject"> 
<role name="it administrator" /> 
<role name="project manager" /> 
<role name="user support" /> 
</ProjectSection> 

You must create a code segment for a class named Role. You want the Role class to be 
initialized, based on values that are retrieved from the custom section of the application 
configuration file. 

Choose the code segment which will accomplish the task. 

A. Public Class RoleInherits ConfigurationElementFriend _ElementName As String = "name" 
<ConfigurationProperty("role")> _ 
Public ReadOnly Property Name() As String 
Get 
Return CType(Me("role"), String) 
End Get 
End Property 
End Class 
B. Public Class Role 
Inherits ConfigurationElement 
Friend _ElementName As String = "role" 
<ConfigurationProperty("name", IsRequired:=True)> _ 
Public ReadOnly Property Name() As String 
Get 
Return CType(Me("name"), String) 
End Get 
End Property 
End Class 

C. Public Class Role 
Inherits ConfigurationElement 
Friend _ElementName As String = "role" 
Private _name As String 
<ConfigurationProperty("name")> _ 
Public ReadOnly Property Name() As String 
Get 
Return _name 
End Get 
End Property 
End Class 
D. Public Class Role 
Inherits ConfigurationElement 
Friend _ElementName As String = "name" 
Private _name As String 
<ConfigurationProperty("role", IsRequired:=True)> _ 
Public ReadOnly Property Name() As String 
Get 
Return _name 
End Get 
End Property 
End Class 




















Answer: B 











QUESTION NO: 338 

You work as the application developer at CertKiller.com. You are defining a new class that will 
compare a specially-formatted string. No default collation comparisons are applicable. 

Choose the code segment which will enable you to implement the IComparable(Of String) 
interface. 

A. Public Class Person 
Implements IComparable(Of String)Public Function CompareTo(ByVal other As String) As 
_Integer Implements IComparable(Of String).CompareTo...End Function 
End Class 

B. Public Class Person 
Implements IComparable(Of String)Public Function CompareTo(ByVal other As Object) As 
_Integer Implements IComparable(Of String).CompareTo...End Function 
End Class 
C. Public Class Person 
Implements IComparable(Of String)Public Function CompareTo(ByVal other As String) _As 
Boolean Implements IComparable(Of String).CompareTo...End Function 
End Class 
D. Public Class Person 
Implements IComparable(Of String)Public Function CompareTo(ByVal other As Object) _As 
Boolean Implements IComparable(Of String).CompareTo...End Function 
End Class 




















Answer: A 











QUESTION NO: 339 

You work as the application developer at CertKiller.com. You are defining a new custom exception 
class. Your code written for the custom exception class is as follows: 

Public Class CustomException 
Inherits ApplicationException 
Public Shared COR_E_ARGUMENT As Int32 = &H80070057 
Public Sub New(ByVal strMessage As String) 
MyBase.New(strMessage) 
HResult = COR_E_ARGUMENT 
End SubEnd Class 

You want to ensure that the new class is used to immediately return control to the COM caller. 
You also want the COM caller to have access to the error code. 

Choose the code segment which you should use to achieve these goals. 

A. Return Marshal.GetExceptionForHR( _ 
CustomException.COR_E_ARGUMENT) 
B. Return CustomException.COR_E_ARGUMENT 
C. Marshal.ThrowExceptionForHR( _ 
CustomException.COR_E_ARGUMENT) 
D. Throw New CustomException("Argument is out of bounds") 




















Answer: D 











QUESTION NO: 340 

You work as the application developer at CertKiller.com. You are working on a new service 
application named CertKillerApp1. CertKillerApp1 periodically calls procedures which are called 
from a method named Method1. The procedures run quite long. You have written the following 
code segment: 

Partial Class CertKillerApp1 Inherits ServiceBase 
Dim blnExit As Boolean = False Protected Overrides Sub OnStart(ByVal args() As String) 
Do 
Method1() 
Loop While Not blnExit 
End Sub 
Protected Overrides Sub OnStop() 
blnExit = True 
End Sub 
Private Sub Method1() 
End SubEnd Class 

You try and start the new service, but find that you cannot. You receive this error message 
instead: Could not start the CertKillerApp1 service on the local computer. Error 1053: The service 
did not respond to the start or control request in a timely fashion. 

You must ensure that CertKillerApp1 starts successfully. 

How will you accomplish the task? 

A. Shift the loop code into the constructor of the service class from the OnStart method. 
B. Drag a timer component to the design surface of the service, and then shift the calls to the long-
running procedure from the OnStart method into the Tick event procedure of the timer. Configure 
the Enabled property of the timer as True. Call the Start method of the timer from the OnStart 
method. 
C. Add a class-level System.Timers.Timer variable to the service class code. Shift the call to the 
Method1 method into the Elapsed event procedure of the timer. Configure the Enabled property of 
the timer as True. Call the Start method of the timer from the OnStart method. 
D. Shift the loop code from the OnStart method into the Method1 method. 




















Answer: C 









QUESTION NO: 341 

You work as the application developer at CertKiller.com. You have to create a new security policy 
for an application domain which must enforce the new CertKiller.com security policy. You write the 
code segment to do this: 


Dim objPolicy As PolicyLevel = PolicyLevel.CreateAppDomainLevelDim noTrustStatement As 
New PolicyStatement( _ 
objPolicy.GetNamedPermissionSet("Nothing")) 
Dim fullTrustStatement As New PolicyStatement( _ 
objPolicy.GetNamedPermissionSet("FullTrust")) 


You must now ensure that all loaded assemblies default to the Nothing permission set. In addition 
to this, when an assembly comes from a trusted zone, your security policy must grant the 
assembly the FullTrust permission set. You must create the code groups to do this. 


Choose the code segment which will achieve this objective. 


A. Dim objGroup1 As CodeGroup = New FirstMatchCodeGroup( _ 
New ZoneMembershipCondition(SecurityZone.Trusted), _ 
fullTrustStatement) 
Dim objGroup2 As CodeGroup = New UnionCodeGroup( _ 
New AllMembershipCondition, noTrustStatement) 
B. Dim objGroup1 As CodeGroup = New FirstMatchCodeGroup( _ 
New AllMembershipCondition, noTrustStatement) 
Dim objGroup2 As CodeGroup = New UnionCodeGroup( _ 
New ZoneMembershipCondition(SecurityZone.Trusted), _ 
fullTrustStatement) 
C. Dim objGroup As CodeGroup = New UnionCodeGroup( _ 
New ZoneMembershipCondition(SecurityZone.Trusted), _ 
fullTrustStatement) 
D. Dim objGroup As CodeGroup = New FirstMatchCodeGroup( _ 
New ZoneMembershipCondition(SecurityZone.Trusted), _ 
fullTrustStatement) 




















Answer: B 











QUESTION NO: 342 

You work as the application developer at CertKiller.com. You are developing a new client 
application named CertKillerApp09. CertKillerApp09 must have a utility screen. The screen must 
show a thermometer; which must indicate what the current status of processes are which are being executed by the application. 

A rectangle, which will be the background of the thermometer, must be drawn on the screen. The 
rectangle must be filled with gradient shading, as shown in the accompanying exhibit. 


Which code segment should you use to accomplish the task? 

A. Dim objRect As New Rectangle(10, 10, 450, 25) 
Dim objBrush As New LinearGradientBrush( _objRect, Color.AliceBlue, Color.CornflowerBlue, 
_LinearGradientMode.ForwardDiagonal) 
Dim objPen As New Pen(objBrush) 
Dim g As Graphics = myForm.CreateGraphicsg.DrawRectangle(objPen, objRect) 
B. Dim objRect As New Rectangle(10, 10, 450, 25) 
Dim objBrush As New LinearGradientBrush( _ 
objRect, Color.AliceBlue, Color.CornflowerBlue, _ 
LinearGradientMode.ForwardDiagonal) 
Dim objPen As New Pen(objBrush) 
Dim g As Graphics = myForm.CreateGraphicsg.FillRectangle(objBrush, objRect) 
C. Dim objRect As New RectangleF(10.0F, 10.0F, 450.0F, 25.0F) 
Dim points() As System.Drawing.Point = _ 
{New Point(0, 0), New Point(110, 145)} 
Dim objBrush As New LinearGradientBrush( _ 
objRect, Color.AliceBlue, Color.CornflowerBlue, _ 
LinearGradientMode.ForwardDiagonal) 
Dim objPen As New Pen(objBrush) 
Dim g As Graphics = myForm.CreateGraphicsg.DrawPolygon(objPen, points) 
D. Dim objRect As New Rectangle(10, 10, 450, 25) 
Dim objBrush As New SolidBrush(Color.AliceBlue) 
Dim objPen As New Pen(objBrush) 
Dim g As Graphics = myForm.CreateGraphicsg.DrawRectangle(objPen, objRect) 




















Answer: B 

Explanation: 

Create a LineGradientBrush and supply to the FillRectangle() method of the graphics object. 

A DrawRectangle() will draw the outline of a rectangle without filling it. 

C draws an unfilled Polygon.. D Uses a SolidBrush and will not achieve the desired gradient fill 











QUESTION NO: 343 

You work as the application developer at CertKiller.com. You must create a code segment that will 
identify the first 100 bytes from a stream variable named CertKillerstream5. 

The initial 100 bytes must be transferred to a byte array named byteArray. The code segment you 
write must assign the transferred bytes to an integer variable named bytesTransferred 

Choose the code segment which you should use. 

A. bytesTransferred = CertKillerstream5.Read(byteArray, 0, 100) 
B. For i As Integer = 1 To 100 
CertKillerstream5.WriteByte(byteArray(i)) 
bytesTransferred = i 
If Not CertKillerstream5.CanWrite Then 
Exit For 
End If 
Next 
C. While bytesTransferred < 100 
CertKillerstream5.Seek(1, SeekOrigin.Current) 
byteArray(bytesTransferred) = _ 
Convert.ToByte(CertKillerstream5.ReadByte())bytesTransferred += 1End While 
D. CertKillerstream5.Write(byteArray, 0, 100)bytesTransferred = byteArray.Length 




















Answer: A 

Explanation: 

The Read() method accepts a byte array and the start position and number of bytes to read as 
parameters. 

B & D The question indicates that data should be read from the stream not written to it. 

C it is unnecessary to attempt to read byte by byte, the Read() method provides a very efficient 
way of reading into a byte array. 











QUESTION NO: 344 

You work as the application developer at CertKiller.com. You are developing a new application 
named CertKiller06. CertKiller06 will be used by users to perform an electronic survey that 
contains 30 True-or-False based questions. You must set each answer to True. You also want to limit the amount of memory used by each 
survey. 

Choose the storage option that you should use. 

A. Dim answers As New BitVector32(1) 
B. Dim answers As New BitVector32(-1) 
C. Dim answers As New BitArray(1) 
D. Dim answers As New BitArray(-1) 




















Answer: B 

Explanation: 

C & D BitVector32 is more efficient than a BitArray when 32 or less binary flags are required. 
Primarily because it is a value type. 

Note: we are not sure why B is preferred to A. 











QUESTION NO: 345 

You work as the application developer at CertKiller.com. You are working on a new method 
named PersistToDB. PersistToDB returns no value, and takes the EventLogEntry parameter type. 

You must create the specific code segment which will enable you to test whether the new method 
works as expected. The code segment you use must be able to access entries from the 
application log of local computers, and must then pass only specific entries on to PersistToDB. 
The relevant entries to be passed to PersistToDB are Error events and Warning events from the 
source named mySource. 

Choose the code segment which would achieve your goal in these circumstances. 

A. Dim myLog As New EventLog("Application", ".") 
For Each entry As EventLogEntry In myLog.Entries 
If entry.Source = "MySource" Then 
PersistToDB(entry) 
End If 
Next 
B. Dim myLog as New EventLog("Application", ".") 
myLog.Source = "MySource" 
For Each entry As EventLogEntry In myLog.Entries 
If entry.EntryType = (EventLogEntryType.Error And _ 
EventLogEntryType.Warning) Then 
PersistToDB(entry) 
End If 
Next 

C. Dim myLog as New EventLog("Application", ".") 
For Each entry As EventLogEntry In myLog.Entries 
If entry.Source = "MySource" Then 
If (entry.EntryType = EventLogEntryType.Error) Or _ 
(entry.EntryType = EventLogEntryType.Warning) Then 
PersistToDB(entry) 
End If 
End If 
Next 
D. Dim myLog as New EventLog("Application", ".") 
myLog.Source = "MySource" 
For Each entry As EventLogEntry In myLog.Entries 
If (entry.EntryType = EventLogEntryType.Error) Or _ 
(entry.EntryType = EventLogEntryType.Warning) Then 
PersistToDB(entry) 
End If 
Next 




















Answer: C 

Explanation: 

It is necessary to create a new Application EventLog, iterate over all the EventLogEntries and call 
the PersistToDB method if the entry is a warning or error and the source is MySource. 

A will PersistToDb irrespective of the type of log entry. The question explicitly states only warnings 
and errors should be persisted. 

B features an incorrect test for warnings and errors. 

D&B do not ensure that only MySource entries are persisted. Instead they overwrite the source. 











QUESTION NO: 346 

You work as the application developer at CertKiller.com. You are developing a new method that 
must compress an array of bytes. The array of bytes which should be compressed must be 
passed to the method in a parameter named document 

Choose the code segment which will perform your task. A. Dim inStream As New MemoryStream(document) 
Dim zipStream As New GZipStream( _inStream, CompressionMode.Compress) 
Dim result(document.Length) As BytezipStream.Write(result, 0, result.Length)Return result 
B. Dim objStream As New MemoryStream(document) 
Dim zipStream As New GZipStream( _ 
objStream, CompressionMode.Compress)zipStream.Write(document, 0, 
document.Length)zipStream.Close()Return objStream.ToArray 
C. Dim outStream As New MemoryStreamDim zipStream As New GZipStream( _outStream, 
CompressionMode.Compress)zipStream.Write(document, 0, 
document.Length)zipStream.Close()Return outStream.ToArray 
D. Dim objStream As New MemoryStream(document) 
Dim zipStream As New GZipStream( _objStream, CompressionMode.Compress) 
Dim outStream As New MemoryStreamDim b As IntegerWhile (b = 
zipStream.ReadByte)outStream.WriteByte(CByte(b)) 
End WhileReturn outStream.ToArray 




















Answer: C 











QUESTION NO: 347 

You work as the application developer at CertKiller.com. You are developing a class definition. 
Your class definition must be able to interoperate with COM applications. 

You must create a code segment that will allow COM applications to create instances of the class. 
COM applications must also be able to call the method named GetAddress. 

Choose the code segment which you should use. 

A. Public Class Customer 
Private m_AddressString As String 
Public Sub New(ByVal Address As String) 
m_AddressString = Address 
End Sub 
Public Function GetAddress() As String 
Return m_AddressString 
End Function 
End Class 
B. Public Class Customer 
Shared m_AddressString As String 
Public Sub New() 
End Sub 
Public Shared Function GetAddress() As String 
Return m_AddressString 
End Function 
End Class 

C. Public Class Customer 
Private m_AddressString As String 
Public Sub New() 
End Sub 
Public Function GetAddress() As String 
Return m_AddressString 
End Function 
End Class 
D. Public Class Customer 
Private m_AddressString As String 
Public Sub New() 
End Sub 
Private Function GetAddress() As String 
Return m_AddressString 
End Function 
End Class 




















Answer: C 

Explanation: 

The class should be declared with a parameter less constructor and the getAddress() method 
should be public. 

A uses a constructor with Parameters. 

B uses static members that are not supported in COM 

D the method GetAddress() must be public to be accessible by COM. 











QUESTION NO: 348 

You work as the application developer at CertKiller.com. You are developing a new application 
that will print a report. The report must list language codes and region codes. 

Choose the code segment that will accomplish this task. 

A. For Each objCulture As CultureInfo In _CultureInfo.GetCultures(CultureTypes.SpecificCultures) 
...Next 
B. Dim objCulture As New CultureInfo("") 
Dim objTypes As CultureTypes = objCulture.CultureTypes 
... 
C. For Each objCulture As CultureInfo In _CultureInfo.GetCultures(CultureTypes.NeutralCultures) 
...Next 
D. For Each objCulture As CultureInfo In 
_CultureInfo.GetCultures(CultureTypes.ReplacementCultures) 
...Next 




















Answer: A 

Explanation: 

CultureTypes.SpecificCultures will filter all language codes that are specific to a country\region. 

B The CultureInfo object created is not associated with any cultures. 

C will yield only neutral cultures, they will not be specific to a country\region. 

D Replacement cultures are user-defined custom cultures. 











QUESTION NO: 349 

You work as the application developer at CertKiller.com. You create a class named CertKillerAge. 
You want the Age objects to be sorted. 

Choose the code segment which you should use. 

A. Public Class Age 
Public Value As Integer 
Public Function CompareTo(ByVal obj As Object) As Object 
If TypeOf obj Is Age Then 
Dim _age As Age = CType(obj, Age) 
Return Value.CompareTo(obj) 
End If 
Throw New ArgumentException("object not an Age") 
End Function 
End Class 
B. Public Class Age 
Public Value As Integer 
Public Function CompareTo(ByVal iValue As Integer) As Object 
Try 
Return Value.CompareTo(iValue) 
Catch 
Throw New ArgumentException ("object not an Age") 
End Try 
End Function 
End Class 

C. Public Class Age 
Implements IComparable 
Public Value As Integer 
Public Function CompareTo(ByVal obj As Object) As Integer _ 
Implements IComparable.CompareTo 
If TypeOf obj Is Age Then 
Dim _age As Age = CType(obj, Age) 
Return Value.CompareTo(_age.Value) 
End If 
Throw New ArgumentException("object not an Age") 
End Function 
End Class 
D. Public Class Age 
Implements IComparable 
Public Value As Integer 
Public Function CompareTo(ByVal obj As Object) As Integer _ 
Implements IComparable.CompareTo 
Try 
Return Value.CompareTo((CType(obj, Age)).Value) 
Catch 
Return -1 
End Try 
End Function 
End Class 




















Answer: C 











QUESTION NO: 350 

You work as the application developer at CertKiller.com. You are working on a component which 
serializes the Meeting class instances. The definition of the Meeting class is as follows: 

Public Class Meeting 
Private title As String 
Public roomNumber As Integer 
Public invitees As String() 
Public Sub New() End Sub 
Public Sub New(ByVal t As String) 
title = t 
End Sub 
End Class 


You configure the following procedure for your component: 


Dim myMeeting As New Meeting("Objectives") 
myMeeting.roomNumber = 20 
Dim attendees As String() = New String(1) {" Amy", " Ally"} 
myMeeting.invitees = attendees 
Dim xs As New XmlSerializer(GetType(Meeting)) 
Dim writer As New StreamWriter("C:\Meeting.xml") 
xs.Serialize(writer, myMeeting) 
writer.Close() 


You want to find out which XML block will be written to the C:\Meeting.xml file when the procedure 
is executed. 


Choose the XML block that shows which content will be written to the C:\Meeting.xml file? 


A. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<title>Goals</title> 
<roomNumber>20</roomNumber> 
<invitee>Amy</invitee> 
<invitee>Ally</invitee> 
</Meeting> 
B. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
<string> Ally</string> 
</invitees> 
</Meeting> 
C. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
title="Objectives"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
<string>Ally</string> 
</invitees> 
</Meeting> 


D. <?xml version="1.0" encoding="utf-8"?> 
<Meeting xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> 
<roomNumber>20</roomNumber> 
<invitees> 
<string>Amy</string> 
</invitees> 
<invitees> 
<string>Ally</string> 
</invitees> 
</Meeting> 




















Answer: B 

Explanation: 

A & C show title member in the XML. Title is a private member hence will not be serialized to XML. 

D Shows multiple Invitees. There is only one object of type Invitees in the class definition. 











QUESTION NO: 351 

You work as the application developer at CertKiller.com. You create a code segment which will 
implement the class named CertKillerClass1. The code segment is shown here: 

Public Class NewClass 
Public Function MyMethod(ByVal Arg As Integer) As Integer 
Return Arg 
End Function 
End Class 

You want the CertKillerClass1.MyMethod function to be dynamically called from a separate class 
within the assembly. 

Choose the code segment which you should use to accomplish the task. A. Dim objNewClass As New NewClassDim objType As Type = objNewClass.GetTypeDim objInfo 
As MethodInfo = _ 
objType.GetMethod("MyMethod") 
Dim objParams() As Object = {1} 
Dim i As Integer = _ 
DirectCast(objInfo.Invoke(Me, objParams), Integer) 
B. Dim objNewClass As New NewClassDim objType As Type = objNewClass.GetTypeDim objInfo 
As MethodInfo = objType.GetMethod("MyMethod") 
Dim objParams() As Object = {1} 
Dim i As Integer = _ 
DirectCast(objInfo.Invoke(objNewClass, objParams), Integer) 
C. Dim objNewClass As New NewClassDim objType As Type = objNewClass.GetTypeDim objInfo 
As MethodInfo = _ 
objType.GetMethod("NewClass.MyMethod") 
Dim objParams() As Object = {1} 
Dim i As Integer = _ 
DirectCast(objInfo.Invoke(objNewClass, objParams), Integer) 
D. Dim objType As Type = Type.GetType("NewClass") 
Dim objInfo As MethodInfo = objType.GetMethod("MyMethod") 
Dim objParams() As Object = {1} 
Dim i As Integer = _ 
DirectCast(objInfo.Invoke(Me, objParams), Integer) 




















Answer: B 

Explanation: 

Use reflection to get MethodInfo object that corresponds to the MyMethod member function. Call 
the Invoke() method of MethodInfo 

A & D the Invoke method requires the object that the method will fire upon if its an instance 
method. myClass should have been passed. 

C the getMethod() does not require the classname . 











QUESTION NO: 352 

You work as the application developer at CertKiller.com. You create a class library that contains a 
class hierarchy. The class hierarchy is specified in this code segment: 

01 Public Class Group 
02 Public Employees As Employee() 
03 End Class 04 
05 Public Class Employee 
06 Public Name As String 
07 End Class 
08 
09 Public Class Manager 
10 Inherits Employee 
11 Public Level As Integer 
12 End Class 

Line numbers are only shown above for reference purposes. 

You create an instance of the Group class, and then populate the fields of the Group class's 
instance. 

You use the Serialize method of the XmlSerializer class to serialize the instance. You realize that 
the attempt is unsuccessful when you receive InvalidOperationException, and an error message 
which states this: "There was an error generating the XML document." 

You must perform the necessary configuration which will allow you to use the Serialize method of 
the XmlSerializer class to serialize the instances. You want the XML output to include elements for 
all public fields in the class hierarchy. 

What should you do to achieve your goal in these circumstances? 

A. Add this code segment between lines 01 and 02 of the code segment: 
<XmlArrayItem(Type:=GetType(Employee))> _ 
<XmlArrayItem(Type:=GetType(Manager))> _ 
B. Add this code segment between lines 01 and 02 of the code segment: 
<XmlElement(Type:=GetType(Employee))> _ 
C. Add this code segment between lines 01 and 02 of the code segment: 
<XmlArray(ElementName:="Employees")> _ 
D. Add this code segment between lines 05 and 06 of the code segment: 
<XmlElement(Type:=GetType(Employee))> 
And 
Add this code segment between lines 10 and 11 of the code segment: 
<XmlElement(Type:=GetType(Manager))> 




















Answer: A 

"Pass Any Exam. Any Time." 

